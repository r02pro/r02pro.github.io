[["vector.html", "2.2 Numeric Vector, Character Vector, &amp; Logical Vector", " 2.2 Numeric Vector, Character Vector, &amp; Logical Vector In the last section, you have had a basic understanding of R objects and how to do object assignments. From this section, we will start to introduce different types of R objects one by one. The first R object we want to introduce is called vector. Vector is the simplest object type in R, which contains one or more values of the same type. We will introduce numeric vector, character vector, and logical vector in this section. Let’s begin with numeric vector. 2.2.1 Numeric vector a. Create numeric vectors A numeric vector is a type of vector that only contains values of numeric type. For example, 6 is a numeric vector with one element of value 6. For vectors, the number of elements corresponds to the length of vector, so 6 is a numeric vector with length 1. After assigning the value 6 to the name x1, you have created another numeric vector x1 which has the same value with 6, you can refer to x1 in the following calculations. 6 #a numeric vector with length 1 x1 &lt;- 6 #x1 is also a numeric vector with length 1 x1 #check the value of x1 But can a numeric vector contain more than one values? The answer is a big YES! In R, you can use the c() function (c is short for combine) to combine elements into a numeric vector. c(1, 3, 3, 5, 5) #use c() to combine elements into a numeric vector with length 5 y1 &lt;- c(1, 3, 3, 5, 5) #y1 is also a numeric vector with length 5 y1 #check the value of y1 length(y1) #length of a vector In this example, you have created a length-5 object using the c() function with arguments containing the five elements separated by comma. Since the value of each element is number here, the object is a numeric vector. If you assign the values to the name y1, you will get a new numeric vector with 5 values. Notice that the second element and the third element have the same value 3 in y1. You can verify the contents of y1 and check the length of it through the length() function. If you write several numeric vectors in c(), you will also create a numeric vector. For example, you can create a numeric vector with values from two numeric vectors. Of course you can create a new numeric vector z1 by doing object assignments. c(c(1,2), c(3,4)) #use c() to combine several numeric vectors into a numeric vector z1 &lt;- c(c(1,2), c(3,4)) z1 length(z1) After creating vectors, you can use the function class() to check its vector type, class(x1) class(y1) class(z1) From the results, you will know that x1, y1 and z1 are both of numeric type, which is the reason why they are called numeric vectors. b. Operations between two vectors Since numeric vectors are made of numbers, you can do arithmetic operations between them, just like the fancy calculator in Section 1.2. If two vectors are of the same length, the calculation is done elementwisely. In other words, R will perform the operation separately for each element. First, let’s create another vector x2 of length 1 and do addition with x1. x2 &lt;- 3 x1 + x2 #&gt; [1] 9 Then obviously you will get 9! Similarly, you can create another vector y2 of the same length as vector y1. Then, you can do operations between y1 and y2. y2 &lt;- c(2, 4, 1, 3, 2) y1 + y2 #&gt; [1] 3 7 4 8 7 The result is yet another length-5 vector. To check the calculation was indeed done elementwisely, you can verify that the value of the first element is \\(1 + 2 = 3\\), and value of the second element is \\(3 + 4 = 7\\), etc. Since the calculation is done elementwisely, we normally would want the two vectors to have the same length. However, there is a recycling rule in R, which is sometimes quite useful and enables us to write simpler code. Specifically, if one vector is shorter than the other vector, R will recycle (repeat) the shorter vector until it matches in length with the longer one. This recycling is particularly helpful for an operator between a length&gt;1 vector and a length-1 vector. Let’s see an example. y1 + x1 #&gt; [1] 7 9 9 11 11 From the result, you can see that each element in y1 is added by 6. The followings are a few additional examples you can try. y1 * x2 y1 / 5 y2 - x1 2.2.2 Character vector character/letter a. Create character vectors Now, let’s move to character vectors. In a character vector, the value of each element is of character type, which means each value is a string. A string is a sequence of characters (including letters, numbers, or symbols) surrounded by a pair of double quotes (\"\") or single quotes (''). To be consistent, we will stick with double quotes in this book. Let’s first create a character vector sheepstudio which only has one element. You can then check the value of this vector by typing its name and verify the vector type by using class(). sheepstudio &lt;- &quot;sheep@007&quot; sheepstudio class(sheepstudio) Double quotes need to be paired in strings. If you miss the right double quote, R will show a plus on the next line, waiting for you to finish the command. If this happens, you can either enter the matching double quote, or press ESC to escape this command. Figure 2.1: Miss the right quotation mark Similar to a numeric vector, you can use the c() function to combine several strings to create a character vector. You can verify the number of strings in the character vector by using length(), and nchar() can help you get the number of characters in each string. animals &lt;- c(&quot;sheep@29&quot;, &quot;pig$29&quot;, &quot;monkey&quot;) animals length(animals) nchar(animals) Note that if you have a vector consisted of numbers with surrounding double quotes, it is also a character vector. (\"4\" and \"29\" are strings) num_vec &lt;- c(4, 29) char_vec &lt;- c(&quot;4&quot;, &quot;29&quot;) class(num_vec) #&gt; [1] &quot;numeric&quot; class(char_vec) #&gt; [1] &quot;character&quot; b. Concatenate several strings into a single string Next, we will introduce how to concatenate several strings into a single string. To do this, you can use the paste() function. First, let’s create a character vector with four elements, four_strings &lt;- c(&quot;This&quot;, &quot;is&quot;, &quot;Sheep@29&quot;, &quot;$Studio&quot;) length(four_strings) #verify the number of strings Then use paste() instead of c(), one_long_string &lt;- paste(&quot;This&quot;, &quot;is&quot;, &quot;Sheep@29&quot;, &quot;$Studio&quot;) one_long_string #&gt; [1] &quot;This is Sheep@29 $Studio&quot; class(one_long_string) length(one_long_string) #verify the number of strings From the results, you can see that one_long_string is a character vector with length 1, and the value of one_long_string is a single string with space between the individual strings. You may notice that the default separator between the individual strings is space. Actually you can change the the separator by setting the sep argument in paste(). For example, you can separate the individual strings with comma, comma &lt;- paste(&quot;This&quot;, &quot;is&quot;, &quot;Sheep@29&quot;, &quot;$Studio&quot;, sep = &quot;,&quot;) comma #&gt; [1] &quot;This,is,Sheep@29,$Studio&quot; If you don’t want to use a separator, you can use the paste0() function. nosep &lt;- paste0(&quot;This&quot;, &quot;is&quot;, &quot;Sheep@29&quot;, &quot;$Studio&quot;) nosep #&gt; [1] &quot;ThisisSheep@29$Studio&quot; c. Change case In character vectors, each string can contain both uppercase and lowercase letters. You can unify the cases of all letters inside a vector. Let’s review the character vector four_strings at first, four_strings &lt;- c(&quot;This&quot;, &quot;is&quot;, &quot;Sheep@29&quot;, &quot;$Studio&quot;) four_strings #&gt; [1] &quot;This&quot; &quot;is&quot; &quot;Sheep@29&quot; &quot;$Studio&quot; Then use the tolower() function to convert all letters to lower case, tolower(four_strings) #&gt; [1] &quot;this&quot; &quot;is&quot; &quot;sheep@29&quot; &quot;$studio&quot; The opposite function of tolower() is toupper(), which converts all letters to upper case, toupper(four_strings) #&gt; [1] &quot;THIS&quot; &quot;IS&quot; &quot;SHEEP@29&quot; &quot;$STUDIO&quot; 2.2.3 Logical vector So far we have created several numeric vectors and character vectors. Some vectors have names, some are not. You can see all the objects you have defined by using the ls() function. ls() #&gt; [1] &quot;ani_char&quot; &quot;animal&quot; &quot;animal_tidy&quot; &quot;animal_wide&quot; &quot;animal_wide_weight&quot; #&gt; [6] &quot;animals&quot; &quot;char&quot; &quot;char_vec&quot; &quot;Code&quot; &quot;comma&quot; #&gt; [11] &quot;d&quot; &quot;dig_num&quot; &quot;dig_num_new&quot; &quot;four_strings&quot; &quot;h&quot; #&gt; [16] &quot;key_mat&quot; &quot;Keys&quot; &quot;logic1&quot; &quot;logic2&quot; &quot;mix_1&quot; #&gt; [21] &quot;mix_2&quot; &quot;mix_3&quot; &quot;my_list&quot; &quot;n&quot; &quot;Name&quot; #&gt; [26] &quot;norm_dat&quot; &quot;norm_dat_1&quot; &quot;norm_dat_2&quot; &quot;norm_dat_3&quot; &quot;nosep&quot; #&gt; [31] &quot;num_vec&quot; &quot;one_long_string&quot; &quot;p&quot; &quot;para_1&quot; &quot;para_2&quot; #&gt; [36] &quot;q&quot; &quot;Section&quot; &quot;sheepstudio&quot; &quot;Type&quot; &quot;weight&quot; #&gt; [41] &quot;x&quot; &quot;x_numeric&quot; &quot;x1&quot; &quot;x2&quot; &quot;x3&quot; #&gt; [46] &quot;y_numeric&quot; &quot;y1&quot; &quot;y2&quot; &quot;year&quot; &quot;z1&quot; As introduced in Section 2.1, another way to check the named objects is via the environment panel as shown in Figure 2.2. Figure 2.2: Environment We can see that the environment panel has two columns, with the first column showing the list of object names, and the second column showing the corresponding information for each object. The information includes the vector type (chr is short for character and num is short for numeric), the vector length, and the first few values of the vector. Note that if the vector is of length 1 (for example x1), the environment will not show the type or the length. Before introducing the logical vector, let’s first learn a function called is.numeric(), which checks whether an object is of numeric type, is.numeric(y1) #Is y1 of numeric type? #&gt; [1] TRUE Similar to is.numeric(), you can also use is.character() function to check if the given object is of character type. is.character(y1) #Is y1 of character type? #&gt; [1] FALSE You may notice that results are TRUE or FALSE from the above codes. Actually, logical vectors are vectors that only use TRUE or FALSE as values. Note that TRUE and FALSE are logical constants in R. Similarly, you can use is.logical() to check if the argument is of logical type, or you can use class() to find out the exact type. logic1 &lt;- c(TRUE, FALSE, TRUE) #you can also use the c() function to create a logical vector is.logical(logic1) class(logic1) You can also use T to represent TRUE and F to represent FALSE in logical vectors. logic2 &lt;- c(T, F, F) is.logical(logic2) class(logic2) It is worth to point out that you don’t want to put a pair of double quotes around TRUE or FALSE when you use them as logical values. If you do that, a character vector will be generated instead. char &lt;- c(&quot;TRUE&quot;, &quot;FALSE&quot;, &quot;TRUE&quot;) is.logical(char) class(char) Note that the keywords TRUE and FALSE are case sensitive, and all letters inside them need to be in upper case. If you change any letter to the lower case, you will get an error, because True is neither a logical constant nor a defined object. tlogic &lt;- True #&gt; Error in eval(expr, envir, enclos): object &#39;True&#39; not found 2.2.4 The coercion rule So far, we have been considering vectors that have values of the same type, namely, numbers, strings, or logical values. In practice, if we have values with a mix of different types in a vector, R will unify all values into the most complex one, which is usually called the cocercion rule. Specifically, R use the following order of complexity (from simple to complex). \\[logical &lt; numeric &lt; character\\] Let’s see a few examples about the coercion. The first example mixes logical values with numbers. mix_1 &lt;- c(TRUE, 7, 24, FALSE) mix_1 #&gt; [1] 1 7 24 0 class(mix_1) #&gt; [1] &quot;numeric&quot; We can see that TRUE will be converted to 1 and FALSE will be converted to 0 when they appear with numbers. The second example mixes numbers with strings. mix_2 &lt;- c(8, &quot;happy&quot;, 26, &quot;string&quot;) mix_2 #&gt; [1] &quot;8&quot; &quot;happy&quot; &quot;26&quot; &quot;string&quot; class(mix_2) #&gt; [1] &quot;character&quot; We can see both 8 and 26 are converted into strings. The final example mixes logical values, numbers and strings. mix_3 &lt;- c(97, TRUE, &quot;pig&quot;) mix_3 #&gt; [1] &quot;97&quot; &quot;TRUE&quot; &quot;pig&quot; class(mix_3) #&gt; [1] &quot;character&quot; We can see that both 97 and TRUE are converted to strings. 2.2.5 Exercise You can run the following code to do the exercise. r02pro(2.2) "]]
