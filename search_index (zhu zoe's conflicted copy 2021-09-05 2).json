[["na.html", "2.8 Missing Values (NA)", " 2.8 Missing Values (NA) In applications, we often encounter the situation where some observations are missing in the data set. In this scenario, R uses NA to represent those observations, indicating they are not available. Let’s see the following example. a &lt;- 1:10 a[11] #&gt; [1] NA Since we define a as a vector of length 10, when we try to access the 11th element of a, it is not available, showing a value of NA. 2.8.1 NA is Contagious NA represents that the underlying value is not available. As a result, for most operations associated with NA, the results will also be NA, showing that NA is contagious. y &lt;- NA y + 3 #&gt; [1] NA y == 3 #&gt; [1] NA As you can see here, since y is NA, indicating the value of y is not available. When you try to calculate y + 3 or y == 3, the answers are clearly not available as well, hence both taking the value NA. The same thing happens when you try to do operations between an NA object and any other object. x &lt;- 3 y + x y == x How about we create another NA object and compare it with y? z &lt;- NA y == z It is again NA, which may be confusing at first. However, keep in mind that since both y and z are not available, there is no way to tell whether they are the same. 2.8.2 Functions on vectors with NA Now, let’s talk about what impact the NA values make for statistical functions. x &lt;- c(1, NA, 3, 4, NA, 2) x #&gt; [1] 1 NA 3 4 NA 2 sum(x) #&gt; [1] NA mean(x) #&gt; [1] NA sd(x) #&gt; [1] NA As you can see, for many functions on vectors, as long as there exists one NA value, the results are often impossible to determine, hence resulting an NA value as well. Typically, you may want to ignore the NA values during the function evaluation. Fortunately, most functions on vectors provides an optional argument na.rm, which takes a logical value, indicating whether to remove NA before applying the function. Let’s see the following examples. sum(x, na.rm = TRUE) #&gt; [1] 10 mean(x, na.rm = TRUE) #&gt; [1] 2.5 sd(x, na.rm = TRUE) #&gt; [1] 1.290994 It is easy to verify that the results are what we expect to get if the NA values are removed. Feel free to try the following codes. x_no_na &lt;- c(1, 3, 4, 2) sum(x_no_na) mean(x_no_na) sd(x_no_na) 2.8.3 Work with NA values When there are NA values in our vector, there is nothing to be afraid of as there are many useful tools we can use. Let’s use x &lt;- c(1, NA, 3, 4, NA, 2) throughout this part. a. find indices with missing values To find indices with missing values, you may be tempted to use the comparison operator introduced in Section 2.6 and compare with NA. Let’s try the following code. x == NA You get a vector of all values equaling NA. This is actually not surprising for the following reason. Given that the NA we are comparing can take any unknown value, any comparison with it will result in an NA value due to the lack of information. Instead of using == for finding missing values, the correct way is to use the is.na() function, which returns a logical vector representing whether each element is missing or not. Then, we can use the which() function to find the indices for the NA values. And the sum() function on the logical vector returns the number of NA values in the vector, following the cocercion rule described in Section 2.5.3. x_na &lt;- is.na(x) #logical vector x_na #&gt; [1] FALSE TRUE FALSE FALSE TRUE FALSE which(x_na) #numeric vector #&gt; [1] 2 5 sum(x_na) #the number of NAs in x #&gt; [1] 2 sum(!x_na) #the number of non-NAs in x #&gt; [1] 4 b. remove missing values Sometimes, you may want to simply remove the missing values. To do that, you can use a logical vector to do vector subsetting introduced in Section 2.6.3. The specific logical vector you want to use is the opposite of the logical vector that represents missing values. x2 &lt;- x[!x_na] x2 c. impute missing values In many applications, naively removing the missing values before doing the analysis may lead to incorrect inference. Usually, it is useful to make the data complete by imputing the missing values. For example, we can use mean imputing or median imputing, which uses the mean or median of the non-missing values. x_impute &lt;- x x_impute[x_na] &lt;- mean(x, na.rm = TRUE) x_impute #&gt; [1] 1.0 2.5 3.0 4.0 2.5 2.0 x #&gt; [1] 1 NA 3 4 NA 2 In x_impute, the 2nd and 5th location of x is replaced by 2.5, the average of the non-missing values of x. d. replace non-standard missing values with NA in the vector Sometimes, the data we collected may not use NA to indicate missingness. For example, in the following vector x3, the value 999 represents the corresponding element is missing. x3 &lt;- c(4, 999, 1, 999, 3, 999, 999) It is highly recommended to convert the values into NA before carrying out any analysis. x3[x3 == 999] = NA x3 #&gt; [1] 4 NA 1 NA 3 NA NA Let’s see another example where both 999 and -999 represent the value is missing. x4 &lt;- c(4, 999, 1, -999, 3, -999, 999) ##999 and -999 are the values indicating missingness x4[x4 %in% c(999, -999)] = NA x4 #&gt; [1] 4 NA 1 NA 3 NA NA 2.8.4 Exercises "]]
