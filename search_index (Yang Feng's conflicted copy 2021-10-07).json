[["dataframe.html", "3.3 Data Frame and Tibble", " 3.3 Data Frame and Tibble So far, we have learned vectors (Chapter 2), matrices (Section 3.1), and arrays (Section 3.2). The three different object types share an important features: they all consist of elements of the same type, namely numeric, character, or logical. In real applications, it is common to have mixed variable types. To accommodate this, let’s introduce a new object type, namely the data frame. 3.3.1 Introduction to Data Frames To create a data frame, you can use the data.frame() function with a collection of vectors of the same length. Let’s see an example of some health conditions of a sheep and a pig over the years 2019, 2020 and 2021. animal &lt;- rep(c(&quot;sheep&quot;, &quot;pig&quot;), c(3,3)) year &lt;- rep(2019:2021, 2) weight &lt;- c(110, 120, 140, NA, 300, 800) height &lt;- c(2.2, 2.4, 2.7, 2, 2.1, 2.3) condition &lt;- c(&quot;excellent&quot;, &quot;good&quot;, NA, &quot;excellent&quot;, &quot;good&quot;, &quot;average&quot;) condition &lt;- factor(condition, ordered = TRUE, levels = c(&quot;average&quot;, &quot;good&quot;, &quot;excellent&quot;)) healthy &lt;- c(rep(TRUE, 5), FALSE) my_data_frame &lt;- data.frame(animal, year, weight, height, condition, healthy) my_data_frame ## animal year weight height condition healthy ## 1 sheep 2019 110 2.2 excellent TRUE ## 2 sheep 2020 120 2.4 good TRUE ## 3 sheep 2021 140 2.7 &lt;NA&gt; TRUE ## 4 pig 2019 NA 2.0 excellent TRUE ## 5 pig 2020 300 2.1 good TRUE ## 6 pig 2021 800 2.3 average FALSE Looking at the data frame my_data_frame, it has 6 columns, each of which represents one variable. The variables are of different types. The animal is factor, year is integer, both weight and height are doubles, condition is ordered factor, and healthy is logical. ’ It is worth taking a close look at the type of animal. As you can see the supplied vector animal is a character vector of strings as its values. However, in the process of creating a data frame, it is automatically converted to a factor. This conversion could sometimes be useful for the subsequent statistical analysis, but it could some cause issues. To disable to automatic conversion, you can add the argument stringsAsFactors = FALSE in the data.frame() function. my_df_no_factor &lt;- data.frame(animal, year, stringsAsFactors = FALSE) str(my_df_no_factor) This kind of data representation is impossible using matrices since the coercion rule will apply, converting everything into characters. Let’s combine everything into a matrix and check its value. my_mat &lt;- cbind(animal, year, weight, height, condition, healthy) my_mat ## animal year weight height condition ## [1,] &quot;sheep&quot; &quot;2019&quot; &quot;110&quot; &quot;2.2&quot; &quot;3&quot; ## [2,] &quot;sheep&quot; &quot;2020&quot; &quot;120&quot; &quot;2.4&quot; &quot;2&quot; ## [3,] &quot;sheep&quot; &quot;2021&quot; &quot;140&quot; &quot;2.7&quot; NA ## [4,] &quot;pig&quot; &quot;2019&quot; NA &quot;2&quot; &quot;3&quot; ## [5,] &quot;pig&quot; &quot;2020&quot; &quot;300&quot; &quot;2.1&quot; &quot;2&quot; ## [6,] &quot;pig&quot; &quot;2021&quot; &quot;800&quot; &quot;2.3&quot; &quot;1&quot; ## healthy ## [1,] &quot;TRUE&quot; ## [2,] &quot;TRUE&quot; ## [3,] &quot;TRUE&quot; ## [4,] &quot;TRUE&quot; ## [5,] &quot;TRUE&quot; ## [6,] &quot;FALSE&quot; In the process of creating data frames, you can also name each column. my_data_frame2 &lt;- data.frame(ani = animal, y = year, w = weight, h = height, con = condition, hea = healthy) After creating the data frame, it is useful to examine its class using the class() function and structure using the str() function. class(my_data_frame) ## [1] &quot;data.frame&quot; str(my_data_frame) ## &#39;data.frame&#39;: 6 obs. of 6 variables: ## $ animal : chr &quot;sheep&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; ... ## $ year : int 2019 2020 2021 2019 2020 2021 ## $ weight : num 110 120 140 NA 300 800 ## $ height : num 2.2 2.4 2.7 2 2.1 2.3 ## $ condition: Ord.factor w/ 3 levels &quot;average&quot;&lt;&quot;good&quot;&lt;..: 3 2 NA 3 2 1 ## $ healthy : logi TRUE TRUE TRUE TRUE TRUE FALSE The str() tells us the data frame has 6 observations and 6 variables, along with the type and the first few values of each variable. From the output, you may be puzzled by the $ symbol before each variable name. In fact, you can easily extract a certain column corresponding to a variable with its name. my_data_frame$animal ## [1] &quot;sheep&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; &quot;pig&quot; ## [6] &quot;pig&quot; my_data_frame$weight ## [1] 110 120 140 NA 300 800 In Section 2.5, we introduced the very useful function summary() which gives us important summary statistics for a vector. Using summary() on a data frame, you get get the summary statistics for each variable. summary(my_data_frame) ## animal year weight ## Length:6 Min. :2019 Min. :110 ## Class :character 1st Qu.:2019 1st Qu.:120 ## Mode :character Median :2020 Median :140 ## Mean :2020 Mean :294 ## 3rd Qu.:2021 3rd Qu.:300 ## Max. :2021 Max. :800 ## NA&#39;s :1 ## height condition healthy ## Min. :2.000 average :1 Mode :logical ## 1st Qu.:2.125 good :2 FALSE:1 ## Median :2.250 excellent:2 TRUE :5 ## Mean :2.283 NA&#39;s :1 ## 3rd Qu.:2.375 ## Max. :2.700 ## From the results, you can see that depending on the variable type, you get different forms of summary. In the object my_data_frame, there are two missing values represented by NA. To remove the observations (rows) with NA values, you can use the na.omit() on the data frame. my_df_nona &lt;- na.omit(my_data_frame) my_df_nona ## animal year weight height condition healthy ## 1 sheep 2019 110 2.2 excellent TRUE ## 2 sheep 2020 120 2.4 good TRUE ## 5 pig 2020 300 2.1 good TRUE ## 6 pig 2021 800 2.3 average FALSE You can see that the 3rd and 4th row are removed since they both have a missing observation. 3.3.2 Subsetting Data Frames As a two-dimensional object type, subsetting data frames is very similar to subsetting matrices. a. using indices to do data frame subsetting The first method for data frame subsetting is to specify the desired row indices and column indices, separated by ,. For example, we can extract the (1, 3) and (2, 4) element of x using the following codes. my_data_frame[1, 3] ## [1] 110 my_data_frame[2, 4] ## [1] 2.4 Similar to a matrix subsetting, if you omit the indices of one dimension, R will keep everything along that dimension. You can also use negative indices to keep everything except the provides indices. Let’s see some examples. my_data_frame[2, ] ## animal year weight height condition healthy ## 2 sheep 2020 120 2.4 good TRUE my_data_frame[, 3] ## [1] 110 120 140 NA 300 800 my_data_frame[c(1,3), -c(3,4)] ## animal year condition healthy ## 1 sheep 2019 excellent TRUE ## 3 sheep 2021 &lt;NA&gt; TRUE b. using column names to do data frame subsetting Since data frames usually have column names, you can do subsetting using multiple column names. my_data_frame[, c(&quot;animal&quot;, &quot;weight&quot;)] ## animal weight ## 1 sheep 110 ## 2 sheep 120 ## 3 sheep 140 ## 4 pig NA ## 5 pig 300 ## 6 pig 800 c. using logical vectors to do data frame subsetting Using logical vectors to do data frame subsetting is very useful. Suppose we want to find the condition of the pig in year 2021. is_2021 &lt;- my_data_frame$year == 2021 is_pig &lt;- my_data_frame$animal == &quot;pig&quot; my_data_frame$condition[is_2021 &amp; is_pig] ## [1] average ## Levels: average &lt; good &lt; excellent Now, let’s say we want to extract all the observations with an excellent condition. my_data_frame[my_data_frame$condition == &quot;excellent&quot;, ] ## animal year weight height condition healthy ## 1 sheep 2019 110 2.2 excellent TRUE ## NA &lt;NA&gt; NA NA NA &lt;NA&gt; NA ## 4 pig 2019 NA 2.0 excellent TRUE my_data_frame[which(my_data_frame$condition == &quot;excellent&quot;), ] #remove the NA row ## animal year weight height condition healthy ## 1 sheep 2019 110 2.2 excellent TRUE ## 4 pig 2019 NA 2.0 excellent TRUE 3.3.3 Introduction to tibbles Having learned data frames, we would like to introduce a modern reimagining of data frame, named tibbles. Tibbles are data frames, but make some of the behaviors of data frames to make coding easier. To use the tibble class, you need to install the tibble package, which is part of the tidyverse package. install.packages(&quot;tibble&quot;) After installing the tibble package, you can load the package and create a tibble the same way as you create a data frame. library(tibble) my_tibble &lt;- tibble(animal, year, weight, height, condition, healthy) my_tibble ## # A tibble: 6 x 6 ## animal year weight height condition healthy ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;ord&gt; &lt;lgl&gt; ## 1 sheep 2019 110 2.2 excellent TRUE ## 2 sheep 2020 120 2.4 good TRUE ## 3 sheep 2021 140 2.7 &lt;NA&gt; TRUE ## 4 pig 2019 NA 2 excellent TRUE ## 5 pig 2020 300 2.1 good TRUE ## 6 pig 2021 800 2.3 average FALSE Another way to create a tibble is using the as_tibble() function on a data frame. as_tibble(my_data_frame) ## # A tibble: 6 x 6 ## animal year weight height condition healthy ## &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;ord&gt; &lt;lgl&gt; ## 1 sheep 2019 110 2.2 excellent TRUE ## 2 sheep 2020 120 2.4 good TRUE ## 3 sheep 2021 140 2.7 &lt;NA&gt; TRUE ## 4 pig 2019 NA 2 excellent TRUE ## 5 pig 2020 300 2.1 good TRUE ## 6 pig 2021 800 2.3 average FALSE From the output, we can see that tibble shows the variable type under the name, which is very helpful. Once we have a tibble, let’s learn its class and structure. class(my_tibble) ## [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; str(my_tibble) ## tibble [6 × 6] (S3: tbl_df/tbl/data.frame) ## $ animal : chr [1:6] &quot;sheep&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; ... ## $ year : int [1:6] 2019 2020 2021 2019 2020 2021 ## $ weight : num [1:6] 110 120 140 NA 300 800 ## $ height : num [1:6] 2.2 2.4 2.7 2 2.1 2.3 ## $ condition: Ord.factor w/ 3 levels &quot;average&quot;&lt;&quot;good&quot;&lt;..: 3 2 NA 3 2 1 ## $ healthy : logi [1:6] TRUE TRUE TRUE TRUE TRUE FALSE From the result, you can see that in addition to \"data.frame\", the tibble also has classes of \"tbl_df\" and \"tbl\", which contain many useful functions. We will be using tibbles extensively throughout the rest of book due to its advantages over the original data frames. Lastly, we summarize the different variables types of tibble in the following table. Type Section &amp;lt;chr&amp;gt; character vector &amp;lt;int&amp;gt; integer &amp;lt;dbl&amp;gt; double &amp;lt;ord&amp;gt; ordered factor &amp;lt;fct&amp;gt; unordered factor &amp;lt;lgl&amp;gt; logical vector &amp;lt;date&amp;gt; dates &amp;lt;dttm&amp;gt; date-times "]]
