[["index.html", "R Programming: Zero to Pro Preface", " R Programming: Zero to Pro Yang Feng and r02proers 2024-10-23 Preface This book is for anyone who is interested in learning R and Data Science. It is designed for people with zero background in programming. We also have a companion R package named r02pro, containing the data sets used as well as interactive exercises for each part. "],["contributing-to-the-book.html", "Contributing to the Book", " Contributing to the Book To improve the book, we would like to ask for your help. With your permission, we will be happy to add your name in the Acknowledgment section to show our gratitude. Typos or Grammar Issues If you find any typos or grammar issues, please feel free to directly click the ‘edit’ button. This allows you to fork the repository to your GitHub account, make the necessary changes, and then submit a pull request. General Questions or Feedback If you have more general questions or feedback about any materials in the book, we greatly appreciate if you can write to us at yang.feng@nyu.edu. "],["acknowledgement.html", "Acknowledgement", " Acknowledgement This book is the culmination of numerous concerted efforts and the synergy of diverse minds. We would like to extend our heartfelt gratitude towards Dr. Rebecca Betensky, Dr. Rumi Chunara, and Dr. Hai Shu. Their visionary guidance was instrumental in the initial conceptualization and development of the courses - GPH-GU 2183: Introduction to Statistical Programming in R and GPH-GU 2183: Intermediate Statistical Programming in R. Furthermore, our deepest appreciation goes to the diligent students enrolled in the courses GPH-GU 2183: Introduction to Statistical Programming in R, GPH-GU 2184: Intermediate Statistical Programming in R, and GPH-GU 2182: Statistical Programming in R at New York University. Their participation and commitment significantly enriched the learning process. The roster of contributors to this book is extensive, and each individual’s unique perspective and expertise has helped shape its content in meaningful ways. This text truly stands as a testament to the power of collaboration and the spirit of learning. The list of people who made contributions include Xiaofeng Yang (@well9801), Neethu Grace Johnson (@neethujohnson01), Yifan Lai (@Yifan-Lai), Ruiming Yu (@OmakaseMaster), Zhihao Chen (@edwardzchen), Fan Bi (@fanbithededenne), Rebecca Yu (@rjy2107), Ting Lu (@tinglusince), Yang Yang (@YoArtemis), Jian Li (@kegemor), Grace Lin (@gracexlyhl), Xin Chen (@zoexinchen), Wanyu Hua (@hiWanyu), Fei Hu (@Fei-Hu-1) "],["building-environment.html", "Building Environment", " Building Environment The R session information when compiling this book is shown below. sessionInfo() #&gt; R version 4.2.3 (2023-03-15) #&gt; Platform: aarch64-apple-darwin20 (64-bit) #&gt; Running under: macOS 15.0.1 #&gt; #&gt; Matrix products: default #&gt; BLAS: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib #&gt; LAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib #&gt; #&gt; locale: #&gt; [1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8 #&gt; #&gt; attached base packages: #&gt; [1] stats graphics grDevices utils datasets methods base #&gt; #&gt; other attached packages: #&gt; [1] dplyr_1.1.0 #&gt; #&gt; loaded via a namespace (and not attached): #&gt; [1] pillar_1.8.1 bslib_0.4.2 compiler_4.2.3 jquerylib_0.1.4 #&gt; [5] highr_0.10 tools_4.2.3 digest_0.6.31 bit_4.0.5 #&gt; [9] jsonlite_1.8.4 evaluate_0.20 lifecycle_1.0.3 tibble_3.2.1 #&gt; [13] pkgconfig_2.0.3 rlang_1.1.0 cli_3.6.2 rstudioapi_0.14 #&gt; [17] yaml_2.3.7 parallel_4.2.3 xfun_0.39 fastmap_1.1.1 #&gt; [21] withr_2.5.0 knitr_1.42 generics_0.1.3 vctrs_0.6.5 #&gt; [25] sass_0.4.5 hms_1.1.2 bit64_4.0.5 tidyselect_1.2.0 #&gt; [29] glue_1.6.2 R6_2.5.1 fansi_1.0.4 vroom_1.6.1 #&gt; [33] rmarkdown_2.20 bookdown_0.34 readr_2.1.4 tzdb_0.4.0 #&gt; [37] magrittr_2.0.3 htmltools_0.5.4 ellipsis_0.3.2 utf8_1.2.3 #&gt; [41] cachem_1.0.7 crayon_1.5.2 In the book, package names are in bold text (e.g., r02pro), and inline codes and functions are formatted in a typewriter font (e.g. 1 + 2, r02pro()). We always add parentheses after a function name (e.g. r02pro()). "],["introduction.html", "Chapter 1 Introduction", " Chapter 1 Introduction This chapter begins with the installation of R, RStudio, and R Packages in Section 1.1, shows how to use R as a fancy calculator in Section 1.2, followed by object assignments in Section 1.3. "],["Installation.html", "1.1 Installation of R, RStudio and R Packages", " 1.1 Installation of R, RStudio and R Packages 1.1.1 Download and Install As the first step, you need to download R and RStudio, whose links are as follows. For both software, you need to choose the version that corresponds to your operating system. Download R: https://cloud.r-project.org/ Download RStudio: https://rstudio.com/products/rstudio/download/#download RStudio is an Integrated Development Environment for R, which is powerful yet easy to use. Throughout this book, you will use RStudio instead of R to learn R programming. Without further ado, let’s start with a quick tour of RStudio. 1.1.2 RStudio Interface After opening RStudio for the first time, you may find that the font and button size is a bit small. Let’s see how to customize the appearance. a. Customize appearance On the RStudio menu bar, you can click Tools, and then click on Global Options as shown below. Figure 1.1: Global Options Then, you will see a window popping up like Figure 1.2. After clicking on Appearance, you can see several drop-down menus including Zoom and Editor font size among other choices shown. Zoom controls the overall scale for all elements in the RStudio interface, including the sizes of the menu, buttons, as well as fonts. Editor font size controls the size of the font only in the code editor. Once finishing customizing the appearance, you need to click on Apply to save the adjustments. Figure 1.2: Zoom and Editor font size Here, we change the Zoom to 150% and set the Editor font size to 18. b. Four panels of RStudio Now, the RStudio interface is clearer with a bigger font size. Although RStudio has four panels, not all of them are visible to us at the beginning (Figure 1.3). Figure 1.3: Unfold panels In Figure 1.3, we have labeled three useful buttons as 1, 2, and 3. By clicking buttons 1 and 3, you can reveal the two hidden panels. Note that you may see different panels hidden when you open RStudio for the first time, depending on the RStudio version. However, you can always reveal the hidden panels by clicking the corresponding buttons like Buttons 1 and 3 in Figure 1.3. By clicking button 2, we can clear the content in the bottom left panel (Panel 2 in Figure 1.4) as shown in the following figure. Figure 1.4: Four panels Now, let’s take a close look at all four panels, which are labeled as 1-4 in Figure 1.4. You can change the size of each panel by dragging the two blue slides up or down and the green slide left or right. Located to the left of the green line, Panels 1 and 2 together compose the Code Area. We will introduce them in the following parts of this section. Located to the right of the green line, Panels 3 and 4 together make up the R Support Area. We will introduce these two panels in later sections. c. Console Firstly, we will introduce panel 2 in Figure 1.4, which is usually called the Console. The console window is the place for you to type in codes (i.e. the things you want R to do) and you will get the results immediately once you run the codes. By clicking the mouse on the line after the &gt; symbol, you can see a blinking cursor, indicating that R is ready to accept codes. Let’s type 1 + 2 and press Return (on Mac) or Enter (on Windows). It is a good habit to add spaces around an operator to increase the readability of the code. Figure 1.5: Writing code in the console Figure 1.6: R code(2) Hooray! You have successfully run the first piece of R code and gotten the correct answer 3. Note that the blinking cursor now appears on the next line, ready to accept a new line of code. The curious you may found that there is a [1] showing before the result 3. In fact, the [1] is an index indicator, showing the next element has an index of 1 in this particular object. We will revisit this point when we introduce vectors in the beginning of Chapter 2 . Although the console may work well for some quick calculations, you need to resort to panel 1 in Figure 1.4 (known as the Editor) to save our work and run multiple lines of code at once. d. Editor The Editor panel is the go-to place to write complicated R codes, which you can save as R files for repeated use in the future. Several kinds of files are available in RStudio. In particular, R script, R Markdown, and R Notebook are the three most common file formats. In order to let you get started better, we will start with R script since this is the simplest file format in R. In Chapter 12 and ？？, we will introduce R Markdown and R Notebook in detail. In the editor panel, you may notice that RStudio has created a file by default (Figure 1.7). The default file RStudio provided is R script. Figure 1.7: R script Next, we will introduce how to run codes in scripts. Let’s go to the editor and type 1 + 2. To run this line of code, you can select this line of code and click the Run button. The keyboard shortcut of running this line of code is Cmd+Return on Mac or Ctrl+Enter on Windows. RStudio will then send the line of code to the console and execute the code. Figure 1.8: Run codes in script (I) You can also run multiple lines of code by selecting the lines and clicking the Run button or using the keyboard shortcut. (Figure 1.9) Figure 1.9: Run codes in script (II) Here, three lines of codes are selected. After running these three lines of code together, you can see that the console executes each line of code and you will get the corresponding answer one by one. Therefore, you can write any number of lines of codes in the script, and you can get the answer of each line in the console. After finishing writing codes in the editor, there may be hundreds or more lines of codes in the script. Now, you may wonder if you need to write these codes again when you want to use the same codes next time. The answer is absolutely NO!!! One of the most important features of R files is that R files can be saved for future use. So do R scripts! To do that, you can click the Save button as shown in Figure 1.10. The keyboard shortcut of saving files is Cmd+S on Mac or Ctrl+S on Windows. Figure 1.10: Save (I) Then you would see a pop-up file dialog box, asking you for a file name and location to save it to. Let’s call it lesson1.1 here. Figure 1.11: Save (II) After saving files successfully, you can confirm the name of the R script on the top. Figure 1.12: Save (III) Then if you close this script and open it again, you would directly see the previous three lines of codes without writing them again. Lastly, if you want to create a new R script, you can click the + button on the menu, then select R Script. Note that there are quite a few other options including R Markdown, which will be introduced in Chapter 13. Figure 1.13: create a new script (I) Consequently, you will see a new file created. Figure 1.14: create a new script (II) 1.1.3 Install and load R packages Now, you have had a basic understanding of RStudio, it is time to meet R packages, which greatly extend the capabilities of base R. There are a large number of publicly available R packages. As of July 2021, there are more than 17K R packages on Comprehensive R Archive Network (CRAN), with many others located in Bioconductor, GitHub, and other repositories. To install an R package, you need to use a built-in R function, which is install.packages(). A function takes in arguments (inputs) and performs a specific task accordingly. After the function name, we always need to put a pair of parentheses with the arguments inside. While there are many built-in R functions, R packages usually contain many useful functions as well, and we can also write our own functions, which will be introduced in Chapter 12. With install.packages(), the argument is the package name with a pair of quotation marks around it. The task it performs is installing the specific package into R. Here, you will install the companion package for this book, named r02pro, a.k.a. R Zero to Pro. The r02pro package contains several data sets that will be used throughout the book, and interactive exercises for each subsection. install.packages(&quot;r02pro&quot;) If you miss the right parenthesis, R will return a plus in the next line (as shown in Figure 1.15), waiting for more input to complete the command. If this happens, you can either enter the right parenthesis, or press ESC to escape this command. When you see a blinking cursor after the &gt; symbol, you can write new codes again. Figure 1.15: Miss the right parenthesis After a package is installed, you still need to load it into R before using it. To load a package, you can use the library() function with the package name as its argument. Here, quotation marks are not necessary. library(r02pro) Note that once a package is installed, you don’t need to install it again on the same machine. However, when starting a new R session, you would need to load the package again. Quotation marks are necessary for installing R packages, but are not necessary for loading packages. When installing packages without quotation marks, you will see an error message, showing object not found. install.packages(r02pro) 1.1.4 Exercises Which of the following code used to install packages into R will return an error? install.packages(\"r02pro\") install.packages(r02pro) Write the R code to load the package r02pro Write the R code to calculate 2 + 3. "],["Calculator.html", "1.2 Use R as a Fancy Calculator", " 1.2 Use R as a Fancy Calculator After learning how to run codes in R, we will introduce how to use R as a fancy calculator. 1.2.1 Add comments using “#” Before we get started, the first item we will cover is adding comments for codes. In R, you can use the hash character # at any position of a given line to initiate a comment, and anything after # will be ignored by R. Let’s see an example, 6 - 1 / 2 # first calculate 1/2=0.5, then 6-0.5=5.5 #&gt; [1] 5.5 By running this line of code (either in the console or in the editor!), you will get a value of 5.5, which is the answer of 6 - 1 / 2. As demonstrated, R will not run syntax after the hash character #. Commands and strings after the # are notations or explanations that can make codes easier to understand. Here, the comment informs you the operation order of previous code: the division is calculated before the subtraction. In general, adding comments to codes is a very good practice, as it greatly increases readability and make collaboration easier. We will also add necessary comments in our codes to help you learn R. 1.2.2 Basic calculation Now let’s start to use R as a calculator! In the previous section we introduced operations such as addition, subtraction, multiplication, division, as well as the combination of multiple basic operations. Additionally, you can also calculate the square root, absolute value and the sign of a number. Operation Explanation 1 + 2 addition 1 - 2 subtraction 2 * 4 multiplication 2 / 4 division 6 - 1 / 2 multiple operations sqrt(100) square root abs(-3) absolute value sign(-3) sign 1.2.3 Get help in R While the first seven operations in the above table look intuitive, you may be wondering, what does the sign() function mean there? Is that a stop sign? Sometimes, you may have no idea how a particular function works. Fortunately, R provides a detailed documentation for each function. a. Ask for help First, we will introduce how to ask for help in R, and below are three common ways to seek for more information. Use a question mark followed by the function name, e.g. ?sign Use help function, e.g. help(sign) Use the help window in RStudio, as shown in Figure 1.16. The help window is the panel 4 of Figure 1.4 in Section 1.1. Then type in the function name in the box to the right of the magnifying glass and press return. Figure 1.16: Ask for help b. Documentation for functions After using the above operations to ask for help in R, you can get the documentation of the function in the help window. The documentation consists of different parts, let’s take the sign() function as an example (Figure 1.17), Figure 1.17: Documentation for function This documentation contains the following parts: Description: A text-format introduction of the function of interest. The introduction describes the function’s mechanism, the acceptable input and output types, and some notes of the function. Usage: The way the function looks like. Arguments: A detailed description of the input. Details: A detailed description of the function, including the background, some complicated usage, and special cases of the function. See Also: Some functions related or similar to this function. Examples: Sample codes and their corresponding answers. You can simply copy codes in the Examples part and run them in the editor or in the console. Note that all words after # are comments and will be ignored by R. Here, from the documentation of the sign() function, you will know that the sign() function can return the signs of numbers, which means it will return 0 for zero, return 1 for positive numbers, and return -1 for negative numbers. The documentation of different functions can contain different parts, we will give you the introduction of other functions in the following sections. 1.2.4 Approximation Next, let’s move on to the approximation in R. When computing 7 / 3, the answer is not a whole number as 7 is not divisible by 3. Approximation will come in handy under such circumstances. Let’s take 7 / 3 as the example. a. Get the integer part and the remainder Code Name 7%/%3 integer division 7%%3 modulus We all know that 7 = 3 * 2 + 1. So the integer division will pick up the integer part, which is 2 here; and the modulus will get the remainder, which is 1. b. Get the nearby integer floor(7 / 3) #&gt; [1] 2 ceiling(7 / 3) #&gt; [1] 3 Since 2 &lt;= 7/3 &lt;= 3, you can use the floor function to find the largest integer &lt;= 7/3, which is 2; and the ceiling function gives the smallest integer &gt;= 7/3, which is 3. c. Round to the nearest number round(7 / 3) #&gt; [1] 2 round(7 / 3, digits = 3) #&gt; [1] 2.333 The round() function follows the rounding principle. By default, you will get the nearest integer to 7 / 3, which is 2. If you want to control the approximation accuracy, you can add a digits argument to specify how many digits you want after the decimal point. Here you will get 2.333 after adding digits = 3. 1.2.5 Power &amp; logarithm You can also use R to do power and logarithmic operations. Generally, you can use ^ to do power operations. For example, 10^5 will give us 10 to the power of 5. Here, 10 is the base value, and 5 is the exponent. The result is 100000, but it is shown as 1e+05 in R. That’s because R uses the so-called scientific notation. scientific notation: a common way to express numbers which are too large or too small to be conveniently written in decimal form. Generally, it expresses numbers in forms of \\(m \\times 10^n\\) and R uses the e notation. Note that the e notation has nothing to do with the natural number \\(e\\). Let’s see some examples, \\[\\begin{align} 1 \\times 10^5 &amp;= \\mbox{1e+05}\\\\ 2 \\times 10^4 &amp;= \\mbox{2e+04}\\\\ 1.2 \\times 10^{-3} &amp;= \\mbox{1.2e-03} \\end{align}\\] Another thing to note is that we don’t use commas when writing a big number in R as we do in reports and essays. For example, we need to write 1000000 for a million instead of 1,000,000. In mathematics, the logarithmic operations are inverse to the power operations. If \\(b^y = x\\) and you only know \\(b\\) and \\(x\\), you can do logarithmic operations to solve \\(y\\) using the general form \\(y = \\log(x, b)\\), which is called the logarithm of \\(x\\) with base \\(b\\). In R, logarithm functions with base value of 10, 2, or the natural number \\(e\\) have shortcuts log10(), log2(), and log(), respectively. Let’s see an example of log10(), the logarithm function with base 10. Here, we have added a comment to help you have a better understanding of log10(). 10^6 #&gt; [1] 1e+06 log10(1e6) #log10(x) = log(x, 10) #&gt; [1] 6 Next, let’s see log2(), the logarithm function with base 2. There is also a comment for log2() here. 2^10 #&gt; [1] 1024 log2(1024) #log2(x) = log(x, 2) #&gt; [1] 10 Before moving on to the natural logarithm, note that the natural number \\(e\\) needs to be written as exp(1) in R. When you want to do power operations on \\(e\\), you can simply change the argument in the function exp(). For example, exp(3) is \\(e\\) to the power of 3. Here, log() without specifying the base argument represents the logarithm function with base \\(e\\). You can see the general form of log() in the comment. exp(1) #&gt; [1] 2.718282 exp(3) #&gt; [1] 20.08554 log(exp(3)) #log(x) = log(x, exp(1)) #&gt; [1] 3 1.2.6 Trigonometric function R also provides the common trigonometric functions. cos(pi) #&gt; [1] -1 acos(-1) #&gt; [1] 3.141593 Here, acos() is the inverse function of cos(). If we set \\(cos(a) = b\\), then we will get \\(acos(b) = a\\). sin(pi/2) #&gt; [1] 1 asin(1) #&gt; [1] 1.570796 Similarly, asin() is the inverse function of sin(). If we set \\(sin(a) = b\\), then we will get \\(asin(b) = a\\). tan(pi/4) #&gt; [1] 1 atan(1) #&gt; [1] 0.7853982 Also, atan() is the inverse function of tan(). If we set \\(tan(a) = b\\), then we will get \\(atan(b) = a\\). 1.2.7 Exercises Write R code to compute \\(\\sqrt{5 \\times 5}\\). Write R code to get help on the function floor. Write R code to compute the square of \\(\\pi\\) and round it to 4 digits after the decimal point. Write R code to compute the logarithm of 1 billion with base 1000. Write R code to verify \\(sin^2(x) + cos^2(x) = 1\\), for \\(x = 724\\). "],["Object-Assignment.html", "1.3 Object Assignment", " 1.3 Object Assignment In the last section, you have seen the power of R as a fancy calculator. However, in order to do more complicated and interesting tasks, it is super helpful to store intermediate results for future use. Let’s take a look at a concrete example. Say if you want to do the following three calculations, all involving exp(3) / log(20,3) * 7. (exp(3) / log(20,3) * 7) + 3 #addition (exp(3) / log(20,3) * 7) - 3 #subtraction (exp(3) / log(20,3) * 7) / 3 #division Using R as a fancy calculator (Section 1.2), you need to type the expression exp(3) / log(20,3) * 7 three times, which is a bit cumbersome. In this section, you will learn how to do object assignment, which can avoid the need for typing the same expression more than once. 1.3.1 What is an R Object? Before we get into the details, let’s first introduce object, which is perhaps the most fundamental thing in R. In principle, everything that exists in R is an object. For example, the number 5 is an object, the expression 1 + 2 is an object, and the expression exp(3) / log(20,3) * 7 is also an object. If you run 5, you will get one element of value 5 from the output. Similarly, if you run 1 + 2, you will get one element of value 3 from the output. You can try to run exp(3) / log(20,3) * 7 by yourself. In these three examples, you can see that there is only one element in each object. However, an object can contain more than one elements, and each element has its own value, which is possibly different from that of another element. Naturally, different objects can contain different values. 1.3.2 Assignment Operation with &lt;- With the importance of objects in mind, let’s learn how to do object assignments in R. To do object assignments, you need to assign value(s) to a name via the assignment operator, which will create a new object with the name you specified. Once the object assignment operation is done, you can simply use the name in subsequent calculations without redundancy. Let’s start with a simple example, x_num &lt;- 5 The assignment operation has three components. From left to right， the first component x_num is the object name of a new object, which has certain naming rules that will be discussed shortly in Section 1.3.3. The second component is the assignment operator &lt;-, which is a combination of the less than sign &lt; immediately followed by the minus sign -, with no space in between. The final component is the object name’s assigned value(s), which is 5 here. There is no space between &lt; and - in the assignment operator &lt;-. Note that although = may also appear to be working as the assignment operator, it is not recommended as = is usually reserved for specifying the value(s) of arguments in a function call, which will be introduced in Section 2.1. After running the code above, you will see no output in the console, unlike the situation when we ran 1 + 2 which gives us the answer 3 (as shown in Figure 1.18). You may be wondering, did we successfully make our first assignment operation? Figure 1.18: No output To verify it, you can run the code with just the object name to check its value. (For all named objects, you can get their value(s) by running codes with just their names.) x_num #&gt; [1] 5 Great! The output is 5, indicating that you have successfully assigned the value 5 to the name x_num, and you have created a new object x_num. From now on, you can use x_num instead of 5 to do the subsequent calculations because x_num and 5 have the same value. Note that R object names are case-sensitive. For example, you have defined x_num, but if you type X_num, the console will return an error message as follow. X_num #&gt; Error in eval(expr, envir, enclos): object &#39;X_num&#39; not found In addition, you can assign value(s) of an expression to a name. Let’s try to simplify the three expressions we showed at the beginning of this section. It is easy to observe that the three expressions share a common term exp(3) / log(20,3) * 7. Let’s assign the common term to a name. y_num &lt;- exp(3) / log(20,3) * 7 y_num #&gt; [1] 51.56119 Now you have successfully created an object y_num with value 51.561191. Using the named object y_num, you can simplify the three calculations as follows. y_num + 3 y_num - 3 y_num / 3 Note that in the object assignment process, it is not the expression itself but rather the value(s) of the expression, that is assigned to a name. So you will not get the expression exp(3) / log(20,3) * 7 by running y_num. You can also try the following examples by yourself. z_num1 &lt;- floor(7 / 3) z_num1 z_num2 &lt;- 7%/%3 z_num2 Clearly, using the object assignment, you can greatly simplify the code and avoid redundancy. 1.3.3 Object naming rule As you now see, the assignment operation in R is very straightforward. In general, R is very flexible in the name you can give to an object. However, there are three important rules you need to follow. a. Must start with a letter or . (period) In addition, if starting with period, the second character can’t be a number. b. Can only contain letters, numbers, _ (underscore), and . (period) One recommended naming style is to use lowercase letters and numbers, and use underscore to separate words within a name. So you can use relatively longer names that is more readable. For example, this_is_name_6 and super_rich_88 are great names. c. Can not use special keywords as names. For example, TRUE &lt;- 12 is not permitted as TRUE is a special keyword in R. You can see from the following that this assignment operation leads to an error message. TRUE &lt;- 12 #&gt; Error in TRUE &lt;- 12: invalid (do_set) left-hand side to assignment Some commonly used reserved keywords that cannot be used as names are listed as below. TRUE else FALSE for NA while Inf break NaN next function repeat if return To get a complete list of reserved words, you can run the following code. ?Reserved 1.3.4 Review objects in environment At this point, we’ve introduced the rules of creating objects in R. Now, you can also confirm the success of object assignments by inspecting the Environment, located in the top right panel (panel3 in Figure 1.4 in Section 1.1). If you exercised previous examples, you can find the newly assigned objects x_num and y_num (possibly also z_num1 and z_num2) in your Environment Viewer. You may also notice that the name TRUE, which we tried but failed to assign the value 12 to, doesn’t appear in the Environment (as shown in Figure 1.19). You can check all the named objects and their values in this area. Figure 1.19: The environment (I) From the picture above, you can see that the value of x_num is 5. In this case, let’s try to assign the new value 6 to x_num and see what will happen next. x_num &lt;- 6 x_num #check its value #&gt; [1] 6 Now you can see that the value of x_num has changed from 5 to 6. Generally, when assigning a new value to an object, R will update the object’s value, and the previous value will no longer be stored. You can verify the result by inspecting the Environment tab, where only the new value of the object will be displayed. Figure 1.20: The environment (II) So it is helpful to monitor the environment from time to time to make sure everything looks fine. Notice that objects without names will not be shown in the environment. You can also see the list of all the named objects (just names without values) using the built-in R function ls(). ls() #&gt; [1] &quot;key_mat&quot; &quot;Keys&quot; &quot;x_num&quot; &quot;y_num&quot; All the objects shown in the environment or on the list are stored in the memory, so they are available for us in subsequent codes. It is a good habit to do object assignments if you want to retrieve their values at a later time. 1.3.5 Object types So far in this section, you have learned how to do object assignments. The values you assigned are all numbers, i.e. of numeric type. Actually, an object may contain more than one values. Also, an object may contain values other than the numeric type, such like character and logical ones. Depending on the composition of values, the object belongs to one particular type. Type Section Atomic Vector 2 Matrix 3.1 Array 3.2 Data Frame 3.3 Tibble 3.4 List 3.5 We will focus on atomic vectors in Chapter 2 and discuss other object types in Chapter 3. While some of the object types look more intuitive than others, you have nothing to worry about since we have the next two chapters devoted to the details of R objects. Objects are the building blocks of R programming and it will be time well spent mastering every object type. 1.3.6 Exercises Write the R code to assign the value 20 to the name num_1. Which of the following is a valid object name in R? 2.True else I_am_not_a_valid_name I_am_a_Pretty#_name Write the R code to get the list of all objects in the environment. "],["r-objects.html", "Chapter 2 R Objects (I): Atomic Vectors", " Chapter 2 R Objects (I): Atomic Vectors In this chapter, we focus on the most fundamental R object type: atomic vectors. We will introduce different types of atomic vectors, creating vectors with patterns, applying different functions and operations on vectors, comparing and extracting vectors. We will also discuss data and times, factors, and how R represents unexpected results. "],["intro-num-vector.html", "2.1 Introduction to Numeric Vectors", " 2.1 Introduction to Numeric Vectors We will start off this chapter by learning numeric vectors. Numeric vectors are perhaps the most commonly used member of the atomic vector family, where all elements are of the same type. 2.1.1 Creation and class A numeric vector is an atomic vector containing only numbers. For example, 6 is a numeric vector with one element of value 6. By assigning the value 6 to the name x1, you can create a new numeric vector x1 with value 6. As a result, you can refer to x1 in subsequent calculations. For any vector, you can use the length() function to check the number of elements it contains. 6 #a numeric vector #&gt; [1] 6 x1 &lt;- 6 #x1 is also a numeric vector x1 #check the value of x1 #&gt; [1] 6 length(6) #length of 6 #&gt; [1] 1 length(x1) #length of x1 #&gt; [1] 1 Given the output, you can see that 6 is a numeric vector with length 1 and you have successfully created the numeric vector x1 of length 1. Moving on, you may wonder, can a numeric vector contain more than one value? The answer is a big YES! In R, you can use the c() function (c is short for combine) to store several elements into one single numeric vector. c(1, 3, 3, 5, 5) #use c() to combine elements into a numeric vector of length 5 #&gt; [1] 1 3 3 5 5 y1 &lt;- c(1, 3, 3, 5, 5) #y1 is a numeric vector of length 5 y1 #check the value of y1 #&gt; [1] 1 3 3 5 5 length(y1) #length of y1 #&gt; [1] 5 In this example, firstly you have created a length-5 object using the c() function with arguments being the five elements separated by comma. Since all elements are numbers, this object is still a numeric vector. Then after assigning the values to the name y1, you will get a new numeric vector y1 with 5 elements. Among the five elements, although some of them have the same value, R still recognizes and stores them separately. This is the reason why the length of y1 is 5 instead of 3. Similar to x1, you can verify the contents of y1 and check the length of it via the length() function. When you assign several values to a name, the order of the values will not change after assignment. If you create two numeric vectors containing the same numbers but in different orders, the two vectors will be two different ones maintaining the specified orders. For example, y2 &lt;- c(1, 3, 5, 7, 9) y2 #&gt; [1] 1 3 5 7 9 y3 &lt;- c(9, 7, 5, 3, 1) y3 #&gt; [1] 9 7 5 3 1 In addition to using numbers inside the c() function, you can also use numeric vectors as the arguments to create a longer vector. The new, longer vector will combine the input numeric vectors in the given order. c(x1, y1) #use c() to combine several numeric vectors into one numeric vector #&gt; [1] 6 1 3 3 5 5 z1 &lt;- c(x1, y1) z1 #&gt; [1] 6 1 3 3 5 5 length(z1) #&gt; [1] 6 Since x1 contains 1 numeric value and y1 contains 5 numeric values, z1 is a numeric vector of length 6 after combination. For any vector, you can use the function class() to check its class. A class can be thought of as a “type,” providing a description about the vector and determining what functions can be applied to it. class(x1) #&gt; [1] &quot;numeric&quot; class(y1) #&gt; [1] &quot;numeric&quot; class(z1) #&gt; [1] &quot;numeric&quot; From the results, you can see that x1, y1, and z1 are all numeric, which is the reason why they are called numeric vectors. As introduced in Section 1.3, you can check the named objects via the environment panel as shown in Figure 2.1. Figure 2.1: The environment (I) We can see that the environment panel has two columns, with the first column showing the list of object names and the second column showing the corresponding information for each object. The information includes the vector type (here num is short for numeric), the vector length, and the value(s) of the vector. Note that if the vector is of length 1 (for example x1), the environment will not show the type or the length. In the last section, we have introduced how to change the value of an object by reassigning it. Similarly, you can also assign a new value, or new values, to x1. Notice that the values you are going to assign can have different length with the previous values. Let’s see an example, z1 &lt;- c(6, 1, 3) z1 #check the value of z1 #&gt; [1] 6 1 3 Now, you can see that z1 contains 3 numeric values, so z1 is a numeric vector of length 3. As expected, you can also view the newly assigned values of z1 in the environment panel, as shown in Figure 2.2. Figure 2.2: The environment (II) Finally, you can use the vector(mode, length) function to create a vector of certain mode and length. vector(&quot;numeric&quot;, 4) 2.1.2 Operations and recycling rule Since numeric vectors are purely made of numbers, you can do arithmetic operations between them, just like the fancy calculator in Section 1.2. If two or more vectors are of the same length, the operation is done element-wisely. In other words, R will perform the operation between elements in the same index of different vectors. First, let’s create another vector x2 of length 1 and compute the sum of x1 and x2. Also recall that we’ve previously created a length-1 numeric vector x1 with value 6. x1 #&gt; [1] 6 x2 &lt;- 3 x1 + x2 #&gt; [1] 9 Then obviously you will get 9! If you assign this operation to a name, you will create a new numeric vector with the result of the operation as the value. s1 &lt;- x1 + x2 s1 #&gt; [1] 9 Here, s1 is a length-1 numeric vector with value 9. Similarly, you can create another vector y2 of the same length as vector y1. Then, you can do operations between y1 and y2. y1 #&gt; [1] 1 3 3 5 5 y2 &lt;- c(2, 4, 1, 3, 2) y1 * y2 #&gt; [1] 2 12 3 15 10 The result is yet another length-5 vector. To check the calculation was indeed done element-wisely, you can verify that the value of the first element is \\(1 * 2 = 2\\), and value of the second element is \\(3 * 4 = 12\\), etc. You can also store the result of multiplication for future use by assigning it to a name. s2 &lt;- y1 * y2 s2 #&gt; [1] 2 12 3 15 10 To have the calculation done element-wisely, R requires two or more vectors to have the same length. However, there is an important recycling rule in R, which is quite useful and enables us to write simpler code. Specifically, if one vector is shorter than the other vector, R will recycle (repeat) the shorter vector until it matches in length with the longer one so that element-wise calculations can be done conveniently. This recycling is most often used for an operation between a length&gt;1 vector and a length-1 vector. Let’s see an example. y1 + x1 #&gt; [1] 7 9 9 11 11 From the result, you can see that x1 is recycled five times to match in length with y1, becoming a length-5 numeric vector with five sixes. Subsequently, each element in y1 is added by 6. By now you have created several objects, and you may find that objects will not be saved in R if you don’t assign their values to names, for example, the results of y1 + x1 is not shown in the environment. The followings are a few additional examples you can try. y1 * x2 y1 / 5 y2 - x1 2.1.3 Storage types (doubles and intergers) Now, it is time to learn how numeric vectors are stored in R. To find the internal storage type of an R object, you can use the typeof() function. my_num &lt;- c(1.5, 3, 4) typeof(my_num) #check the internal storage type #&gt; [1] &quot;double&quot; You can see that the internal storage type of my_num is double, meaning that my_num is stored as a double precision numeric value. In fact, R stores numeric vectors as double precision vectors by default. Let’s see another example, my_dbl &lt;- c(3, 4) typeof(my_dbl) #check the internal storage type #&gt; [1] &quot;double&quot; Different from my_num which contains a non-integer (1.5), all elements in my_dbl are integers. However, the storage type of my_dbl is still double, same as my_num. When all values of a numeric vector are integers (such as my_dbl), you can store it as an integer vector, which is also a numeric vector. To do this, you only need to put an “L” after each integer in the vector. Let’s create an integer vector and check its storage type as well as its class. my_int &lt;- c(3L, 4L) typeof(my_int) #&gt; [1] &quot;integer&quot; class(my_int) #&gt; [1] &quot;integer&quot; You can see that the internal storage type of my_int is indeed of integer type, with the class of it being integer as well. It is also worth noting that the displaying value of my_dbl and my_int are the same. my_dbl #&gt; [1] 3 4 my_int #&gt; [1] 3 4 You can also check the vector type and values in the environment. (as shown in Figure 2.3) Figure 2.3: Different storage types From the picture above, you can see that the values of my_int are still 3 and 4, which are the same as those of my_dbl. The difference between these two vectors is that my_int is an integer vector since its internal storage type is integer, and such a storage type offers great memory savings compared to doubles. Notice that a numeric vector’s internal storage type is consistent. Say if you assign multiple numeric values to an object, even when you assign an “L” to most values, as long as the object obtains at least one decimal value, the vector will be stored in R as double. This rule also implies that any numeric vector containing at least one decimal value cannot be transformed to an integer vector. my_num2 &lt;- c(1.5, 3L, 4L) typeof(my_num2) #&gt; [1] &quot;double&quot; class(my_num2) #&gt; [1] &quot;numeric&quot; Moreover, as you can see by running the code below, whenever you put an “L” after an decimal value, you will get the warning and the storage type will remain double. my_num3 &lt;- c(1.5L, 3L, 4L) typeof(my_num3) #&gt; [1] &quot;double&quot; class(my_num3) #&gt; [1] &quot;numeric&quot; In conclusion, all the numeric vectors will be stored as double by default. If all values in a numeric vector are integers, you can convert this numeric vector into an integer vector, and the storage type of this vector will be integer, which can save memories compared to doubles. That being said, don’t get confused: both double and integer vectors belong to numeric vectors. Despite the differences between integers and doubles, you can usually ignore their differences unless you are working on a very big data set. R will automatically convert objects between integers and doubles when necessary. 2.1.4 Printing Now, you have learned numeric vectors along with their possible storage types. In this part, let’s discuss how you can customize the output digit of a number via printing. Let’s start with pi, which is a mathematical constant you may be familiar with. pi is also an internal numeric vector available for use in R, meaning that it will appear in the environment panel without requiring you to assign it to a name. pi #&gt; [1] 3.141593 As you can see from the output, R prints out 7 significant digits by default, though in fact we need infinitely many digits to faithfully represent pi. To print out an object with a customized significant digit number, you can use the print() function that contains useful argument called digits, which controls the number of significant digits to be printed. Let’s see the following examples. You can try the following examples. print(pi, digits = 20) #print pi for 20 significant digits #&gt; [1] 3.141592653589793116 print(pi, digits = 4) #print pi for 4 significant digits #&gt; [1] 3.142 Note that the round() function also has an argument digits, which has a different meaning, representing the number of digits after the decimal point. print(pi, digits = 4) #print pi for 4 significant digits #&gt; [1] 3.142 round(pi, digits = 4) #round pi to 4 decimal places #&gt; [1] 3.1416 You may be wondering whether happens if digits is larger than the number of the actual significant digits of a number. Let’s try the following example. print(1.2, digits = 5) #&gt; [1] 1.2 Clearly, the print() function will print out at most the significant digits of the number. When you print a vector with more than one element, the same number of decimal places is printed for all elements. In this case, the digits parameter represents the minimum number of significant digits, and that at least one element will be encoded with that minimum number. print(c(pi, exp(1), log(2)), digits = 4) #&gt; [1] 3.1416 2.7183 0.6931 print(c(pi, exp(1), log(2), exp(-5)), digits = 4) #&gt; [1] 3.141593 2.718282 0.693147 0.006738 print(c(20000, 1.2, 2.34), digits = 3) #&gt; [1] 20000.00 1.20 2.34 As you can imagine, the print() function will be very useful in creating tables that look more streamlined. 2.1.5 Exercises Write the R code to complete the following tasks. Create a numeric vector named vec_1 with values \\((2, 4, 6, 8)\\), get its length, find out its class, and get its storage type. For the numeric vector vec_2 &lt;- c(1, 3, 7, 10), get the value of the 3rd element, multiple the 3rd element by 5, and verify the change. Create a vector vec_3 where each element is twice the corresponding element in vec_1 minus half the corresponding element in vec_2. Create an integer vector int_1 that contains integers \\((2, 4, 6, 8)\\). Check its class and storage type. Print out the vector \\((e, e^2, e^3)\\) with 5 significant digits. "],["intro-char-vector.html", "2.2 Introduction to Character Vectors", " 2.2 Introduction to Character Vectors After familiarizing yourself with the numeric vectors in Section 2.1, we will introduce another member of the atomic vector family: character vectors. 2.2.1 Creation, class and storage type A character vector is another type of atomic vector (where all elements are of the same type). In a character vector, the value of each element is of character type, which means each element is a string. A string is a sequence of characters (including letters, numbers, or symbols) surrounded by the double quotes (““) or single quotes (''). For consistency, we will stick with double quotes in this book. The first example: if the word book is surrounded by a pair of double quotes, then it is a string, and \"book\" is a character vector with length 1. The value of \"book\" is the string itself. Notice that here \"book\" is a vector without a name since we have not assigned its value to a name, which will be introduced shortly. You can then verify the number of strings in this vector by using length() and verify the vector type by using class(). &quot;book&quot; #&gt; [1] &quot;book&quot; length(&quot;book&quot;) #&gt; [1] 1 class(&quot;book&quot;) #&gt; [1] &quot;character&quot; Now the class() function will return character, which shows that \"book\" is a character vector. After assigning the value to the name r02pro, you have created a new character vector r02pro with “book” as the value. r02pro &lt;- &quot;book&quot; r02pro #&gt; [1] &quot;book&quot; class(r02pro) #&gt; [1] &quot;character&quot; Double quotes need to be paired in strings. If you miss the right double quote, R will show a plus on the next line, waiting for you to finish the command. If this happens, you can either enter the matching double quote, or press ESC to escape this command. Figure 2.4: Miss the right quotation mark Next, let’s create a numeric vector num_vec with number 708. After adding a pair of double quotes around the number 708, “708” has converted to a string now. You can assign the value “708” to a name (say char_vec), which will create a new character vector named char_vec. Don’t forget to check the vector type by using class() if you are not sure. num_vec &lt;- 708 char_vec &lt;- &quot;708&quot; class(num_vec) #&gt; [1] &quot;numeric&quot; class(char_vec) #&gt; [1] &quot;character&quot; Also, strings can contain symbols. For example, you can create a character vector with “gph&amp;708”. char_vec2 &lt;- &quot;gph&amp;708&quot; class(char_vec2) #&gt; [1] &quot;character&quot; In conclusion, if characters (including letters, numbers, and symbols) are surrounded by double quotes, it will be interpreted as a string by the R language. Similar to a numeric vector, you can have multiple elements in a character vector, using the c() function to combine several strings into a single vector. You can verify the number of elements in a vector by using the length() function. Now we know how to obtain the length of a vector, but what about the length of a single element within a given vector? Function nchar() can help us with that, as you will get the number of characters in a string. animals &lt;- c(&quot;sheep%29&quot;, &quot;bear$11&quot;, &quot;monkey@66&quot;) animals #&gt; [1] &quot;sheep%29&quot; &quot;bear$11&quot; &quot;monkey@66&quot; length(animals) #&gt; [1] 3 nchar(animals) #&gt; [1] 8 7 9 As shown in the example, we can see that there are three elements in the animals vector, and string “sheep%29” has a length of 8 (including 5 characters, 1 symbol, and 2 numbers). Similarly, “bear$11” and “monkey@66” have a length of 7 and 9, and you can check it by yourself with the nchar() function. Same as the numeric vector, you can use the typeof() function to find the internal storage type of a character vector. All the character vectors will be stored as the character in R. You can check the storage type of some character vectors we created before. typeof(char_vec) #&gt; [1] &quot;character&quot; typeof(animals) #&gt; [1] &quot;character&quot; Finally, you can use the vector(mode, length) function to create a character vector of certain length. vector(&quot;character&quot;, 6) #&gt; [1] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; Note that the default value is an empty string for all elements. 2.2.2 Change case In character vectors, each string can contain both uppercase and lowercase letters. You can unify the cases of all letters inside a vector. Let’s review the character vector four_strings first, four_strings &lt;- c(&quot;This&quot;, &quot;is&quot;, &quot;R02#&quot;, &quot;$Pro&quot;) four_strings #&gt; [1] &quot;This&quot; &quot;is&quot; &quot;R02#&quot; &quot;$Pro&quot; As one could observe, the vector four_strings contains a mix of uppercase, lowercase, numbers, and symbols. In order to convert all convertible characters in each string to lowercase, you can use the tolower() function. The converted result can be shown directly, or saved as a new vector with your name of preference. For example, after four_strings is passed to tolower(), the returned result was saved to lower_strings. lower_strings &lt;- tolower(four_strings) lower_strings #&gt; [1] &quot;this&quot; &quot;is&quot; &quot;r02#&quot; &quot;$pro&quot; One should also notice that, numbers and symbols within a string will not be changed, as they are non-alphabetic characters. The opposite operation of tolower() is toupper(), which converts all characters in the vector to uppercase. upper_strings &lt;- toupper(four_strings) upper_strings #&gt; [1] &quot;THIS&quot; &quot;IS&quot; &quot;R02#&quot; &quot;$PRO&quot; 2.2.3 Review of getting help in R In Section 1.2.3, we introduced three common ways to get help in R, which can help you know more about a particular function. In this section, we will review these methods by taking toupper and tolower as examples. Use a question mark followed by the function name ?tolower Use help function help(tolower) Use the help window in RStudio Use any of the methods listed above to get the documentation for the function tolower(), and let’s take a detailed look at it. Different from the documentation of the sign() function, you will the title is named “Character Translation and Casefolding” (Figure 2.5). Figure 2.5: Help (I) The Description part describes the general purpose of this function. In this example, all functions introduced in this documentation translate characters in a character vector (from upper to lower case or vice versa). The Usage part shows the expected syntax. This section may contain multiple functions that share similar usage, but with different number and format of input. For example, chartr is expecting three arguments, which is old,new and x, respectively, but tolower and toupper functions is only taking one argument x. The Arguments part provides detailed explanation for argument. Depending on the function, argument could be different from data type to input length, and it is best to read them individually. For our example, you can focus on the explanation of x for tolower and toupper functions for now, as this is the only required input for both of them. Next, let’s move to the Details part, Figure 2.6: Help (II) The Details part explains the mechanism of the functions, as well as what each of them could achieve. The Value part shows the result that the function would return, with specified data attributes and types. For tolower and toupper, since we only covert the cases of characters, the returned character vector will share the same length() as the input vector. Figure 2.7: Help (III) In the last part of the documentation, you can see the notes in the Note part and some functions related to functions introduced in the See Also part. Remember to try some sample codes in the Examples part, and implement your own codes with the help of the examples. At the end of this section, let us review the environment panel. You can see all the character vectors with names in this section. Notice that now the vector type has been changed to chr (here chr is short for character). Figure 2.8: Character vectors You can also see the list of all the named objects by using ls() function. ls() #&gt; [1] &quot;animals&quot; &quot;char_vec&quot; &quot;char_vec2&quot; &quot;four_strings&quot; #&gt; [5] &quot;lower_strings&quot; &quot;num_vec&quot; &quot;r02pro&quot; &quot;upper_strings&quot; 2.2.4 Exercises Write R code to create a numeric vector named vec_1 with values 7 24 8 26, get its length, and find out its type. Write R code to create a character vector named char_1 with values \"I\", \"am\", \"learning\", \"R!\", get its length, find out its type, and concatenate the vector into a single string with space as the separator. For the char_1 defined in Q2, find the number of characters in each string, and convert each string to upper case. Create a length-2 logical vector representing whether vec_1 and char_1 are of character type. "],["intro-logi-vector.html", "2.3 Introduction to Logical Vectors", " 2.3 Introduction to Logical Vectors Having learning numeric vectors (Section 2.1) and character vectors (Section 2.2), it is time to master logical vectors, which is another important type of atomic vectors, containing only logical values. 2.3.1 Logical vectors: creation by comparisons, class, and storage type A logical vector is an atomic vector containing only logical values, mostly TRUE and FALSE. Logical vectors are most omnipresent when we check whether a comparison statement is true or false. Generally, comparisons are more common between numeric vectors since it is easy to compare numbers so that we will take the comparisons between numeric vectors as examples in this section. For two length-1 vectors, the comparison is simply done between the only element of each vector. Let’s create a numeric vector x with value 3, and then compare it with 2 and 1. (Here 2 and 1 are both length-1 numeric vectors) x &lt;- 3 x &lt; 2 #&gt; [1] FALSE x &gt; 1 #&gt; [1] TRUE The value of x &lt; 2 is FALSE since 3 is not smaller than 2, and the value of x &gt; 1 is TRUE since 3 is larger than 1. So x &lt; 2 and x &gt; 1 are both vectors of length 1. Just like numeric and character vectors, you can check the class, length, and storage type of the result of this comparison. Let’s take x &gt; 1 for example. class(x &gt; 1) #&gt; [1] &quot;logical&quot; length(x &gt; 1) #&gt; [1] 1 typeof(x &gt; 1) #&gt; [1] &quot;logical&quot; In addition, you can assign values of logical vectors to names for future use. big_1 &lt;- x &gt; 1 big_1 class(big_1) typeof(big_1) Now, it is clear that x &gt; 1 and big_1 are both logical vectors with length of 1. There are a few other commonly used operators for doing comparisons, which all result in TRUE when the statement is correct, and FALSE otherwise. x &lt; 2 #less than #&gt; [1] FALSE x &lt;= 2 #less than or equal to #&gt; [1] FALSE x &gt; 1 #bigger than #&gt; [1] TRUE x &gt;= 1 #bigger than or equal to #&gt; [1] TRUE x == 3 #equal to #&gt; [1] TRUE #x = 3 #another assignment operator in addition to `&lt;-`, NOT comparison x != 3 #not equal to #&gt; [1] FALSE Note that if you want to check whether two vectors are equal, you have to use two equal signs (with no space in-between) as a single operator, which is ==, to do comparisons. If only one equal sign is used, it would work as an assignment operator. In addition, you can use an exclamation mark together with one equal sign, which is !=, to find out whether two vectors are not equal. In addition to making comparisons involving vectors of length 1, you can also do it with vectors containing more than one elements. When we make comparisons between two vectors that contain more than one elements, R will make an element-wise comparison just like the arithmetic operations between two numeric vectors in Section 2.1.2. x2 &lt;- c(1, 2, 6) x3 &lt;- c(2, 2, 4) logi_1 &lt;- x2 &lt;= x3 logi_1 #&gt; [1] TRUE TRUE FALSE As x2 and x3 are of the same length, element-wise comparison will be applied. The result of this comparison logi_1 will be a logical vector of the same length, and only contain TRUE and FALSE. You can also manually check that the values of logi_1 agree with the comparisons 1 &lt;= 2, 2 &lt;= 2, and 6 &lt;= 4. Similar to the arithmetic operations on numeric vectors, the recycling rule (introduced in Section 2.1.2) also applies to the comparison when the two vectors do not have the same length. This recycling is most often used for a comparison between a vector with length greater than 1 and a vector with length of 1. Let’s see an example. x3 &lt;- c(2, 2, 4) x3 != 2 #&gt; [1] FALSE FALSE TRUE Here, x3 is a numeric vector with length of 3, and 2 is a numeric vector of length 1. From the result, you can see that 2 is compared with each element in x3, producing a length-3 logical vector. You can simply check the values by doing the following comparisons: 2 != 2, 2 != 2 and 4 != 2. Now you must be familiar with logical vectors. Similar to numeric vectors and character vector, you can also use the c() function along with the logical values TRUE (or T for short) and FALSE (or F for short) as elements. logi_2 &lt;- c(TRUE, FALSE, TRUE) logi_2 #&gt; [1] TRUE FALSE TRUE class(logi_2) #&gt; [1] &quot;logical&quot; The values of logical vectors can also be T or F. You can check the class of logi_3 by using class(). logi_3 &lt;- c(F, T, F, T) logi_3 class(logi_3) typeof(logi_3) It is worth emphasizing that, in creating numeric vectors and logical vectors, quotation marks aren’t necessary like they are in creating character vectors. If you put quotation marks around TRUE or FALSE, you will create a character vector instead. char_1 &lt;- c(&quot;TRUE&quot;, &quot;FALSE&quot;, &quot;TRUE&quot;) char_1 #&gt; [1] &quot;TRUE&quot; &quot;FALSE&quot; &quot;TRUE&quot; class(char_1) #&gt; [1] &quot;character&quot; It is worth mentioning that, R is case-sensitive in terms of the expression of TRUE and FALSE. Any expression other than TRUE, FALSE, T, or F will be recognized as character values or name of an object in R, not logical values. Please see the example below. # Valid Expression class(c(TRUE, T)) #&gt; [1] &quot;logical&quot; # Invalid Expression class(true) #&gt; Error in eval(expr, envir, enclos): object &#39;true&#39; not found class(True) #&gt; Error in eval(expr, envir, enclos): object &#39;True&#39; not found class(&quot;true&quot;) #&gt; [1] &quot;character&quot; Finally, you can use the vector(mode, length) function to create a logical vector of certain length. vector(&quot;logical&quot;, 2) Note that the default value is FALSE. 2.3.2 Logical vectors: creation when testing for types In addition to comparison operations, another situation that you will encounter logical vectors is when we test whether an object belongs to certain type. First of all, you can use is.numeric() to check whether an object is numeric, i.e. can be interpreted as numbers. It will return TRUE if the object is numeric, and will otherwise return FALSE. Note that both double vectors and integer vectors (Section 2.1.3) are numeric since they can both be interpreted as numbers. To further differentiate between double vectors and integer vectors, you can use is.double() and is.integer(). x1 &lt;- c(1, 2) x2 &lt;- c(1L, 2L) c(is.numeric(x1), is.double(x1), is.integer(x1)) #&gt; [1] TRUE TRUE FALSE c(is.numeric(x2), is.double(x2), is.integer(x2)) #&gt; [1] TRUE FALSE TRUE From the result, you can see that both x1 and x2 are numeric, only x1 is of double type, and only x2 is of integer type. Similarly, you can use is.character() to check whether an object is character, and is.logical() to check whether an object is logical. Let’s look at some examples. x1 &lt;- c(1, 2) x2 &lt;- c(&quot;this&quot;, &quot;is&quot;, &quot;great&quot;) x3 &lt;- c(TRUE, FALSE) c(is.numeric(x1), is.character(x1), is.logical(x1)) #&gt; [1] TRUE FALSE FALSE c(is.numeric(x2), is.character(x2), is.logical(x2)) #&gt; [1] FALSE TRUE FALSE c(is.numeric(x3), is.character(x3), is.logical(x3)) #&gt; [1] FALSE FALSE TRUE We can see that all results from those check functions are logical values and they agree with the corresponding object types. 2.3.3 Exercises Write the R code to complete the following tasks. Suppose we have x1 &lt;- c(1, 2, 3), create a logical vector with name logi_1 that represents whether each element of x1 is less than or equal to its square. Suppose we have logi_2 &lt;- c(TRUE, TRUE, FALSE). Create a logical vector of length 4 with name logi_3 with elements representing whether logi_2 is of integer type, double type, character type, and logical type, respectively. "],["coercion-rule.html", "2.4 Coercion Rule", " 2.4 Coercion Rule At this point, we have introduced three types of atomic vectors: numeric (Section 2.1) (containing double and integer types), character (Section 2.2), and logical vectors (Section 2.3). Recall that by definition, the atomic vectors always contain elements of a single type. You may wonder what will happen if we try to create a vector with values of mixed types and that is exactly what we are going to answer in this section. 2.4.1 Coercion with c() When we supply arguments of different types in the c() function, R will unify all elements into the most complex type, which is usually called the coercion rule. Specifically, R uses the following order of complexity (from simple to complex). \\[\\mbox{logical} &lt; \\mbox{numeric} &lt; \\mbox{character}\\] Let’s see a few examples to learn how the coercion works. The first example mixes logical values with numbers. mix_1 &lt;- c(TRUE, 7, 4, FALSE) mix_1 #&gt; [1] 1 7 4 0 typeof(mix_1) #&gt; [1] &quot;double&quot; class(mix_1) #&gt; [1] &quot;numeric&quot; You can see that the logical values are converted to numbers, in particular, TRUE is converted to 1 and FALSE is converted to 0, when they mix with numbers. At the end, you can see mix_1 is a numeric vector with four numbers. The result of coercion can be confirmed with the typeof() and class() function. The second example mixes numbers with strings. mix_2 &lt;- c(&quot;today&quot;, &quot;is&quot;, &quot;Jan&quot;, 15, &quot;2022&quot;) mix_2 #&gt; [1] &quot;today&quot; &quot;is&quot; &quot;Jan&quot; &quot;15&quot; &quot;2022&quot; class(mix_2) #&gt; [1] &quot;character&quot; typeof(mix_2) #&gt; [1] &quot;character&quot; You can see that both 15 and 2022 are converted into strings since strings are more complex than numbers. Then, mix_2 will be a character vector. The next example mixes logical values, numbers and strings. mix_3 &lt;- c(16, TRUE, &quot;pig&quot;) mix_3 #&gt; [1] &quot;16&quot; &quot;TRUE&quot; &quot;pig&quot; class(mix_3) #&gt; [1] &quot;character&quot; You can see in both mix_3 and mix_4, both 16 and TRUE are converted to strings! That’s because values of character type are the most complex among all values. Next, let’s see an interesting example in which we have two layers of coercion. mix_4 &lt;- c(c(16, TRUE), &quot;pig&quot;) mix_4 #&gt; [1] &quot;16&quot; &quot;1&quot; &quot;pig&quot; Nested c() will collapse into a single vector recursively and during the process, the coercion rule will apply whenever needed. First, c(16, TRUE) will be converted to c(16, 1) since numbers are more complex than logical values. Then, the expression becomes c(c(16, 1), \"pig\"). Since characters are more complex than numbers, c(16, 1) will be converted to c(\"16\", \"1\") when you combine it with \"pig\", leading to the results of mix_5. To help you understand the process, let’s look at another example. mix_5 &lt;- c(16, c(TRUE, &quot;pig&quot;)) mix_5 #&gt; [1] &quot;16&quot; &quot;TRUE&quot; &quot;pig&quot; Here, the first layer is c(TRUE, \"pig\") which is coerced to c(\"TRUE\", \"pig\"). Then, 16 will be coerced to \"16\" in c(16, c(\"TRUE\", \"pig\")), leading to the final result. The difference between mix_4 and mix_5 reflects the sequential coercion process. Lastly, let’s talk about the coercion within numeric values. In particular, we have learned that there are two kinds of types numeric values are stored: namely integers and doubles. In the coercion rule, we have \\[\\mbox{integer} &lt; \\mbox{double}.\\] Let’s see the following examples. typeof(c(1, 5L)) #&gt; [1] &quot;double&quot; typeof(c(TRUE, 5L)) #&gt; [1] &quot;integer&quot; Let’s now summarize the coercion rule of all types we have learned. \\[\\mbox{logical} &lt; \\mbox{integer} &lt; \\mbox{double} &lt; \\mbox{character}\\] 2.4.2 Cocercion in operators In addition to appearing in the vector creation using the c() function, the coercion rule also applies when we apply operators with different types. typeof(1L + 3) #&gt; [1] &quot;double&quot; 2 + TRUE + FALSE + TRUE #&gt; [1] 4 (TRUE * 30 + FALSE * 29)/2 #&gt; [1] 15 R is very smart in whether to apply the coercion. typeof(1L + 5L) #&gt; [1] &quot;integer&quot; typeof(1L * 5L) #&gt; [1] &quot;integer&quot; typeof(1L / 5L) #&gt; [1] &quot;double&quot; When comparing vectors of different types, the coercion rule also will apply. Take the following vectors as example: a &lt;- c(-1, 0, 1) b &lt;- c(TRUE, FALSE, TRUE) a == b #&gt; [1] FALSE TRUE TRUE #&gt; [1] FALSE TRUE TRUE When we are trying to figure out if a is equal to b, we get a length-3 logical vector. Elements in b is first converted into 1 and 0 based on the coercion rule we previously introduced, which is TRUE = 1 and FALSE = 0, and the result will be c(1, 0, 1). Thus, a comparison between a logical and a numeric vector is changed into comparing two numeric vectors. You can make comparisons between vectors of other types, the following example shows that the classic transitive property in math (\\(a = b\\) and \\(b = c\\) imply \\(a = c\\)) doesn’t hold in R. 1 == TRUE #&gt; [1] TRUE TRUE == &quot;TRUE&quot; #&gt; [1] TRUE 1 == &quot;TRUE&quot; #&gt; [1] FALSE 2.4.3 Explicit Coercion Besides the coercion rule which automatically converts all elements into the most complex type, you can also use functions to do the conversion manually. In particular, as.numeric(), as.integer(), as.character(), and as.logical() convert its argument into numeric, integer, character, and logical, respectively. as.numeric(c(TRUE, FALSE)) #&gt; [1] 1 0 as.character(c(TRUE, FALSE)) #&gt; [1] &quot;TRUE&quot; &quot;FALSE&quot; as.integer(c(TRUE, FALSE)) #&gt; [1] 1 0 as.logical(c(1, 0)) #&gt; [1] TRUE FALSE as.logical(c(&quot;TRUE&quot;, &quot;FALSE&quot;)) #&gt; [1] TRUE FALSE 2.4.4 Exercises Looking at the following codes without running in R, what are the storage types of mix_1, mix_2, mix_3, mix_4, mix_5, and mix_6? Verify your answers by running the code in R and explain the reason. int_1 &lt;- 5L int_2 &lt;- 6L num_1 &lt;- 2 char_1 &lt;- &quot;pig&quot; logi_1 &lt;- TRUE mix_1 &lt;- int_1 + int_2 mix_2 &lt;- int_1 + num_1 mix_3 &lt;- int_1/int_2 mix_4 &lt;- c(num_1, char_1) mix_5 &lt;- c(num_1, logi_1) mix_6 &lt;- c(num_1, char_1, logi_1) If logi_2 &lt;- c(TRUE, FALSE, TRUE) and logi_3 &lt;- TRUE, what are the values of 3 * logi_2 + logi_3 and logi_2 - logi_3? "],["subsetting-and-modify-values.html", "2.5 Vector Subsetting and Modifying Values", " 2.5 Vector Subsetting and Modifying Values So far, we’ve learned fundamental knowledge of 2.1, 2.2, and 2.3. In this section, we’ll start with how to create named vectors. Heads up, the process of creating a named vector is different from object assignment, and you’ll see the difference immediately. 2.5.1 Named Vectors Remember in Section 1.3, we learned to give a name to an object by using the assignment operator &lt;-. Depending on what name you assign to an object, it may provide a broad but unspecified explanation of the element(s) the object contains. When necessary, we need a way to label each element of an object to have a concrete idea on what each element refers to. To do so, We can turn an vector into an named vector, and there are two ways to complete this task. a. Using the equal sign whilst creating the vector If you have an object with a short length, you can consider using the form name = value inside the c() to create a named vector in one step. x_w_name &lt;- c(height = 165, weight = 60, BMI = 22) x_w_name #&gt; height weight BMI #&gt; 165 60 22 In this example, we can see that the output includes a label for every arbitrary numeric value so that we know what these numbers mean in real life. For a named vector, you can also access its elements via the names, and update the values via the assignment operator. x_w_name[&quot;height&quot;] #&gt; height #&gt; 165 x_w_name[&quot;weight&quot;] &lt;- x_w_name[&quot;weight&quot;] + 10 x_w_name #&gt; height weight BMI #&gt; 165 70 22 b. Using the Names Function names() afterwards While the equal sign method is straightforward, it is less effective when the object contains a few elements. In such cases, we can apply the Function names() after the vector is created. For example, if we want to represent whether it snows on each day using a logical vector during a ten-day time period. y &lt;- c(TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, TRUE, FALSE, TRUE, TRUE) y #&gt; [1] TRUE FALSE TRUE TRUE FALSE TRUE TRUE FALSE TRUE TRUE names(y) &lt;- c(&quot;Jan 1&quot;, &quot;Jan 2&quot;, &quot;Jan 3&quot;, &quot;Jan 4&quot;, &quot;Jan 5&quot;, &quot;Jan 6&quot;, &quot;Jan 7&quot;, &quot;Jan 8&quot;, &quot;Jan 9&quot;, &quot;Jan 10&quot;) y #&gt; Jan 1 Jan 2 Jan 3 Jan 4 Jan 5 Jan 6 Jan 7 Jan 8 Jan 9 Jan 10 #&gt; TRUE FALSE TRUE TRUE FALSE TRUE TRUE FALSE TRUE TRUE Again, the output after applying names() provides more information than before. You can also access element(s) and update their values via their names as we introduced just now. Reflectively, we can create an named vector whenever we want the vector itself to include more information, and the specific way to do that is really contingent upon our preferences and what we are given in each case. Now, it’s important to be aware that the value for an element’s name need to be a character vector. Actually, an element’s name is also a type of attributes of R Objects. We will introduce other types of attributes as we encounter them. The name attribute provides additional information regarding the meaning of each element, and enables us to extract values using the names. attributes(x_w_name) #&gt; $names #&gt; [1] &quot;height&quot; &quot;weight&quot; &quot;BMI&quot; str(x_w_name) #&gt; Named num [1:3] 165 70 22 #&gt; - attr(*, &quot;names&quot;)= chr [1:3] &quot;height&quot; &quot;weight&quot; &quot;BMI&quot; x_wo_name &lt;- c(165, 60, 22) str(x_wo_name) #&gt; num [1:3] 165 60 22 You can see that x_w_name is a named numeric vector, with the names attribute. In contrast, str() function tells us x_wo_name is a plain numeric vector with no attributes. To directly extract certain attributes of an R object, you can use the attr() function on it with the second argument being the specific attribute you wish to extract. attr(x_w_name, &quot;names&quot;) #&gt; [1] &quot;height&quot; &quot;weight&quot; &quot;BMI&quot; 2.5.2 Vector subsetting Now, let’s delve into this section’s main focus: vector subsetting. At some point of your analysis of a vector with more than 1 element, you may want to extract particular elements to constitute a new vector. In R, the new vector is considered as a subvector of the original vector. This process is called vector subsetting, and the subvector will be of the same type as the original one. In this part, we will introduce two common ways to do vector subsetting in R. Before we get started, let’s create a vector which will be used throughout this part. h &lt;- c(3,1,4,2,90) a. Use logical vectors to do vector subsetting Firstly, let’s see how we can apply logical vectors to do vector subsettings. Following the original vector’s name, a pair of square brackets [ ] is used to include a logical vector of the same length as the original vector. Here is an example, h[c(TRUE, FALSE, TRUE, FALSE, TRUE)] #&gt; [1] 3 4 90 From the result, you can see that the values from h with the same positions of TRUEs are extracted. Since 3, 4 and 90 are parts of the values of h, the vector composed of 3 4 90 is a subvector of h. When assigning these three values to a name, you will get a named subvector sub1. While sub1 is developed from h, they are now stored as two different vectors. sub1 &lt;- h[c(TRUE, FALSE, TRUE, FALSE, TRUE)] sub1 #&gt; [1] 3 4 90 In addition to writing the logical vector in an explicit form, you can also use a named logical vector or an expression whose result is a logical vector. Let’s say we want to find the subvector of h for all elements in h that are larger than 2. Then, you can first compare h with 2, getting a logical vector, which is named big3 here. h &gt; 2 #&gt; [1] TRUE FALSE TRUE FALSE TRUE big3 &lt;- h &gt; 2 big3 #&gt; [1] TRUE FALSE TRUE FALSE TRUE Then you may notice that both big3 and h &gt; 2 are identical to c(TRUE, FALSE, TRUE, FALSE, TRUE). So, you can clearly put either big3 or h &gt; 2 into [ ], which generates the same subvector with 3 4 90 as its elements. h[c(TRUE, FALSE, TRUE, FALSE, TRUE)] #&gt; [1] 3 4 90 h[big3] #&gt; [1] 3 4 90 h[h &gt; 2] #&gt; [1] 3 4 90 Don’t restrict yourself in thinking that only numeric vectors can be subsetted. If you create a character vector home and compare it to \"pig\", you will get another logical vector same3. Let’s try to use same3 to do vector subsetting on h. home &lt;- c(&quot;pig&quot;, &quot;monkey&quot;, &quot;pig&quot;, &quot;monkey&quot;, &quot;pig&quot;) same3 &lt;- home == &quot;pig&quot; sub2 &lt;- h[same3] sub2 #&gt; [1] 3 4 90 Awesome! You still get the result of 3 4 90! As a result, as long as the logical vector you apply in subsetting have the same logical values, you will get the same result after doing vector subsetting. Of course, you can do vector subsetting on character vectors or logical vectors. Keep in mind that the result will be the same type as the original one. Try the following code by yourself. home[same3] #&gt; [1] &quot;pig&quot; &quot;pig&quot; &quot;pig&quot; home[big3] #&gt; [1] &quot;pig&quot; &quot;pig&quot; &quot;pig&quot; lg &lt;- c(TRUE, FALSE, FALSE, FALSE, TRUE) lg[same3] #&gt; [1] TRUE FALSE TRUE lg[big3] #&gt; [1] TRUE FALSE TRUE b. Use indices to do vector subsetting Next, we will introduce how to use indices to do vector subsetting. To achieve this goal, you need to put a numeric vector inside [ ], for example, h #let&#39;s refresh ourself with what elements h contains #&gt; [1] 3 1 4 2 90 h[c(2,4)] #return values of the 2nd and 4th elements of h #&gt; [1] 1 2 As it shows, the values of the 2nd and 4th elements in h are returned. Notice that, in R, the first element in a vector has index 1, whereas other programming languages may have different indexing fashion. In that sense, the numeric vector inside the [ ] represents relative indices instead of actual numeric values. If you add a minus sign - before the numeric vector, you will get all elements except the 2nd and 4th ones in h. h[-c(2,4)] #return values except the 2nd and 4th elements of h #&gt; [1] 3 4 90 Similar to using a named logical vectors, you can also use a named numeric vector to do vector subsetting. ind &lt;- c(2,4) sub3 &lt;- h[ind] sub3 #&gt; [1] 1 2 The first line of this example looks like a new object assignment that assigns two numeric values, 2 and 4, to the name ind. However, what we really attempt is to restrict ind, a random name, to represent the 2nd and the 4th index. Also, you can get subvectors of character vectors or logical vectors via indices. home[ind] #&gt; [1] &quot;monkey&quot; &quot;monkey&quot; lg[ind] #&gt; [1] FALSE FALSE In conclusion, there are two ways to get a subvector of h with values bigger than 2. h &lt;- c(3,1,4,2,90) h[h &gt; 2] #h &gt; 2 will return TRUE if the element in h has value bigger than 2 #&gt; [1] 3 4 90 h[c(1,3,5)] #It&#39;s clear to see that the first, third and fifth elements have values bigger than 2 #&gt; [1] 3 4 90 c. using names to do vector subsetting For a named vector, we can also use character vectors consisting of the names as indices to do vector subsetting. The elements’ names and their corresponding indices are fungible. x_w_name &lt;- c(height = 165, weight = 60, BMI = 22) x_w_name[&quot;height&quot;] #&gt; height #&gt; 165 x_w_name[c(&quot;weight&quot;, &quot;BMI&quot;)] #&gt; weight BMI #&gt; 60 22 x_w_name[c(1,3)] # c(&quot;weight&quot;, &quot;BMI&quot;) and c(1, 3) refer to the same elements, so the last two lines lead to the same output #&gt; height BMI #&gt; 165 22 ###Access and modify values in vectors and sub-vectors We’ll end this section by learning the way to access and modify values in a vector. This is a fairly basic data manipulation, and the reason we wait until now to introduce it is because we use the same ways to access and modify values in atomic vectors that we presented in previous sections. Let’s begin with extracting one element from a vector. To access a specific element, you can apply vector indexing by using the index of the element with a pair of square brackets [ ] surrounding it following by the vector name. After accessing an element, you can also update its value by using the assignment operator with the extraction expression on the left and the new value on the right. Let’s say you want to access the third element of y1 and update its value to 100. y1 &lt;- c(1, 3, 3, 5, 5) y1 #&gt; [1] 1 3 3 5 5 y1[3] #&gt; [1] 3 y1[3] &lt;- 100 y1 #&gt; [1] 1 3 100 5 5 It is as straightforward as it looks like! From the result, you can see that you’ve updated the third element’s value is updated to 100. Now, if you did look through the first half of this section, at this point you may find that accessing a vector’s element(s) is completed similarly compared to vector subsetting. It turns out we can update the values of multiple elements of a vector in a similarly way. a. Change all values in subsets of vectors Firstly, let’s review values of vector h and get a subset of it. h &lt;- c(3,1,4,2,90) h[c(2,4)] #&gt; [1] 1 2 Obviously, you will get a numeric vector with 1 and 2 as the values. Let’s see how to change values for a subset of h. You just need to assign new values to the subset, then you can verify the values of h. Let’s see an example, h[c(2,4)] &lt;- c(10, 20) h #&gt; [1] 3 10 4 20 90 h[c(2,4)] &lt;- 10 #recycling rule applies h #&gt; [1] 3 10 4 10 90 In the first two lines, you can see that you have changed 1 and 2 to 10 and 20, respectively. In the last two lines, however, since you assign multiple values to one new value, R will apply recycling rule to complete the value updating process. In both cases, you have successfully change parts of h! b. Define the vector again Another way to change values in vectors is to do object assignment again using the same name, then you can change any values of it. Let’s first reset the values of h. h &lt;- c(3,1,4,2,90) From Section 1.3, you learned that you can check all objects you assigned and their values in the environment panel. So let’s review values of vector h from this panel together. Figure 2.9: Values of h (1) We should agree that h is a numeric vector with 5 values Then let’s try to do an object assignment again, this time you can assign different values to h and see what will happen to h. h &lt;- c(1,2,3,4,5) h #&gt; [1] 1 2 3 4 5 Then you can see that the values of h have been changed to the new ones! Another easier way to verify values of h is from the environment, so it is a good habit to monitor the environment from time to time to make sure everything looks fine. Figure 2.10: Values of h (2) You can assign any values to h as you want, then h may change the vector type or even the object type according to the values assigned. By running the following code, h will be a character vector with three strings. h &lt;- c(&quot;pig&quot;, &quot;monkey&quot;, &quot;panda&quot;) Figure 2.11: Values of h (3) If you assign values of a subvector to a name, you will create a new vector. Now hs is not the subset of h, it is a vector with the same value as the subset. If you assign different value(s) to hs, there will be no change on h. h &lt;- c(3,1,4,2,90) hs &lt;- h[c(2,4)] hs &lt;- 10 h 2.5.3 Exercises Consider the vector v1 &lt;- c(7, 2, 4, 9, 7), v2 &lt;- c(6, 2, 8, 7, 9), and v3 &lt;- 1:50. Find the locations in v1 where the corresponding value is smaller than v2. Find the subvector of v2 such that the corresponding location in v1 is larger than 5. Find the subvector of v3 such that it is divisible by 7. (Hint: the result of 7%%7 is equal to 0 since 7 is divisible by 7) For all elements of v3 that is divisible by 8, replace it by 100. "],["patterned_numeric_vectors_creation.html", "2.6 Numeric Vectors: Creating numeric vectors with patterns", " 2.6 Numeric Vectors: Creating numeric vectors with patterns In Section 2.1, you learned how to create numeric vectors with length more than 1 by using the c() function. When the number of elements become too big, you may feel redundant manually typing in all those elements. Luckily, as long as the assigned elements have certain patterns, R allows you to create the desired numeric vector numeric vectors more efficiently. 2.6.1 The colon operator : – Equally-spaced numeric vectors with increment of 1 or -1 An equally-spaced numeric vector is a numeric vector with the same distance between adjacent elements. Suppose you want to assign consecutive integers from 1 to 5 to the name pattern1. Coming from Section 2.1, you may do the following: pattern1 &lt;- c(1, 2, 3, 4, 5) However, when the number of elements changes from 5 consecutive integers to 100 consecutive integers, manually typing in would be really time-consuming and inefficient. In R, you can use the colon operator : to create equally-spaced numeric vectors. Note that you don’t need to use : together with c(). pattern2 &lt;- 1:5 If you compare pattern1 and pattern2, you will realize that they are both numeric vectors with elements of consecutive integers from 1 to 5. Let’s experiement : with more attempts. pattern3 &lt;- 1:100 pattern3 #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #&gt; [19] 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 #&gt; [37] 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 #&gt; [55] 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 #&gt; [73] 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 #&gt; [91] 91 92 93 94 95 96 97 98 99 100 pattern4 &lt;- 5:1 pattern4 #&gt; [1] 5 4 3 2 1 pattern5 &lt;- 1.2:5.2 pattern5 #&gt; [1] 1.2 2.2 3.2 4.2 5.2 With pattern3, you can see how powerful and convenient the colon operator is. In addition to create ascending equally-spaced numeric vectors, you can also use it to create descending ones, like pattern4. Eventually, you can use the colon operator to assign equally-spaced decimals to numeric vectors. However, as you can see below, R will store numeric vectors with equally-spaced integers as type integer and those with equally-spaced decimals as type double. class(pattern4) #&gt; [1] &quot;integer&quot; class(pattern5) #&gt; [1] &quot;numeric&quot; 2.6.2 The seq() function – Equally-spaced numeric vectors with any increment As powerful as the colon operator : is, it is really restricted to creating equally-spaced numeric vectors with an increment 1 or -1. By contrast, the seq() function don’t have such a restriction, and it will come into play when you want to create equally-spaced numeric vectors with increments other than 1 or -1. a. Create sequences with the by argument The seq() function can include three arguments: from, to, and by. The from and to arguments specify the start and limited end values, respectively, while the by argument specifies the increment of the sequence. seq(from = 1, to = 5, by = 1) #&gt; [1] 1 2 3 4 5 seq(to = 5) #&gt; [1] 1 2 3 4 5 You can interpret the above example as “an equally-spaced numeric vector starting at 1 and ending at 5, with the increment between adjacent elements of 1”. If you don’t specify the optional from and by arguments, seq() will use the default value 1 for both arguments. Now you have had four methods to create vectors with consecutive integers. c(1,2,3,4,5,6) #write all numbers down 1:6 #use colon operator seq(from = 1, to = 6, by = 1) #use seq() seq(to = 6) #use seq() Next, let’s assign a different value to the by argument in the seq() function. What you will get a numeric vector with 1 3 5 as its values. seq(from = 1, to = 5, by = 2) #&gt; [1] 1 3 5 Note that the ending value of the sequence doesn’t always equal the value assigned to the to argument. If you change the limit end value to 6, you still get the same sequence. This is because the next value in the sequence would be 7, which is larger than the limit end value 6. This is the reason why to denotes the limited end value, not the end value. seq(from = 1, to = 6, by = 2) #&gt; [1] 1 3 5 Of course, you can assign decimal numbers to arguments in the seq() function. Below, you will first get a sequence which starts with 1, increases by 0.5 each time until it is larger than 6. Subsequently, you will get a numeric vector with 1.1 1.8 2.5 3.2 as its values. seq(from = 1, to = 6, by = 0.5) #&gt; [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 5.5 6.0 seq(from = 1.1, to = 3.2, by = 0.7) #&gt; [1] 1.1 1.8 2.5 3.2 Besides ascending sequences, you can also create descending sequences via seq(). Similarly, you can assign positive numbers as well as negative ones to arguments in the seq() function. Try out some examples like below: seq(from = 1.5, to = -1, by = -0.5) #&gt; [1] 1.5 1.0 0.5 0.0 -0.5 -1.0 seq(from = -3.5, to = -3, by = 0.1) #&gt; [1] -3.5 -3.4 -3.3 -3.2 -3.1 -3.0 seq(from = 1.5, to = -1, by = 0.5) #&gt; Error in seq.default(from = 1.5, to = -1, by = 0.5): wrong sign in &#39;by&#39; argument It’s worth-noting that the arguments in seq() function should make algebraic sense. For example, in the last example above, it doesn’t make sense to use a positive value in the byargument when the start value is bigger than the limited end value, which implies a decreasing sequence. In such cases, You should expect to see an error message. b. Create sequences with the length.out argument In seq(), instead of setting the increment via the by argument, you can also specify the length.out argument, which creates a equally-spaced sequence with the assigned length (a.k.a. the number of elements in the numeric vector). R will automatically calculate the difference between two neighboring elements according to values of three arguments in seq(). seq(from = 1, to = 5, length.out = 9) #&gt; [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 Here, you will get an equally-spaced sequence of length 9 from 1 to 5. You can also create a decreasing sequence by using the length.out argument. seq(from = 5, to = -5, length.out = 9) #&gt; [1] 5.00 3.75 2.50 1.25 0.00 -1.25 -2.50 -3.75 -5.00 seq(from = 5, to = -5, length.out = 8.9) #&gt; [1] 5.00 3.75 2.50 1.25 0.00 -1.25 -2.50 -3.75 -5.00 What will happen if you assign a decimal number to the length.out argument? In such a case, R will round up the decimal to the nearest integer when carrying out the length.out argument. In the last example above, the value 8.9 is rounded up to 9. Unlike creating sequences with by argument, if you specify the length.out argument in seq(), the start value and limited end value of the sequence you get will be exactly match the input arguments. c. Create sequences with both the by and length.out arguments Lastly, if you provide both the by and length.out arguments, only one of the from and to arguments is necessary. With one value (the start value or the limit end value) fixed, seq() will create a vector with specified increment and length. If you only have the from argument, you will get a sequence starting from the value you set, with the increment in the by argument, until you get a sequence with a length specified in the length.out argument. If you only have the to argument, you will get a sequence ending with the value you set, with the increment in the by argument, until you get a sequence with a length specified in the length.out argument. seq(from = 1, by = 2, length.out = 5) #&gt; [1] 1 3 5 7 9 seq(to = 1, by = 2, length.out = 5) #&gt; [1] -7 -5 -3 -1 1 Before leaving the seq() function, you should be aware that you can at most provide three arguments. For example, you will see an error when running the following example since all four arguments are specified. seq(from = 1, to = 3, by = 1, length.out = 3) #&gt; Error in seq.default(from = 1, to = 3, by = 1, length.out = 3): too many arguments 2.6.3 The sequence generator seq_along() – Matching numeric vectors Now, we will introduce one function derived from the seq() function. Let’s first create a numeric vector extend. extend &lt;- seq(from = 2, to = 8, length.out = 7) extend #&gt; [1] 2 3 4 5 6 7 8 By the value assigned to the length.out argument, you know that the length of extend is 7. You also know that 2 3 4 5 6 7 8 are the elements of extend. Next, let’s put extend in seq_along(). seq_along(extend) #&gt; [1] 1 2 3 4 5 6 7 As you can tell from the result, seq_along() takes a numeric vector as its argument, generating consecutive integers from 1 to the length of the input vector. The seq_along() function is commonly used when writing loops, which will be covered at a later time. You can also use 1:length(extend) to get the same result as seq_along(extend). 1:length(extend) #&gt; [1] 1 2 3 4 5 6 7 2.6.4 The rep() Function – Numeric vectors with repeated values The rep() function is designed for another type of patterned numeric vectors, which are with replicated values as their elements. To do repetition, you can use the rep() function, which works by repeating the first argument for the number of times indicated in the second argument. Suppose you want to assign four 2s to the name num1. You can use the rep() function here: num1 &lt;- rep(2, 4) num1 #&gt; [1] 2 2 2 2 You can interpret the function as “creating a numeric vector in which 2 is repeated four times”. The resulting vector is a length-4 numeric vector with all elements of value 2. In addition to one single value, a numeric vector with several values can be assigned in the first argument. num2 &lt;- rep(c(1, 4, 2), 3) num2 #&gt; [1] 1 4 2 1 4 2 1 4 2 Here, the rep() will repeat the whole vector c(1, 4, 2) three times. Note that the vector is repeated as a whole, not elementwisely. Reflectively, you may be wondering what happens the second argument also has several numbers? Let’s try together. num3 &lt;- rep(c(1,5,7), c(3,2,1)) num3 #&gt; [1] 1 1 1 5 5 7 In rep(), when the second argument is also a numeric vector, R will do an element-repeat-operation by repeating each element in the first argument the number of times indicated in the corresponding index of the second argument and combine the repeated vectors to a single numeric vector. In this example, 1 is repeated 3 times, 4 is repeated twice, and 7 is repeated once. It is equivalent to c(rep(1,3), rep(4,2), rep(7,1)) #&gt; [1] 1 1 1 4 4 7 It is important that, to assign two numeric vectors as the two arguments in rep(), the two numeric vectors should have the same length. Otherwise, you will see an error message telling you the second argument (a.k.a. the times argument) is invalid. num4 &lt;- rep(c(1,5,7), c(3,2)) #&gt; Error in rep(c(1, 5, 7), c(3, 2)): invalid &#39;times&#39; argument Last but not least, you can also apply each and times arguments in the rep() command. The former implies how many times each element in the vector of interest will be repeated per round, while the latter determines how many rounds the repeating will include. rep(c(1,2), each = 3, times = 3) #&gt; [1] 1 1 1 2 2 2 1 1 1 2 2 2 1 1 1 2 2 2 2.6.5 The unique() and table() Functions – Getting unique elements and their frequencies So far, you have learned how to create vectors with specific patterns. Sometimes, you may want to inspect the unique elements (elements with different values) in a numeric vector and their corresponding frequencies. Let’s use num3 as an example. (Don’t forget to use ls() or check the environment panel to find all objects you have defined), num3 #&gt; [1] 1 1 1 5 5 7 You can use unique() to show all unique elements in vectors. unique(num3) #&gt; [1] 1 5 7 From the result, you know the unique elements in num3 are 1, 5, and 7. To get the frequency of each element, you can use the table() function. table(num3) #&gt; num3 #&gt; 1 5 7 #&gt; 3 2 1 Here, the first row is the numeric vector’s name. The second row shows all unique elements, and the third row is their corresponding frequencies. In num3, there are three 1s, two 5s and one 7. 2.6.6 Exercises Use five different ways to create an equally-spaced sequence with 2 4 6 8 10 as result. Use two different ways to create the patterned sequence with 2 2 6 6 8 8 2 2 6 6 8 8 as result. Use two different ways to create a numeric vector with 1 2 3 1 2 3 4 5 1 2 3 4 5 6 7 as result. Show the unique elements and their corresponding frequency. "],["numeric-sort-rank-order.html", "2.7 Numeric Vectors: Sort, Rank, Order", " 2.7 Numeric Vectors: Sort, Rank, Order After creating a numeric vector, we usually need to arrange (sort) the elements in either ascending or descending order. In this section, we will introduce how to sort numeric vectors and two other measures related to sorting. First, let’s create a numeric vector to be used throughout this section. x &lt;- c(2, 3, 2, 0, 4, 7) x #check the value of x #&gt; [1] 2 3 2 0 4 7 2.7.1 Sort vectors with sort() The first function we will introduce is sort(). By default, the sort() function sort elements in vector in the ascending order, namely from the smallest to largest. sort(x) #&gt; [1] 0 2 2 3 4 7 If you want to sort the vector in the descending order, namely from the largest to smallest, you can add a second argument decreasing = TRUE. sort(x, decreasing = TRUE) #&gt; [1] 7 4 3 2 2 0 2.7.2 Get ranks in vectors with rank() Next, let’s talk about ranks in a vector. The rank() function gives the ranks for each element of the vector, namely the corresponding positions in the ascending order. It is worth mentioning that, in R, indexes start at 1 - the 1st element of is at index 1, and the following indexes will count as normal. rank(x) #&gt; [1] 2.5 4.0 2.5 1.0 5.0 6.0 If you check the values of x, you can see that the smallest value of x is 0, which corresponds to the element at the fourth position of the original x vector. Thus, a rank of 1 will be assigned to the fourth position of the rank vector. The second smallest value of x is 2, which appears twice at the first and the third positions, resulting a tie (elements with the same value will result in a tie). Normally, these two elements would have ranks 2 and 3, respectively. To break the tie, the rank() function assigns the average of the ranks for all elements within a tie situation, by default. For our example, the average of 2 and 3 is 2.5, and will be assigned to the first and the third position of the rank vector. In addition to this default behavior for handling ties, rank() also provides other options by setting the ties.method argument. The third smallest value of x is 3, with a rank of 4 at the second position, thus a 4.0 will appear at the second position in the rank vector. The rest of the ranks is assigned in the same fashion. If you set ties.method = \"min\", all the tied elements will have the minimum rank instead of the average rank. In this case, the minimum rank is 2. rank(x, ties.method = &quot;min&quot;) #&gt; [1] 2 4 2 1 5 6 If you want to break the ties by the locations of the tied elements appear in the vector, you can set ties.method = \"first\". Then, the earlier-appearing elements will have smaller ranks than the later-appearing ones. In this example, the first element will have rank 2 and the third element has rank 3, since the first element appears earlier than the third element. There are other options for handling ties, which you can look up in the documentation of rank() if interested. rank(x, ties.method = &quot;first&quot;) #&gt; [1] 2 4 3 1 5 6 Unlike sort(), you can’t get positions in the descending order from the rank() function by adding decreasing = TRUE in rank(). However, you can achieve this goal by using sort(-x) if you want to get the positions in the descending order for vector x. sort(-x) #&gt; [1] -7 -4 -3 -2 -2 0 2.7.3 Get the ordering permutation via `order() The next item we want to introduce is the order() function. Note that the function name order could be a bit misleading since ordering elements also has the same meaning of sorting. However, although it is related to sorting, order() is a very different function from sort(). Let’s recall the values of x and apply order() on x. x #&gt; [1] 2 3 2 0 4 7 order(x) #&gt; [1] 4 1 3 2 5 6 sort(x) #&gt; [1] 0 2 2 3 4 7 From the result, you can see that the order() function returns indices for the elements in the ascending order, namely from the smallest to the largest. For example, the first output is 4, since the 4th element in x is the smallest. The second output is 1, since the 1st element in x is the second smallest. In other words, order() returns a permutation which rearranges the vector x into ascending order, which is shown in the following example. x[order(x)] #&gt; [1] 0 2 2 3 4 7 Unlike rank(), the order() function breaks the ties by the appearing order by default. If you want the indices corresponding to the descending order, then you can set decreasing = TRUE just like what we did in the sort() function. order(x, decreasing = TRUE) #&gt; [1] 6 5 2 1 3 4 In this section, we have covered sort(), rank(), and order() functions for numeric vectors. It is helpful to provide a brief summary. The sort() function sorts elements in vectors in ascending/descending order. The rank() function produces ranks for each element of the vector. The order() function returns the corresponding indices in ascending/descending order for the elements. 2.7.4 Exercises Write R codes to solve the following problems. Create a numeric vector named exe with values 2, 0, -3, 0, 5, 6 and sort exe from the largest to the smallest. In exe, what’s the ranks of 2 and the first 0? For exe, get indices for the elements in the ascending order. "],["numeric-vector-statistics.html", "2.8 Numeric vector: Summary Statistics", " 2.8 Numeric vector: Summary Statistics We’ve spent several sections learning the features of numeric vectors. In this section, we will introduce statistical functions on numeric vectors. Let’s first create a numeric vector. h &lt;- c(3, 2, 75, 0, 100) h #check the value of h #&gt; [1] 3 2 75 0 100 Next, we will divide statistical functions into several groups, and introduce them one by one. 2.8.1 Minimum and Maximum min(h) #&gt; [1] 0 max(h) #&gt; [1] 100 range(h) #&gt; [1] 0 100 First, you can get the minimum and maximum values of a numeric vector by calling the min() and max() functions, respectively. To get these two values at one time, you can call the range() function, which returns a length-2 vector with the minimum value(the first element) and maximum value(the second element). which.min(h) #&gt; [1] 4 which.max(h) #&gt; [1] 5 In addition to getting the minimum and the maximum values, it is often useful to get the corresponding locations of them. In h, the minimum value 0 is located in the fourth place, and this is why you will get a result of 4 from which.min(). If multiple elements are assigned with the same minimum value, which.min() will return the first location. Similarly, which.max() tells you the location of the maximum value. g &lt;- c(2, 2, 1, 1) which.min(g) #&gt; [1] 3 which.max(g) #&gt; [1] 1 The third and fourth elements in g both have the minimum value, but which.min(g) returns a result of 3 since the minimum value firstly appears in the third element. Similarly, which.max() gives you a result of 1. cummin(h) #&gt; [1] 3 2 2 0 0 cummax(h) #&gt; [1] 3 3 75 75 100 In addition to calculating the minimum value of all elements, you can also use the cumulative minimum function, called cummin(). It returns a vector of the same length as the input vector, with the value at each location being the minimum of all preceding elements until that location in the original vector. For example, the first element of cummin(h) is 3 because the minimum of the first element in the original vector is always itself. The second element of cummin(h) is 2, since the minimum of the first two elements (3 and 2) in his 2, and so on. Note that once we reach the minimum value of the original vector, the remaining elements of the cumulative minimum function will always equal to the minimum value. There is also a corresponding function for computing the cumulative maximums, called cummax(). 2.8.2 Sum and Product sum(h) #&gt; [1] 180 cumsum(h) #&gt; [1] 3 5 80 80 180 Next, let’s look at the sum() function, which produces the sum of all elements in the vector. For the numeric vector h, the sum is 3+2+75+0+100, which is 180. Similar to cummin(), you can use the cumsum() function to compute the cumulative sums, which works by summing up the elements of the original vector cumulatively up to each location. In cumsum(h), the first element is 3 since there is only one element (3) to do summation, and the second element is 5 since the summation of the first two elements (3 and 2) in h is 5. You can easily verify the values of the remaining elements by yourself. prod(h) #&gt; [1] 0 cumprod(h) #&gt; [1] 3 6 450 0 0 As long as we can calculate the sum and cumulative sum of a numeric vector, we can also compute the product of a numeric vector’s elements by the prod() function. In h, since there is 0 in h, the result is 0. Similarly, we have the cumulative product function cumprod() working by multiplying the elements of the original vector cumulatively up to each location. h #&gt; [1] 3 2 75 0 100 diff(h) #&gt; [1] -1 73 -75 100 It is worth noting that the diff() function doesn’t work the same way as the sum() function. Specifically, diff() returns the difference between consecutive elements in a numeric vector. In h, the difference between the first and the second elements (3 and 2) is -1, whereas that between the second and the third elements (2 and 75) is 73. In other words, the computations in done by subtracting the former element from the latter one in a consecutive pair. 2.8.3 Mean and median mean(h) #&gt; [1] 36 median(h) #&gt; [1] 3 The arithmetic mean of a numeric vector’s elements can be easily computed via the mean() function. To get the median of a numeric vector’s elements, we would need to place them in value order and find the middle. The sort() function introduced previously can list elements in order from the smallest to the largest. Comparatively, the median() function first places the elements in value order and then returns the middle number. If the vector length is odd, the middle number is the value of the element in the central location. In sort(h), we can see that the median corresponds to the third number out of five numbers since there are two numbers larger than 3 and two numbers smaller than 3. If the vector length is even, the middle number is the average of the two middle elements after sorting. sort(g) #&gt; [1] 1 1 2 2 median(g) #&gt; [1] 1.5 Recall g with values of 2, 2, 1, 1. After sorting, you will see that 1 and 2 are in the middle. The median is then defined as the average of these two elements, namely 1.5. 2.8.4 Quantiles quantile(h) #&gt; 0% 25% 50% 75% 100% #&gt; 0 2 3 75 100 quantile() produces sample quantiles of a given numeric vector. By default, it generates 2 rows and 5 numbers. The top row represents the different percentiles, which are always the 0 percentile, 25th percentile (0.25 quantile), 50th percentile (0.5 quantile), 75th percentile (0.75 quantile), and 100th percentile. The second row consists of the corresponding values of each quantile. We next go over all five quantile values. First of all, 0 percentile and 100th percentile are always the minimum and the maximum values, respectively. The 50th percentile (0.5 quantile) is the same as the median. The 25-th percentile (0.25 quantile), also called the first quartile, is the value such that there are 25 percent (or a quarter) of the remaining data (all elements without this number) smaller than it. For vector h, the value is 2 since there is exactly 1 number, which is 25 percent of the remaining 4 numbers, smaller than 2. Similarly, the 75-th percentile, also called the third quartile, is the value such that 75 percent of the remaining data is smaller than this number. For vector h, the value is 75 since there are 3 numbers, which are 75 percent of the remaining 4 numbers, smaller than 75. You also have an important concept called interquartile range (IQR), defined as the difference between the 3rd quartile (75-th percentile) and the 1st quartile (25-th percentile). The interquartile range of h is 73, which is 75 - 2. IQR(h) #&gt; [1] 73 In addition to the default five percentiles, the quantile() function can also compute a specific quantile between 0 and 1. To do this, you just need to specify the second argument probs. Let’s try to find the 95th quantile. quantile(h, probs = 0.95) #&gt; 95% #&gt; 95 As before, this asks R to compute the 95th percentile, meaning 95 percent of the remaining data is smaller than this value. Because you only have 5 values in this vector, it may not be very intuitive. However, if you have more elements in a vector, say 1001, you can count the number of the remaining data that is smaller than this value, which should be 950 (the number of remaining data is 1000, and 95 percent of 1000 is 950). In addition, the second argument can be a vector of probabilities, which will produce a numeric vector of the corresponding quantiles. quantile(h, probs = c(0.1, 0.2, 0.99)) #&gt; 10% 20% 99% #&gt; 0.8 1.6 99.0 2.8.5 Summary statistics summary(h) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 0 2 3 36 75 100 Compared with quantile(), the summary function produces a more comprehensive picture of a numeric vector. Applying summary(), you can get the 5 percentiles and the arithmetic mean at one time. (Min: 0 percentile, 1st Qu: 25-th percentile, Median: 50-th percentile, 3rd Qu: 75-th percentile, Max: 100-th percentile) Group F: variance and standard deviation var(h) #&gt; [1] 2289.5 sd(h) #&gt; [1] 47.84872 The last group of functions are var() and sd(), which compute the sample variance and sample standard deviation of a numeric vector, respectively. The formula of sample variance of vector \\(h\\) is \\[var(h) = \\frac{1}{n-1}\\sum_{i=1}^n (h_i-\\bar h)^2,\\] where \\(n\\) is the length of \\(h\\) and \\(\\bar h\\) is the average of all elements. By definition, the sample standard deviation is the square root of sample variance, which you can verify by sqrt(var(h)). For your convenience, we would like to provide a summary of all the functions introduced in the following table. Operation Explanation Length min(h) the minimum value 1 max(h) the maximum value 1 range(h) both the minimum value and the maximum value 2 which.min(h) the (first) location of the minimum value 1 which.max(h) the (first) location of the maximum value 1 cummin(h) the cumulative minimum values same as the original numeric vector cummax(h) the cumulative maximum values same as the original numeric vector sum(h) the sum of all elements 1 cumsum(h) the cumulative sum same as the original numeric vector prod(h) the product of all elements 1 cumprod(h) the cumulative products same as the original numeric vector mean(h) the average of all elements 1 median(h) the middle number in sort(h) 1 quantile(h) the 0 percentile, 25-th percentile, 50-th percentile, 75-th percentile, and 100-th percentile 5 IQR(h) the difference between the 3rd quartile and the 1st quartile 1 quantile(h, probs = 0.95) the 95-th percentile 1 quantile(h, probs = c(0.1, 0.2, 0.99)) several quantiles at a time same as the argument numeric vector summary(h) 5 percentiles and the mean 6 var(h) the sample variance 1 sd(h) the sample standard deviation 1 2.8.6 Exercises Suppose x &lt;- c(5, 2, 4, 1, 2, 1) Write the R code to reproduce each element of the summary vector summary(x) Write the R code to generate the cumulative sum, cumulative product, cumulative minimum, and cumulative maximum of x. Write R code to generate a vector consisting of the 0.1, 0.2, 0.6, 0.8, 0.9 quantiles of x. Write R code to calculate the sample variance and sample standard deviation of x. "],["char-concatenate.html", "2.9 Character Vectors: Create with Repetition and Concatenate", " 2.9 Character Vectors: Create with Repetition and Concatenate From this section, we will dive deep into character vectors. 2.9.1 Create character vectors with repetition Just like numeric vectors, you can also create character vectors with repetition via the rep() function. rep(&quot;sheep&quot;, 5) #&gt; [1] &quot;sheep&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;sheep&quot; If the first argument is of length larger than 1, and the second argument is a single integer, the rep() function will repeat the first vector the corresponding times that is specified by the integer. rep(c(&quot;sheep&quot;, &quot;monkey&quot;), 3) #&gt; [1] &quot;sheep&quot; &quot;monkey&quot; &quot;sheep&quot; &quot;monkey&quot; &quot;sheep&quot; &quot;monkey&quot; Another option is to specify the second argument as a numeric vector of the same length as the vector to be repeated. In this case, each element of the character vector will be sequentially repeated the corresponding number of times. Please see the following examples. rep(c(&quot;sheep&quot;, &quot;monkey&quot;), rep(3, 2)) #&gt; [1] &quot;sheep&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;monkey&quot; &quot;monkey&quot; &quot;monkey&quot; rep(c(&quot;sheep&quot;, &quot;monkey&quot;), c(3,4)) #&gt; [1] &quot;sheep&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;monkey&quot; &quot;monkey&quot; &quot;monkey&quot; &quot;monkey&quot; 2.9.2 Concatenate strings with paste() Next, we will introduce how to concatenate several strings into a single string. To do this, you can use the paste() function. First, let’s create a character vector with four elements, four_strings &lt;- c(&quot;I&quot;, &quot;love&quot;, &quot;r02pro&quot;, &quot;!&quot;) four_strings #&gt; [1] &quot;I&quot; &quot;love&quot; &quot;r02pro&quot; &quot;!&quot; length(four_strings) #verify the number of strings #&gt; [1] 4 To concatenate the four strings in to a single string, you can use paste() instead of c(): one_long_string &lt;- paste(&quot;I&quot;, &quot;love&quot;, &quot;r02pro&quot;, &quot;!&quot;) one_long_string #&gt; [1] &quot;I love r02pro !&quot; You can verify the class and length of the new object. class(one_long_string) #&gt; [1] &quot;character&quot; length(one_long_string) #verify the number of strings #&gt; [1] 1 From the results, you can see that one_long_string is a character vector with length 1, and the value of one_long_string is a single string with spaces between the individual strings. In paste(), the default separator between the individual strings is space. Take a look at the documentation of the paste() function with any form of getting help (Section 1.2) that we previously introduced. What does the sep = \" \" argument mean? In fact, you can change the separator by setting the sep argument as a string in paste(). For example, you can separate the individual strings with comma or !&amp;!. comma &lt;- paste(&quot;I&quot;, &quot;love&quot;, &quot;r02pro&quot;, &quot;!&quot;, sep = &quot;,&quot;) comma #&gt; [1] &quot;I,love,r02pro,!&quot; paste(&quot;I&quot;, &quot;love&quot;, &quot;r02pro&quot;, &quot;!&quot;, sep = &quot;!&amp;!&quot;) #&gt; [1] &quot;I!&amp;!love!&amp;!r02pro!&amp;!!&quot; If you don’t want to use a separator, you can set sep = \"\" or use the paste0() function. paste(&quot;I&quot;, &quot;love&quot;, &quot;r02pro&quot;, &quot;!&quot;, sep = &quot;&quot;) #&gt; [1] &quot;Ilover02pro!&quot; paste0(&quot;I&quot;, &quot;love&quot;, &quot;r02pro&quot;, &quot;!&quot;) #&gt; [1] &quot;Ilover02pro!&quot; You may noticed the next argument for paste() is collapse = NULL in the documentation. If you would like to concatenate the elements of a vector into a longer string, you need to specify the collapse argument as the separator instead of sep in the paste() function. paste(four_strings, collapse = &quot;&quot;) #&gt; [1] &quot;Ilover02pro!&quot; paste(four_strings, collapse = &quot;,&quot;) #&gt; [1] &quot;I,love,r02pro,!&quot; paste(four_strings) ##doesn&#39;t work without the collapse argument #&gt; [1] &quot;I&quot; &quot;love&quot; &quot;r02pro&quot; &quot;!&quot; In addition to paste several strings into one long string, you can also use the paste() function to concatenate two or more character vectors, where the pair of strings will be pasted elementwisely. paste(c(&quot;July&quot;, &quot;August&quot;), c(&quot;2007&quot;, &quot;2008&quot;)) #&gt; [1] &quot;July 2007&quot; &quot;August 2008&quot; Note that you can take advantage of the recycling rule by using single strings in the character vectors. paste(&quot;Do&quot;, c(&quot;I&quot;, &quot;you&quot;, &quot;they&quot;), &quot;love r02pro?&quot;) #&gt; [1] &quot;Do I love r02pro?&quot; &quot;Do you love r02pro?&quot; &quot;Do they love r02pro?&quot; paste(&quot;Yes!&quot;, c(&quot;I&quot;, &quot;You&quot;, &quot;They&quot;), &quot;love r02pro!&quot;) #&gt; [1] &quot;Yes! I love r02pro!&quot; &quot;Yes! You love r02pro!&quot; &quot;Yes! They love r02pro!&quot; By default, the arguments in the paste() function are all character vectors. However, if you mix vectors of different types, all elements will be converted to characters based on the coercion rule (Section 2.4) before being concatenated. paste(c(&quot;Peter&quot;, &quot;James&quot;, &quot;Mary&quot;), &quot;has been learning R for&quot;, 2:4, &quot;years.&quot;) #&gt; [1] &quot;Peter has been learning R for 2 years.&quot; #&gt; [2] &quot;James has been learning R for 3 years.&quot; #&gt; [3] &quot;Mary has been learning R for 4 years.&quot; paste(&quot;The statement is&quot;, c(T, F)) #&gt; [1] &quot;The statement is TRUE&quot; &quot;The statement is FALSE&quot; 2.9.3 Output via cat() Another commonly used function related to character vectors is the cat() function, which converts its arguments to character vectors, concatenates them to a single character vector, appends the given separator specified in the optional argument sep to each element, and then outputs them. The default separator is space. cat(&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;long&quot;, &quot;string&quot;) #&gt; I am a long string Let’s try to specify the separator sep = \"$\". cat(&quot;I&quot;, &quot;am&quot;, &quot;a&quot;, &quot;long&quot;, &quot;string&quot;, sep = &quot;$&quot;) #&gt; I$am$a$long$string The cat() function is super useful when one wants to print a message in user-defined functions. Some important characters are the newline character \\n, and the tab character \\t. Let’s try it in action. Please pay special attention to the effects of \\n and \\t characters. cat(&quot;I&quot;, &quot;am&quot;, &quot;\\n&quot;, &quot;starting \\t line 2....&quot;, &quot;a&quot;, &quot;long&quot;, &quot;\\n&quot;, &quot;starting line 3....&quot;, &quot;string&quot;) #&gt; I am #&gt; starting line 2.... a long #&gt; starting line 3.... string Similar to the paste() function, implicit coercion will also apply before the concatenate process. cat(c(&quot;Peter&quot;, &quot;James&quot;, &quot;and Mary&quot;),&quot;\\n&quot;, &quot;have been learning R for\\n&quot;, 2:4, &quot;years,\\n&quot;, &quot;respectively.&quot;) #&gt; Peter James and Mary #&gt; have been learning R for #&gt; 2 3 4 years, #&gt; respectively. 2.9.4 Exercises Write R codes using the rep() function to reproduce the following three vectors with alphabetic letter values. Avoid repeating the same letters in your code. a b c d a b c d a b c d a a a b b b c c c d d d a a a a b b b c c d Please use the paste() function to reproduce the following sentences. Avoid repeating the same words in your code. Alice has been playing tennis for 4 years in London. Bob has been playing soccer for 3 years in New York. Charlie has been playing baseball for 2 years in Berlin. Please use the paste() and cat() functions to reproduce the following message. Avoid repeating the same words in your code. #&gt; Starting i = 1 #&gt; Starting i = 2 #&gt; Starting i = 3 #&gt; Starting i = 4 #&gt; Starting i = 5 #&gt; Starting i = 6 #&gt; Starting i = 7 #&gt; Starting i = 8 #&gt; Starting i = 9 #&gt; Starting i = 10 "],["character-sort-rank-order.html", "2.10 Character Vectors: Sort, Rank, Order", " 2.10 Character Vectors: Sort, Rank, Order In Section 2.7, you learned sort(), rank()``, andorder()` to sort numeric vectors and get their elements’ ranks and indices. These three functions can be used in a similar manner for character vectors. Similar to numeric vectors, let’s first prepare a character vector. char_vec &lt;- c(&quot;a&quot;, &quot;A&quot;, &quot;B&quot;, &quot;b&quot;, &quot;aB&quot;,&quot;ac&quot;, &quot;1c&quot;, &quot;.a&quot;, &quot;1a&quot;,&quot;2a&quot;,&quot;.a&quot;,&quot;&amp;u&quot;,&quot;3&quot;,&quot;_4&quot;) 2.10.1 Ordering rules For character vectors, R uses the lexicographical ordering, which is sometimes called dictionary order since it is the order used in a dictionary. Note that the strings in character vectors can contain letters, numbers, or symbols. There are a few important ordering rules as follows. symbols &lt; digits &lt; letters: symbols appear first, followed by digits, and letters appear last. symbols are ordered in a specific way as shown below. syms &lt;- c(&quot; &quot;,&quot;,&quot;,&quot;;&quot;,&quot;_&quot;,&quot;(&quot;,&quot;)&quot;,&quot;!&quot;,&quot;[&quot;,&quot;]&quot;,&quot;{&quot;,&quot;}&quot;,&quot;-&quot;,&quot;*&quot;,&quot;/&quot;,&quot;#&quot;,&quot;$&quot;,&quot;%&quot;,&quot;^&quot;, &quot;&amp;&quot;,&quot;`&quot;,&quot;@&quot;,&quot;+&quot;,&quot;=&quot;,&quot;|&quot;,&quot;?&quot;,&quot;&lt;&quot;,&quot;&gt;&quot;,&quot;.&quot;) sort(syms) #&gt; [1] &quot; &quot; &quot;_&quot; &quot;-&quot; &quot;,&quot; &quot;;&quot; &quot;!&quot; &quot;?&quot; &quot;.&quot; &quot;(&quot; &quot;)&quot; &quot;[&quot; &quot;]&quot; &quot;{&quot; &quot;}&quot; &quot;@&quot; &quot;*&quot; &quot;/&quot; &quot;&amp;&quot; &quot;#&quot; #&gt; [20] &quot;%&quot; &quot;`&quot; &quot;^&quot; &quot;+&quot; &quot;&lt;&quot; &quot;=&quot; &quot;&gt;&quot; &quot;|&quot; &quot;$&quot; digits are ordered ascendingly: the smaller digits appear earlier than the bigger ones. nums &lt;- 0:9 sort(nums) #&gt; [1] 0 1 2 3 4 5 6 7 8 9 Letters have two sorting rules. In R, letters is a pre-created character vector with all 26 lower-cased letters in the alphabet, and LETTERS is another character vector with all 26 upper-cased letters in the alphabet. Case-wise, lower cases go before upper cases. Letter-wise, letters are sorted alphabetically. all_letters &lt;- c(letters,LETTERS) sort(all_letters) #&gt; [1] &quot;a&quot; &quot;A&quot; &quot;b&quot; &quot;B&quot; &quot;c&quot; &quot;C&quot; &quot;d&quot; &quot;D&quot; &quot;e&quot; &quot;E&quot; &quot;f&quot; &quot;F&quot; &quot;g&quot; &quot;G&quot; &quot;h&quot; &quot;H&quot; &quot;i&quot; &quot;I&quot; &quot;j&quot; #&gt; [20] &quot;J&quot; &quot;k&quot; &quot;K&quot; &quot;l&quot; &quot;L&quot; &quot;m&quot; &quot;M&quot; &quot;n&quot; &quot;N&quot; &quot;o&quot; &quot;O&quot; &quot;p&quot; &quot;P&quot; &quot;q&quot; &quot;Q&quot; &quot;r&quot; &quot;R&quot; &quot;s&quot; &quot;S&quot; #&gt; [39] &quot;t&quot; &quot;T&quot; &quot;u&quot; &quot;U&quot; &quot;v&quot; &quot;V&quot; &quot;w&quot; &quot;W&quot; &quot;x&quot; &quot;X&quot; &quot;y&quot; &quot;Y&quot; &quot;z&quot; &quot;Z&quot; From the example below, you will find out that the letter-wise rule is prioritized over the case-wise rule. x &lt;- c(&quot;d&quot;, &quot;c&quot;) sort(x) #&gt; [1] &quot;c&quot; &quot;d&quot; y &lt;- c(&quot;d&quot;, &quot;C&quot;) sort(y) #&gt; [1] &quot;C&quot; &quot;d&quot; 2.10.2 Sort vectors with sort() You can surely apply sort() on character vectors. A character vector’s elements (i.e., strings) are sorted by their first character. If two elements have the same first character, they will be sorted by their second character. The rule applies until the indexed ties between two strings’ characters are broken, or two strings run out of characters. Let’s try to sort the character vector char_vec. sort(char_vec) #&gt; [1] &quot;_4&quot; &quot;.a&quot; &quot;.a&quot; &quot;&amp;u&quot; &quot;1a&quot; &quot;1c&quot; &quot;2a&quot; &quot;3&quot; &quot;a&quot; &quot;A&quot; &quot;aB&quot; &quot;ac&quot; &quot;b&quot; &quot;B&quot; We have the following observations. Symbols appear first, followed by digits, and letters appear last. According to the ordering rule of symbols, _4 goes first, .a (two of them) and &amp;u follow subsequently. 1a and 1c have the same first character. Between their second character, a goes before c, therefore 1a goes before 1c. aB and ac have the same first character, since b goes before C (although B is an upper case while c is a lower case), aB goes before ac. Of course, we can also have the order reversed by adding the argument decreasing = TRUE inside sort(). sort(char_vec, decreasing = TRUE) #&gt; [1] &quot;B&quot; &quot;b&quot; &quot;ac&quot; &quot;aB&quot; &quot;A&quot; &quot;a&quot; &quot;3&quot; &quot;2a&quot; &quot;1c&quot; &quot;1a&quot; &quot;&amp;u&quot; &quot;.a&quot; &quot;.a&quot; &quot;_4&quot; 2.10.3 Get ranks in vectors with rank() The same ordering rules introduced in subsection 2.10.1 do apply when R ranks a character vector’s strings. Here, the element with rank 1 is _4 and .a has rank 2. Just like numeric vectors, if you have strings with the same value (i.e., characters) in character vectors, these elements’ ranks will be the same (the average of the corresponding ranks) by default. rank(char_vec) #&gt; [1] 9.0 10.0 14.0 13.0 11.0 12.0 6.0 2.5 5.0 7.0 2.5 4.0 8.0 1.0 As expected, you can set the ties.method argument in rank() to use other methods for breaking ties. rank(char_vec, ties.method = &quot;min&quot;) #&gt; [1] 9 10 14 13 11 12 6 2 5 7 2 4 8 1 rank(char_vec, ties.method = &quot;first&quot;) #&gt; [1] 9 10 14 13 11 12 6 2 5 7 3 4 8 1 2.10.4 Get the ordering permutation via order() Again, you can use the same order() function to get the corresponding indices of a character vector’s strings. Also, the order() function breaks the ties by the appearing order by default. order(char_vec) #&gt; [1] 14 8 11 12 9 7 10 13 1 2 5 6 4 3 The decreasing argument still works for order(): order(char_vec, decreasing = TRUE) #&gt; [1] 3 4 6 5 2 1 13 10 7 9 12 8 11 14 2.10.5 Summary and comparisons Let’s put all sort-related functions together to clarify their functions. char_vec #&gt; [1] &quot;a&quot; &quot;A&quot; &quot;B&quot; &quot;b&quot; &quot;aB&quot; &quot;ac&quot; &quot;1c&quot; &quot;.a&quot; &quot;1a&quot; &quot;2a&quot; &quot;.a&quot; &quot;&amp;u&quot; &quot;3&quot; &quot;_4&quot; sort(char_vec) #&gt; [1] &quot;_4&quot; &quot;.a&quot; &quot;.a&quot; &quot;&amp;u&quot; &quot;1a&quot; &quot;1c&quot; &quot;2a&quot; &quot;3&quot; &quot;a&quot; &quot;A&quot; &quot;aB&quot; &quot;ac&quot; &quot;b&quot; &quot;B&quot; The sort() function sort char_vec according to previously introduced ordering rules. _4 goes first because its first character is a symbol (symbols &lt; digits &lt; letters), and _ goes before “.” and “&amp;”. rank(char_vec) #&gt; [1] 9.0 10.0 14.0 13.0 11.0 12.0 6.0 2.5 5.0 7.0 2.5 4.0 8.0 1.0 The rank() function gives the ranks of strings inside char_vec. The first returned rank is 9.0 because the first string in char_vec, namely “a”, is sorted in the 9th place in char_vec. The second returned rank is 10.0 because the second string in char_vec, namely “A”, is sorted in the 10th place in char_vec. order(char_vec) #&gt; [1] 14 8 11 12 9 7 10 13 1 2 5 6 4 3 The order() function gives the ordering permutation of char_vec. The first returned order is 14 because sorting char_vec will put this character vector’s 14th string, namely “_4”, in the first place. Similarly, the second returned order is 8 because sorting char_vec will put this character vector’s 8th string, namely “.a”, in the second place. 2.10.6 Exercises Suppose exercise &lt;- c(\"&amp;5\", \"Nd\", \"9iC\", \"3df\", \"df\", \"nd\", \"_5\", \"9ic\") Sort exercise in the ascending order. Explain why 1) 3df goes before 9ic; 2) &amp;5 goes before 3df; 3) 9ic goes before 9iC. Apply both rank() and order() to the character vector exercise. Within the two returned vectors, explain how does the element 7 means differently in two vectors. "],["factors.html", "2.11 Character Vectors, Factors &amp; Ordered Factors", " 2.11 Character Vectors, Factors &amp; Ordered Factors Having learned various aspects of character vectors, we will introduce a very important class of objects in this section, named factors. First, let’s create a character vector to be used in this section. animals &lt;- c(&quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;, &quot;sheep&quot;, &quot;sheep&quot;, &quot;pig&quot;) 2.11.1 Create a factor from a vector So, what is exactly a factor? It can be viewed as a special type of vector whose elements take on a fixed and known set of different values. You can create a factor from a vector using the factor() function. To understand the output of a factor, it is helpful to compare the results with the original vector animals. animals_fac &lt;- factor(animals) animals_fac #&gt; [1] sheep pig monkey sheep sheep pig #&gt; Levels: monkey pig sheep animals #&gt; [1] &quot;sheep&quot; &quot;pig&quot; &quot;monkey&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; First, note that the strings in the character vector all have quotation marks around the elements, while the corresponding factor doesn’t have them. Second, we see an additional row in the factor, starting with “Levels:”. This shows the unique elements of animals ordered alphabetically. If you use the class() function on animals_fac, you will see it is indeed a factor. class(animals_fac) #&gt; [1] &quot;factor&quot; class(animals) #&gt; [1] &quot;character&quot; To retrieve the levels of a factor, you can use the function levels() on it. levels(animals_fac) #&gt; [1] &quot;monkey&quot; &quot;pig&quot; &quot;sheep&quot; To have a deeper understanding on factors, it is helpful to check its internal storage type using typeof(). typeof(animals_fac) #&gt; [1] &quot;integer&quot; as.numeric(animals_fac) #&gt; [1] 3 2 1 3 3 2 Perhaps a bit surprisingly, a factor is stored as integers. The integers represent the corresponding locations of each element in the levels. For example, the first value of as.numeric(animals_fac) is 3, since the first element of animals_fac is \"sheep\", which is the third element in the levels. The particular storage mechanism for factors is very appealing in the sense that storing integers takes much less space than storing all the same levels repeatedly in the original character vector. As the same time, you can easily reproduce the original character vector using the integers and the factor levels using vector subsetting via indices. levels(animals_fac)[as.numeric(animals_fac)] #&gt; [1] &quot;sheep&quot; &quot;pig&quot; &quot;monkey&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; To show that factors indeed could take less memory than the corresponding character vectors when the levels are repeated many times, let’s see the following example where we use the object.size() function to check the estimate of memory used to store the corresponding object. many_animals &lt;- rep(c(&quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;), c(100,200,300)) many_animals_fac &lt;- factor(many_animals) object.size(many_animals) #&gt; 5016 bytes object.size(many_animals_fac) #&gt; 3032 bytes From this example, we can see that storing the information as a factor could offer substantial memory savings (about 40% in this example) compare to storing it as a character vector. Another advantage of factors over vectors is that it will detect any input that is outside of the levels. Let’s try to assign the string “Tiger” to the first element of both animals_fac and animals. animals_fac_new &lt;- animals_fac animals_fac_new[1] &lt;- &quot;Tiger&quot; animals_fac_new #&gt; [1] &lt;NA&gt; pig monkey sheep sheep pig #&gt; Levels: monkey pig sheep animals_new &lt;- animals animals_new[1] &lt;- &quot;Tiger&quot; animals_new #&gt; [1] &quot;Tiger&quot; &quot;pig&quot; &quot;monkey&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; Since \"Tiger\" is not inside the levels set, we see a warning in the assignment process and the value of the first element is modified to &lt;NA&gt;, indicating it is “Not Available”. We will cover NA in detail in Section 2.15. When the same assignment is done on the vector animals, there is no warning and the first element of animals is changed to “Tigers” as instructed. This is an attractive feature of factors that can prevent input errors. In addition to creating factors from character vectors, you can also create them from numeric vectors as well as logical vectors. x &lt;- rep(3:1, 1:3) x_fac &lt;- factor(x) y &lt;- rep(c(T, F), c(5, 3)) y_fac &lt;- factor(y) It is worth noting that after converting a numeric vector into a factor, the usual arithmetic operation can no longer be applied since the numbers become levels. x_fac[1] + 1 #&gt; Warning in Ops.factor(x_fac[1], 1): &#39;+&#39; not meaningful for factors #&gt; [1] NA The result is NA with a warning message that + is not meaningful for factors. 2.11.2 Set the factor levels and labels As we have seen, the factor() function extracts the unique elements from a vector and sort them as its levels. To manually specify the levels and their order, you can set the levels argument. For example, if you only want \"sheep\" and \"pig\" in the level, you can use the following code. factor(animals_fac, levels = c(&quot;pig&quot;, &quot;sheep&quot;)) #&gt; [1] sheep pig &lt;NA&gt; sheep sheep pig #&gt; Levels: pig sheep As you can see, the third element is now NA, since the corresponding value \"monkey\" is not in the set of levels. You can also create labels to represent each level of the factor by setting the labels argument in the factor() function. factor(animals_fac, levels = c(&quot;pig&quot;, &quot;sheep&quot;), labels = c(&quot;pretty_pig&quot;, &quot;smart_sheep&quot;)) #&gt; [1] smart_sheep pretty_pig &lt;NA&gt; smart_sheep smart_sheep pretty_pig #&gt; Levels: pretty_pig smart_sheep An alternative way to modify the levels of the factor is to assign the desired level vector to the levels() function with the factor as its argument. For example, if you want to translate the animals names into Spanish, you can use levels(animals_fac) &lt;- c(&quot;mona&quot;, &quot;cerda&quot;, &quot;oveja&quot;) animals_fac #&gt; [1] oveja cerda mona oveja oveja cerda #&gt; Levels: mona cerda oveja 2.11.3 Ordered factors By default, the function factor() creates an unordered factor, which is usually used when there are no natural ordering among the levels. Sometimes, there may be a natural ordering among the levels. Let’s see an example. conditions &lt;- c(&quot;excellent&quot;, &quot;good&quot;, &quot;excellent&quot;, &quot;good&quot;, &quot;average&quot;) factor(conditions) #&gt; [1] excellent good excellent good average #&gt; Levels: average excellent good Different from the animals in animals, the conditions have a natural ordering. We know average &lt; good &lt; excellent. To encode this information in a factor, you can create a so-called ordered factor by setting ordered = TRUE in the factor() function and specify the levels in the ascending order of the desired ordering. condition_ordered_fac &lt;- factor(conditions, ordered = TRUE, levels = c(&quot;average&quot;, &quot;good&quot;, &quot;excellent&quot;)) condition_ordered_fac #&gt; [1] excellent good excellent good average #&gt; Levels: average &lt; good &lt; excellent We can see that there is an ordering shown in the “Levels”. You can also make comparisons on ordered factors. condition_ordered_fac[1] &lt; condition_ordered_fac[2] #&gt; [1] FALSE The result is FALSE since excellent &gt; good. Let’s check what would be the result if we don’t specify order = TRUE. condition_fac &lt;- factor(conditions, levels = c(&quot;average&quot;, &quot;good&quot;, &quot;excellent&quot;)) condition_fac[1] &lt; condition_fac[2] #&gt; Warning in Ops.factor(condition_fac[1], condition_fac[2]): &#39;&lt;&#39; not meaningful #&gt; for factors #&gt; [1] NA The result is again NA, since the comparison &lt; is not meaningful for unordered factors. We will revisit the topic of factor ordering when generating bar charts in Section 5.8.2. 2.11.4 Exercises What are the advantages of factors over vectors? Suppose we define x &lt;- factor(1:5), what is the result of x[1] &lt; x[2]? Please try to answer this question without R. (a): TRUE (b): FALSE (c): NA Suppose we define x &lt;- factor(1:5, ordered = TRUE), what is the result of x[1] &lt; x[2]? Please try to answer this question without R. (a): TRUE (b): FALSE (c): NA Suppose we define x &lt;- factor(1:5, ordered = TRUE, levels = 5:1), what is the result of x[1] &lt; x[2]? Please try to answer this question without R. (a): TRUE (b): FALSE (c): NA Suppose size &lt;- rep(c(\"big\", \"small\", \"medium\"), 3:1), convert it to an ordered factor with levels small &lt; medium &lt; big. "],["logical-patterns.html", "2.12 Logical Vectors: Create with Repetitions and Summary Functions", " 2.12 Logical Vectors: Create with Repetitions and Summary Functions Whenever you need to create repeated vectors that are of logical type, you can conveniently achieve such tasks through methods you learned in @ref(patterned_numeric_vectors_creation) and 2.9. 2.12.1 Create logical vectors with repetitions Let’s start by recalling how we create numeric and character vectors with repetitions. The function we use is the rep() function, inside of which the first argument refers to elements to be repeated, and the second argument indicates the number of repetitions. num1 &lt;- rep(1, 3) cha1 &lt;- rep(&quot;sheep&quot;, 2) Remember that, the first argument can be 1) a number, 2) a character, 3) colon operator : (for numeric vectors), 4) a numeric vector with several values, and 5) a character vector with several values; the second argument can be 1) a number, 2) colon operator :, and 3) a numeric vector with several values. When only the first argument is a vector with several values, it is repeated as a whole, not elementwisely. When both arguments are vectors with several values, R will do an element repeat operation. num2 &lt;- rep(c(1, 0), 3) num3 &lt;- rep(1:3, 3:1) num4 &lt;- rep(c(1, 0), c(2, 2)) char2 &lt;- rep(c(&quot;apple&quot;, &quot;chocolate&quot;), 2) char3 &lt;- rep(c(&quot;apple&quot;, &quot;chocolate&quot;), 1:2) char4 &lt;- rep(c(&quot;apple&quot;, &quot;chocolate&quot;), c(3, 3)) If you feel confident creating numeric and character vectors with repetitions, the ways of creating logical vectors with repetitions are basically at your fingertips: logic &lt;- rep(c(TRUE, FALSE, NA), c(3,2,1)) logic 2.12.2 Statistical Functions on Logical Vectors Before we end our study of logical vectors with logical operators in next section, we will take a look at how some previously introduced summary functions can be used on logical vectors. Group A: summary statistics What if we apply summary() on logical vectors? logic &lt;- rep(c(T,F,T,NA), 4:1) summary(logic) #&gt; Mode FALSE TRUE NA&#39;s #&gt; logical 3 6 1 Similar to character vectors, you can get the vector type, which is logical here. You also get a frequency table for the times FALSE, TRUE, and missing values NA appear in the vector. Group B: arithmetic operations Different from character vectors, logical vectors can be used in ordinary arithmetic, meaning you can apply almost all the functions summarized in Table ?? to logical vectors. In such cases, the coercion rule introduced in Section 2.4 will convert every TRUE to 1 and FALSE to 0. Let’s take a look at an example, a &lt;- c(TRUE, TRUE, FALSE, FALSE, TRUE) sum(a) #&gt; [1] 3 mean(a) #&gt; [1] 0.6 Clearly, to proceed calculations, R considers a having three 1s and two 0s, given there are three TRUE and two FALSE. Therefore, sum(a)equals 3 andmean(a)` equals 0.6. You are welcome to try other functions on a logical vector. However, as much as TRUE and FLASE will be coerced into specific numeric values, missing values NA won’t be coerced to an assigned value. Therefore, ordinary arithmetic involving NA will return NA as well, meaning the result is not available. b &lt;- c(TRUE, FALSE, TRUE, NA) sum(b) #&gt; [1] NA mean(b) #&gt; [1] NA d &lt;- c(1:5, NA) sum(d) #&gt; [1] NA e &lt;- c(1:5, NaN) sum(e) #&gt; [1] NaN f &lt;- c(1:5, NA, NaN) is.na(d) #&gt; [1] FALSE FALSE FALSE FALSE FALSE TRUE is.nan(d) #&gt; [1] FALSE FALSE FALSE FALSE FALSE FALSE 2.12.3 Exercises Write the R code to create logical vectors with the following results, then show the unique elements and their corresponding frequencies in each vector: a).FALSE TRUE NA FALSE TRUE NA b). FALSE FALSE TRUE TRUE TRUE NA Write two different R codes using rep() function to create a logical vector with values TRUE FALSE TRUE FLASE. The two codes should have at least one argument different from each other. "],["logical_operators.html", "2.13 Logical Vectors: Logical Operators", " 2.13 Logical Vectors: Logical Operators In Section 2.5, you learned how to do vector subsetting, which yields a subvector of the original vector. Let’s take a numeric vector x &lt;- 1:5 as an example. To get a subvector of x with values greater than 3, you can create a logical vector, and then use it as the index to do vector subsetting. x &lt;- 1:5 xb3 &lt;- x &gt; 3 set1 &lt;- x[xb3] set1 #&gt; [1] 4 5 Here, the numeric vector set1 has values 4 5. You can get another subvector of x by running the following codes. xs4 &lt;- x &lt;= 4 set2 &lt;- x[xs4] set2 #&gt; [1] 1 2 3 4 Sometimes, you may want to get a subvector containing elements that satisfy more than one conditions. For example, how can we find the subvector of x with values larger than 3 and less than or equal to 4? In this section, we will introduce several logical operators and use them to get subvectors. Here, we will focusing on applying logical operators on logical vectors, but keep in mind that many of the example here could be used to express complex arguments in R. Before we get started, let’s create another numeric vector y, and compare it to 8 and 9, separately. Then you will get two logical vectors with the same values as xb3 and xs4. y &lt;- 6:10 yb8 &lt;- y &gt; 8 #xb3 is the same as yb8 ys9 &lt;- y &lt;= 9 #xs4 is the same as ys9 2.13.1 NOT operator by ! The first operator we want to introduce is !, often called the NOT operator. The NOT operator returns the opposite of the input logical values. It is intuitive to understand since if something is NOT FALSE, then it is TRUE; and if it is NOT TRUE, then it has to be FALSE. The effect of ! is summarized in the following table. Operation Result ! TRUE FALSE ! FALSE TRUE Let’s see what happens if you apply the NOT operator on a logical vector with more than one element. !c(FALSE, FALSE, FALSE, TRUE, TRUE) #the opposite of a logical vector #&gt; [1] TRUE TRUE TRUE FALSE FALSE Here, you get another logical vector with the same length as the original one. The value of each element in the output is the opposite of the corresponding value in the original vector. Since xb3 is also a logical vector, you can apply ! on xb3 and use !xb3 (which is also a logical vector) to do vector subsetting. Guess what you will get? !xb3 #&gt; [1] TRUE TRUE TRUE FALSE FALSE set3 &lt;- x[!xb3] set3 #&gt; [1] 1 2 3 Of course, the resulting numeric vector set3 will have 1 2 3 as values! As a result, set1 and set3 are complements of each other from the whole vector x. We can actually get back x with xb3 alone, with some help of vector subsetting and vector concatenation introduced in previous sections. c(x[!xb3], x[xb3]) == x #&gt; [1] TRUE TRUE TRUE TRUE TRUE 2.13.2 AND operator by &amp; Now, we will introduce the AND operator &amp;. For two logical vectors of the same length, &amp; performs comparisons elementwisely. For each location of the resulting vector, the value will be TRUE if the values in the same location of the input two vectors are both TRUE, and will be FALSE otherwise. In particular, for each element, we have the following summary. Operation Result TRUE &amp; TRUE TRUE TRUE &amp; FALSE FALSE FALSE &amp; TRUE FALSE FALSE &amp; FALSE FALSE Let’s see an example of the AND operation between two logical vectors of the same length. c(FALSE, FALSE, FALSE, TRUE, TRUE) &amp; c(TRUE, TRUE, FALSE, TRUE, FALSE) #&gt; [1] FALSE FALSE FALSE TRUE FALSE As explained before, the AND operator works elementwisely, and the intermediate step is as below. c(FALSE &amp; TRUE, FALSE &amp; TRUE, FALSE &amp; FALSE, TRUE &amp; TRUE, TRUE &amp; FALSE) #&gt; [1] FALSE FALSE FALSE TRUE FALSE As you can see from the result, only the fourth element is TRUE since the fourth element of both input logical vectors is TRUE. Since the AND operator makes comparisons elementwisely, the recycling rule also works here. As in the arithmetic operations, normally, we mix one vector with length &gt; 1 and another one with length 1. c(FALSE, FALSE, FALSE, TRUE, TRUE) &amp; FALSE #&gt; [1] FALSE FALSE FALSE FALSE FALSE Using the AND operator, you can now easily get a subvector of x with value(s) &gt; 3 and &lt;= 4. Recall that at the beginning of this section, you have created two logical vectors xb3 and xs4, then let’s apply &amp; on them, xb3 &amp; xs4 #&gt; [1] FALSE FALSE FALSE TRUE FALSE From the result, you know that both xb3 and xs4 have value TRUE for the fourth element, which means the statement that the value is &gt; 3 and &lt;= 4 is TRUE for the fourth element in x. Then, you can use xb3 &amp; xs4 (a logical vector) to do vector subsetting. x[xb3 &amp; xs4] #&gt; [1] 4 Here, you get a subvector of x with the value 4. Since xs4 and ys9 have the same values, you will get the same result if you include ys9 to get a subvector. Therefore, you can try the following codes by yourself. x[xb3 &amp; ys9] x[yb8 &amp; ys9] Note that the logical vector used to do vector subsetting needs to be of the same length as the original vector. Since x and y have the same length, the logical vectors from above can also be used to get subvectors of y. For example, you will get the same result from the following four codes. y[xb3 &amp; xs4] y[yb8 &amp; ys9] y[xb3 &amp; ys9] y[yb8 &amp; xs4] 2.13.3 OR operator by | The OR operator | works similarly to the AND operator &amp;, but the difference is that | returns TRUE if there is at least one TRUE among the two elements at the same location in the two vectors. The working mechanism of | is summarized below. Operation Result TRUE | TRUE TRUE TRUE | FALSE TRUE FALSE | TRUE TRUE FALSE | FALSE FALSE Let’s try another example on length &gt; 1 vectors and compare the result with that when we use the AND operator &amp;. c(FALSE, FALSE, FALSE, TRUE, TRUE) | c(TRUE, TRUE, FALSE, TRUE, FALSE) #&gt; [1] TRUE TRUE FALSE TRUE TRUE c(FALSE, FALSE, FALSE, TRUE, TRUE) &amp; c(TRUE, TRUE, FALSE, TRUE, FALSE) #&gt; [1] FALSE FALSE FALSE TRUE FALSE You also get a length-5 logical vector with an elementwise OR operation |, which is very different from the result with AND operation &amp;. Naturally, you can also use xb3 | xs4 to do vector subsetting, leading to another length-5 logical vector. xb3 | xs4 #&gt; [1] TRUE TRUE TRUE TRUE TRUE x[xb3 | xs4] #&gt; [1] 1 2 3 4 5 Wow! You get all five elements of x! That’s because the statement “the value is either &gt; 3 or &lt;= 4” is TRUE for all elements in x. 2.13.4 Exclusive OR by xor Last but not least, we introduce the exclusive OR operator xor. From the name, it’s easy to know that xor is an extended form of |. Here are some examples, Operation Result xor(TRUE, TRUE) FALSE xor(TRUE, FALSE) TRUE xor(FALSE, TRUE) TRUE xor(FALSE, FALSE) FALSE Unlike the OR operator, xor() returns TRUE when there is one and only one TRUE among values of these two logical vectors. If these two vectors have the same value, both TRUE or both FALSE, you will get the value FALSE. For two length &gt; 1 vectors, xor() again performs comparisons elementwisely. You can check the result by yourself! xor(c(FALSE, FALSE, FALSE, TRUE, TRUE), c(TRUE, TRUE, TRUE, TRUE, FALSE)) #&gt; [1] TRUE TRUE TRUE FALSE TRUE Since you also get a logical vector after applying xor(), you can use it to do vector subsetting. Using different combinations to do vector subsetting is interesting. Try them! x[xor(xb3, xs4)] y[xor(!xb3, ys9)] y[xor(yb8, !ys9)] 2.13.5 Summary of Logical Operators Let’s summarize the logical operators between two vectors. The NOT operator ! returns the opposite of each value. The AND operator &amp; returns TRUE if both are TRUE. The OR operator | returns TRUE if at least one is TRUE. The exclusive OR operator xor() returns TRUE if one and only one is TRUE. 2.13.6 Exercises Consider the vector v1 &lt;- seq(from = 1, to = 100, by = 3), and v2 &lt;- sqrt(v1). Find the subvector of v1 with values bigger than 30 and less than 60. And assign the subvector to name v1s. Find the subvector of v2 such that the corresponding value of v1 is less than 20 or larger than 50. Use an example to verify \\[xor(a, b) = (!a &amp; b) | (a &amp; !b)\\] "],["set-operations.html", "2.14 Set Operations", " 2.14 Set Operations 2.14.1 Set operations We’ve spent a couple sections introducing numeric, character, and logical vectors separately. In this section, we’ll continue discussing set operations between two vectors of the same type. However, all set operators in this section are applicable to all three types off vectors. For later convenience, let’s create some numeric, character, and logical vectors now. num1 &lt;- c(1, 2, 1, 3, 1) num2 &lt;- c(1, 1, 3, 4, 4, 5) char1 &lt;- c(&quot;sheep&quot;, &quot;monkey&quot;, &quot;sheep&quot;, &quot;chicken&quot;) char2 &lt;- c(&quot;sheep&quot;, &quot;pig&quot;, &quot;pig&quot;) log1 &lt;- c(T, F, F, T) log2 &lt;- c(T, T, T) a. Intersection When attempting to inspect values appeared in both vectors, you can use the intersect() function. Such values can be anything that can be put inside numeric vectors, character vectors, or logical vectors. intersect(num1,num2) #&gt; [1] 1 3 intersect(char1,char2) #&gt; [1] &quot;sheep&quot; intersect(log1,log2) #&gt; [1] TRUE Taking a closer look at the outputs, you will notice that the intersection procedure discards duplicate values in two vectors of the same type. In other words, only the unique elements are retained in the output. b. Union While intersect() gives values appeared in both vectors of interest, the union() function outputs all values that appear in at least one vector in the arguments. union(num1, num2) #&gt; [1] 1 2 3 4 5 union(char1,char2) #&gt; [1] &quot;sheep&quot; &quot;monkey&quot; &quot;chicken&quot; &quot;pig&quot; union(log1,log2) #&gt; [1] TRUE FALSE Again, only one copy of each value is retained in the output. c. Set difference To get values that are only included in one of the two vectors of interest, you can use the setdiff() function. Now, it’s important to keep in mind that, inside the function, the first argument will be the one you’d like to inspect its unique values. Let’s start with num1 and num2, two numeric vectors we created at the beginning of this section. To get values that only appear in num1 but not num2, num1 will become the first argument and num2 will be the second/last argument. setdiff(num1, num2) #&gt; [1] 2 Then you will get the result of 2! Reflecting on the output, you should realize that the setdiff() function only cares whether a value only appears, not if a value appears more or less frequently, in the specific vector of interest (in our case, num1). The rationale is that the setdiff() function will get unique elements in the arguments before setting the difference between them. Similarly, if you want to get values in num2 but not in num1, num2 should be in the first argument and num1 is in the second. These rules also apply to character vectors and logical vectors. setdiff(num2, num1) #&gt; [1] 4 5 setdiff(char1, char2) #&gt; [1] &quot;monkey&quot; &quot;chicken&quot; setdiff(log2, log1) #&gt; logical(0) d. Set equality To check whether two vectors are the same, you can use the setequal() function. Similar to the setdiff() function, the setequal() function works by looking at whether the two vectors have same set of unique values. setequal(num1, num2) #&gt; [1] FALSE setequal(char1, char2) #&gt; [1] FALSE setequal(log1, log2) #&gt; [1] FALSE Of course you will get FALSE in each operation: num1 has a unique value 2, char1 and char1 each have their unique values, and \"F\" only appears in log1. However, you will get get TRUE in the following examples, setequal(c(1, 1, 2), c(1, 2)) #&gt; [1] TRUE setequal(c(&quot;apple&quot;, &quot;apple&quot;, &quot;peach&quot;), c(&quot;apple&quot;, &quot;peach&quot;)) #&gt; [1] TRUE setequal(c(&quot;T&quot;, &quot;T&quot;, &quot;F&quot;, &quot;F&quot;), c(&quot;T&quot;, &quot;F&quot;)) #&gt; [1] TRUE e. Membership determination Finally, to check whether each element of one vector is inside the other vector in the arguments, you can use the is.element() function or the %in% operator. They are identical to each other. The order of vectors is also important for membership determination. is.element(num1, num2) #&gt; [1] TRUE FALSE TRUE TRUE TRUE char2 %in% char1 #&gt; [1] TRUE FALSE FALSE log1 %in% log2 #&gt; [1] TRUE FALSE FALSE TRUE For is.element() and %in%, the output will be a logical vector and its length will be the same as the first argument. In the first example above, the output is a logical vector of length-5, the same length as num1. The first element of num1 is 1, and num2 also has elements with value 1, so the first element of the logical vector is TRUE. The second element of num1 is 2, but num2 doesn’t have any elements with value 2, hence the result is FALSE. You can verify the other elements by yourself. Even if the first value of num2 is not 1, as long as 1 appears somewhere in num2, the first element of the output would still be TRUE. In other words, is.element() and %in% don’t take the values’ indices into consideration. 2.14.2 Applicance of the coercion rule At the beginning of this section, we’ve stressed that set operations are performed on two vectors of the same type. What about set operations on two vectors of different types? Are such operations achievable? The answer is Yes! Remember in Section 2.4, you learned the coercion rule, which basically indicates that R will unify all elements into the most complex type. When you apply set operations on two vectors of different types, R will coerce the simpler vector to the more complex vector’s type and subsequently perform set operations of the same type. Below is how R recognize each vector type’s complexity, from the simplest to the most complex. \\[\\mbox{logical} &lt; \\mbox{numeric} &lt; \\mbox{character}\\] Let’s try some examples. x &lt;- 1:6 y &lt;- c(T, T, F, T) intersect(x, y) #&gt; [1] 1 union(x, y) #&gt; [1] 1 2 3 4 5 6 0 setdiff(x, y) #&gt; [1] 2 3 4 5 6 setequal(x, y) #&gt; [1] FALSE is.element(x, y) #&gt; [1] TRUE FALSE FALSE FALSE FALSE FALSE In the example above, x and y are a numeric vector and a logical vector, respectively. When they become the arguments of set operations, the vector of the simpler type, y, is coerced to the more complex type, numeric type in this case. Specifically, TRUE is coerced to 1 and FALSE is coerced to 0. This is why you get a value of 0 when performing intersect(), when 0 doesn’t look like extant in either x or y. From there, set operations are basically performed on two numeric vectors. 2.14.3 Summary Please find a summary of the set operations between x and y in the following table. x and y are two vectors of the same type. If two vectors are of different vector types, the coercion rule will be applied as introduced above. Operation Code Argument_Order Intersection intersect(x, y) insensitive Union union(x, y) insensitive Set Difference setdiff(x, y) sensitive Set Equality setequal(x, y) insensitive Membership Determination is.element(x, y) sensitive 2.14.4 Exercises Consider the vector s1 &lt;- seq(from = 1, to = 100, length.out = 7). Compare s1 to 50 to see whether the values of s1 are bigger than 50, then assign the result to name s2. Compare s1 to 80 to see whether the values of s1 are less or equal to 80, then assign the result to name s3. Use two methods (logical operators and set operations) to find the subvector of s1 with values bigger than 50 and less or equal to 80. For x &lt;- 1:200, use two methods (logical operators and set operations) to find the subvector of x that is divisible by 7, but not divisible by 2. "],["missing-values.html", "2.15 Missing Values (NA)", " 2.15 Missing Values (NA) So far, we have been working with the ideal case that the vector is fully observed without any missing values. However, in most applications, you may encounter the situation, where some values like NA or a large value 999, which represent missingness in the data set for certain variables, and such values can be resulted from one of the below situations: the observer fails to record the data, meaning the value is not available at the given position of a vector or a data frame, or the data is impossible or undefined, meaning the value is resulted from an error or logical contradiction, such as dividing by 0. In two scenarios, R uses a) NA, indicating they are not available, and b) NaN, indicating they are not a number to present those values, respectively. Let’s see the following example. a &lt;- 1:10 a[11] #&gt; [1] NA Here, you have defined a as a length-10 numeric vector with 10 values in it. If you try to access the 11-th element of a, it is not available, hence you will see NA as the result. Sometimes, the values of some elements in a vector are missing, then you can use NA for these elements. Here is an example containing NAs as some values. If you want to get values of the 2nd and 4th elements in b, you will get NA NA as the result. b &lt;- c(1, NA, 2, NA, 3) b #&gt; [1] 1 NA 2 NA 3 b[c(2,4)] #&gt; [1] NA NA Let’s see another example. b &lt;- 0/0 If you look at the environment panel, you will see that b has a value of NaN, because arithmetically you cannot divide a number by 0. c &lt;- c(NA, NA) class(b) #&gt; [1] &quot;numeric&quot; typeof(b) #&gt; [1] &quot;double&quot; class(c) #&gt; [1] &quot;logical&quot; typeof(c) #&gt; [1] &quot;logical&quot; By running the above codes, you can notice that NA is stored as a logical type, whereas NaN is stored as a numeric type. Now you have had a basic understanding of NA and NaN. In the following parts of this section, we want to introduce several properties of them. Let’s start with the fact that NA is contagious. 2.15.1 NA and NaN are contagious a. NA NA implies that the underlying value is not available, in other words, there is uncertainty with the value. As a result, for most operations associated with NA, the results will also be NA, showing that NA is contagious. y &lt;- NA y + 3 #&gt; [1] NA y == 3 #&gt; [1] NA As you can see here, y is NA, indicating the value of y is not available. When you try to do operations like y + 3 or y == 3, the answers are clearly not available as well, hence both taking the value NA. How about we create another NA object and compare it with y? z &lt;- NA y == z #&gt; [1] NA NA == NA #&gt; [1] NA It is again NA, which may be confusing at a first thought. However, keep in mind that since both y and z are not available, there is no way to tell whether they are the same. Hence y == z is also NA. Think about what is the value of 1NA in R. Try to run it in R. Does it agree with your thoughts? Think about what is the value of 0NA in R. Try to run it in R. Does it agree with your thoughts? Answer 1. For any \\(x\\), we have \\(1^x = \\exp(\\log (1^x)) = \\exp(x \\log 1) = \\exp(x \\cdot 0) = 1\\). Since there is no uncertainty regarding the expression, the value of 1NA is 1 Answer 2. We have \\(0^0 = \\lim_{x\\to 0}x^x =\\exp[\\lim_{x\\to 0} x\\log(x)]=\\exp[0] = 1\\), and \\(0^1 = 0\\). Since NA represents uncertainty values, it can be 0 or 1 or other numbers. So 0NA is not deterministic because it can take different values according to the exponent. Hence, the value of 0NA is also NA. Now, let’s talk about what impact the NA values make when we apply statistical functions. Let’s create a vector containing NA values, and apply some functions on it. x &lt;- c(1, NA, 3, 4, NA, 2) x #&gt; [1] 1 NA 3 4 NA 2 sum(x) #&gt; [1] NA mean(x) #&gt; [1] NA sd(x) #&gt; [1] NA As you can see, for many statistical functions on vectors, as long as there exists at least one NA values in vectors, the results are often impossible to determine, hence resulting an NA value as well. As a result, you may want to ignore the NA values during the function evaluation. Fortunately, most statistical functions on vectors provide an optional argument na.rm, which takes a logical value, indicating whether to remove NA before applying the functions. Let’s see the following examples. sum(x, na.rm = TRUE) #&gt; [1] 10 mean(x, na.rm = TRUE) #&gt; [1] 2.5 sd(x, na.rm = TRUE) #&gt; [1] 1.290994 It is easy to verify that the results are what we expect to get if the NA values are removed. Feel free to try the following codes which apply the same functions on the subvector with the non-missing values. x_no_na &lt;- c(1, 3, 4, 2) sum(x_no_na) mean(x_no_na) sd(x_no_na) Interesting, the summary() function will deal with the NA values automatically by removing them before computing the five percentiles and the mean. In addition, the summary() function provides a column which shows the number of NAs in x. summary(x) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s #&gt; 1.00 1.75 2.50 2.50 3.25 4.00 2 b. NaN b * 3 #&gt; [1] NaN b + 3 #&gt; [1] NaN Similar to NA, NaN is also contagious, because numeric calculations on undefined values are also undefined. d &lt;- c(1, 2, 3, 0/0) d #&gt; [1] 1 2 3 NaN sum(d) #&gt; [1] NaN mean(d) #&gt; [1] NaN sd(d) #&gt; [1] NA sum(d, na.rm = TRUE) #&gt; [1] 6 mean(d, na.rm = TRUE) #&gt; [1] 2 sd(d, na.rm = TRUE) #&gt; [1] 1 Moreover, if a vector consists undefined values, applying statistical functions on it will also result in NaN, and you can still use na.rm to remove NaN before applying the functions. 2.15.2 Work with NA values Since NA is far more common in real-life applications, we’ll focus this section on NA values. When there are NA values in our vector, there is nothing to be afraid of as there are many useful tools we can use. Let’s use x &lt;- c(1, NA, 3, 4, NA, 2) throughout this part. a. Find indices with missing values Firstly, we will introduce how to find indices with missing values. To find the indices, you may be tempted to use the comparison operator introduced in Section 2.3.1. Let’s try to compare x with NA as the following code. x == NA #&gt; [1] NA NA NA NA NA NA You get a vector of all values equaling NA! This is actually not surprising for the following reason. Given that the NA you are comparing can take any unknown value, any comparison with it will result in an NA value due to the lack of information. Instead of using == for finding missing values, the correct way is to use the is.na() function, which returns a logical vector representing whether the value of each element is missing or not. Then, you can use the which() function which can return the locations of all TRUE values to find the indices for the NA values. Here, the sum() function on the logical vector x_na returns the number of NA values in the vector, following the coercion rule described in Section 2.12.2. x_na &lt;- is.na(x) #logical vector x_na #&gt; [1] FALSE TRUE FALSE FALSE TRUE FALSE which(x_na) #numeric vector #&gt; [1] 2 5 sum(x_na) #the number of NAs in x #&gt; [1] 2 sum(!x_na) #the number of non-NAs in x #&gt; [1] 4 If you only want to detect whether there is any NA values in the vector, you can use the anyNA() function. anyNA(c(NA, 1)) #&gt; [1] TRUE anyNA(1:3) #&gt; [1] FALSE b. Remove missing values Sometimes, you may want to simply remove the missing values. To do that, you can use a logical vector to do vector subsetting as introduced in Section 2.5.2. The specific logical vector you want to use is the opposite (!) of the logical vector that represents missing values. Then you will get a subvector of x which keeps all values except NA. You can also use the na.omit() function to achieve the same result. x2 &lt;- x[!x_na] x2 #&gt; [1] 1 3 4 2 na.omit(x) #&gt; [1] 1 3 4 2 #&gt; attr(,&quot;na.action&quot;) #&gt; [1] 2 5 #&gt; attr(,&quot;class&quot;) #&gt; [1] &quot;omit&quot; c. Impute missing values In many applications, naively removing the missing values before doing the analysis may lead to incorrect inference. Usually, it is useful to make the data complete by imputing the missing values. For example, you can use mean imputing or median imputing, which replaces the missing values with the mean or median of the non-missing values. x_impute &lt;- x mean(x, na.rm = TRUE) #&gt; [1] 2.5 x_impute[x_na] &lt;- mean(x, na.rm = TRUE) x_impute #&gt; [1] 1.0 2.5 3.0 4.0 2.5 2.0 x #&gt; [1] 1 NA 3 4 NA 2 If you want to compare the values of an object before and after some operations, you can create a new object with the same value as the original object (here, we create x_impute which has the same value as x), then make operations on x_impute without changing the value of x. In x_impute, values of the 2nd and 5th elements are replaced by 2.5, the average of the non-missing values of x. d. Replace non-standard missing values with NA in the vector Sometimes, the data we collected may not use NA to indicate that a value is missing. For example, in the following vector x3, the value 999 represents the corresponding element that is missing. x3 &lt;- c(4, 999, 1, 999, 3, 999, 999) It is highly recommended to convert these values into NA before carrying out any analysis. x3[x3 == 999] &lt;- NA x3 #&gt; [1] 4 NA 1 NA 3 NA NA Let’s see another example where both 999 and -999 represent the value is missing. You can convert all 999 and -999 into NA by using operations introduced in Section 2.14. x4 &lt;- c(4, 999, 1, -999, 3, -999, 999) ##999 and -999 are the values indicating missingness x4[x4 %in% c(999, -999)] &lt;- NA x4 #&gt; [1] 4 NA 1 NA 3 NA NA 2.15.3 Exercises For the vector x &lt;- rep(c(1, 2, NA), 3:5), verify each value of summary(x) by using other functions. find the indices with missing values; create a vector x_no_na containing the non-missing values in x; replace those missing values by the median of the non-missing values in x. For the vector y &lt;- rep(c(\"N\", 2, \"A\"), 5:3), the values of both \"N\" and \"A\" indicate missingness. Convert non-standard missing values to NA, then find the indices of y that correspond to missing values. "],["date-time.html", "2.16 Dates and Times", " 2.16 Dates and Times Now you have learned numeric vectors, character vectors and logical vectors which are quite intuitive. In this section, we want to introduce two special formats of vectors in R which are dates and times. Dates and times belong to vectors because they only contain values of the same type. 2.16.1 Dates a. Date class Let’s first look at a vector in the date format. First, to get today’s date, you can use the Sys.Date() function. Similarly, you can verify its class by using the class() function. today &lt;- Sys.Date() today #&gt; [1] &quot;2024-10-23&quot; class(today) #&gt; [1] &quot;Date&quot; Looking at the output, we know that today is a vector of the Date class. You may be wondering how are the dates stored in R. To get this information, you can use the typeof() function on a date object. typeof(today) #&gt; [1] &quot;double&quot; This may look a bit surprising to you. Indeed, dates objects are stored as numeric values (in “double” to be precise), representing the (signed) number of days that has passed since Jan 1, 1970 (The reference date in R). To get this information, you can convert it to a number by as.numeric(). as.numeric(today) #&gt; [1] 20019 Storing the dates as numbers makes it handy to perform additions and subtractions. For example, you can use today - 1 to get the date of yesterday, and use today + 1 to get the date of tomorrow. today - 1 #&gt; [1] &quot;2024-10-22&quot; today + 1 #&gt; [1] &quot;2024-10-24&quot; The computation in R is done by adding or subtracting one to the number of days since Jan 1, 1970. Although the output of today looks similar to a string, you will get a character vector if you assign value(s) like \"2021-09-09\" to a name. You you can verify its class by using class(). Of course, an error will show up if you try to do addition or subtraction operations on a character vector. date_char &lt;- &quot;2021-09-09&quot; class(date_char) #&gt; [1] &quot;character&quot; date_char - 1 #&gt; Error in date_char - 1: non-numeric argument to binary operator You can also get the days of week, months, and quarters for a date using the functions weekdays(), months(), and quarters(). weekdays(today) months(today) quarters(today) b. Converting between dates and strings Now, you may be wondering what information we can extract out of an object of the date class. We can use the format() function to convert a date class object into a string that contains various information about the date. First, let’s introduce a list of commonly used elements of dates and the corresponding conversion specification. A conversion specification is usually formed by % followed by a single letter. The following table shows a list of common conversion specifications. Code Name Example %m 2-digit month 10 %d 2-digit day 23 %y 2-digit year 24 %Y 4-digit year 2024 %a abbreviated weekday Wed %A full weekday Wednesday %b abbreviated month Oct %B full month October Then, for a Date class object, we can create a format string that contains any number of the conversion specifications in the previous table. The working mechanism of format() is that, it will scan through the format string, look for all the conversion specifications, and convert the conversion specifications into their corresponding values for the given date. Any character in the format string that is not part of a conversion specification is interpreted literally (and %% gives %). Let’s see an example. format(today, &quot;Today is %A (%a for short), %b %d, %Y. It is also %m/%d/%Y&quot;) #&gt; [1] &quot;Today is Wednesday (Wed for short), Oct 23, 2024. It is also 10/23/2024&quot; On the other hand, we can also convert a string back into a Date class object. To do that, you can use the as.Date() function with the string along with the corresponding format string in the fomat argument. You can also specify the tryFormats argument, which contains a character vector with all possible formats to try. Aug &lt;- as.Date(&quot;08-01-2021&quot;, format = &quot;%m-%d-%Y&quot;) Aug #&gt; [1] &quot;2021-08-01&quot; class(Aug) #&gt; [1] &quot;Date&quot; Here, the value of format corresponds to each part in string. %m corresponds to 08, which is the month of the date. %d corresponds to 01, which is the day of the date. %Y corresponds to 2021, which is the year of the date. Now you have successfully converted the string into a vector of the Date class! The as.Date() function can be viewed as the inverse function of format() when we use the same format string. as.Date(format(today, format = &quot;%m-%d-%Y&quot;), format = &quot;%m-%d-%Y&quot;) Notice that the correspondence of the string and supplied format should follow the above table, otherwise you may get some unexpected result. as.Date(&quot;08-01-2021&quot;, format = &quot;%B-%d-%Y&quot;) #wrong #&gt; [1] NA as.Date(&quot;August-01-2021&quot;, format = &quot;%B-%d-%Y&quot;) #correct #&gt; [1] &quot;2021-08-01&quot; Here, you should use August rather than 08 in string because %B corresponds to full month, so you get NA as the result. In addition to use - as the separator, you can also use / as the separator. If the separators used in the string and the format doesn’t match in as.Date(), you will also get NA as the result. as.Date(&quot;08/01/2021&quot;, format = &quot;%m/%d/%Y&quot;) #&gt; [1] &quot;2021-08-01&quot; as.Date(&quot;08/01/2021&quot;, format = &quot;%m-%d-%Y&quot;) #&gt; [1] NA as.Date(&quot;08/01/2021&quot;, format = &quot;%m-%d/%Y&quot;) #&gt; [1] NA You can try different combinations by yourself. Here are some examples！ as.Date(&quot;01-03-2021&quot;, format = &quot;%m-%d-%Y&quot;) #&gt; [1] &quot;2021-01-03&quot; as.Date(&quot;01-03-2021&quot;, format = &quot;%d-%m-%Y&quot;) #&gt; [1] &quot;2021-03-01&quot; as.Date(&quot;Apr-03-2021&quot;, format = &quot;%b-%d-%Y&quot;) #&gt; [1] &quot;2021-04-03&quot; as.Date(&quot;09/October/97&quot;, format = &quot;%d/%B/%y&quot;) #&gt; [1] &quot;1997-10-09&quot; as.Date(&quot;2010-02-29&quot;, format = &quot;%Y-%m-%d&quot;) #&gt; [1] NA It is worth noting that the last output is NA, indicating that Feb 29, 2010 is not a valid date. That’s because only leap years have 29 days in February! In addition to manually specifying a single format for the conversion, the as.Date() function also has a parameter tryFormats which could include multiple formats, for which the functions will try sequentially until the supplied string matches with a particular format. The default value of tryFormats is c(\"%Y-%m-%d\", \"%Y/%m/%d\"). Note that the first format %Y-%m-%d is the ISO 8601 international standard. as.Date(&quot;2010-02-28&quot;) #&gt; [1] &quot;2010-02-28&quot; as.Date(&quot;2010/03/28&quot;) #&gt; [1] &quot;2010-03-28&quot; Although this may work well when you are certain the default formats match the character vector provided, all elements have to be of the same format. as.Date(c(&quot;2010-02-28&quot;, &quot;2010/03/28&quot;)) #&gt; [1] &quot;2010-02-28&quot; NA As a precaution, it is recommended that you manually supply the format via the format argument and make sure all the elements follow the format. We can also construct date using the number of days since a reference date using the origin argument in the as_date() function. as.Date(10, origin = &quot;2021-01-01&quot;) #10 days after 2021-01-01 #&gt; [1] &quot;2021-01-11&quot; c. difftime class Now, let’s introduce a very useful class named difftime. From the name, you may be able to tell it is designed to represent time differences. Let’s see an example when we subtract between two dates objects. ref_date &lt;- as.Date(&quot;1970/01/01&quot;, format = &quot;%Y/%m/%d&quot;) days_diff &lt;- today - ref_date #the time difference between two dates days_diff #&gt; Time difference of 20019 days class(days_diff) #&gt; [1] &quot;difftime&quot; To learn more about the difftime class, let’s look at its structure. str(days_diff) #&gt; &#39;difftime&#39; num 20019 #&gt; - attr(*, &quot;units&quot;)= chr &quot;days&quot; You can see that it is stored as a number, with an attribute named \"units\" and the value \"days\". This attribute shows the units of the difference. To create a time difference in other units, you can use the difftime() function and specify the units argument to the desired units. hours_diff &lt;- difftime(today, ref_date, units = &quot;hours&quot;) weeks_diff &lt;- difftime(today, ref_date, units = &quot;weeks&quot;) You can also use the as.difftime() function to help getting date. For example, to get the date of 10 weeks and 3 days from today, you can use the following code. ten_week &lt;- as.difftime(10, units = &quot;weeks&quot;) today + ten_week + 3 #&gt; [1] &quot;2025-01-04&quot; 2.16.2 Times After talking about dates, it is natural to introduce how times are represented in R. Just like dates, let’s first get the time at the current moment using the Sys.time() function. You can also check its class, internal storage type, and structure by the class(), typeof(), and str() functions. now &lt;- Sys.time() now #&gt; [1] &quot;2024-10-23 18:25:07 EDT&quot; class(now) #&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; typeof(now) #&gt; [1] &quot;double&quot; str(now) #&gt; POSIXct[1:1], format: &quot;2024-10-23 18:25:07&quot; The object now is of class POSIXct. The second element of class(now) is POSIXt, which is a parent class for class POSIXct and class PISIXlt. This parent class POSIXt is used to allow operations such as subtraction to mix the two classes. From the result of typeof(now), we know that similar to dates, the POSIXct class used to represent times is also stored as double. Indeed, the class POSIXct represents the (signed) number of seconds since the beginning of 1970 as a numeric vector. You can also get the time of an hour ago or a minute later. Now, here the difference is in the unit of seconds instead of days for the date class. now - 3600 #&gt; [1] &quot;2024-10-23 17:25:07 EDT&quot; now + 60 #&gt; [1] &quot;2024-10-23 18:26:07 EDT&quot; Besides all the elements for dates you can use for the time class object, a list of other commonly used elements of times and the corresponding conversion specifications is summarized in the following table. Code Name Example %H hours 18 %M minutes 25 %S seconds 07 %Z time zone EDT Just like dates, you can format the time into characters via the format() function. format(now, &quot;Hi! The current time in %Z (Time Zone) is %A (weekday), year %Y, month %m, day %d, hour %H, min %M, second %S. &quot;) #&gt; [1] &quot;Hi! The current time in EDT (Time Zone) is Wednesday (weekday), year 2024, month 10, day 23, hour 18, min 25, second 07. &quot; You can also display the time in a different time zone by setting the tz argument in the format() function. format(now, tz = &quot;UTC&quot;) #Coordinated Universal Time #&gt; [1] &quot;2024-10-23 22:25:07&quot; format(now, tz = &quot;America/Los_Angeles&quot;) #Pacific Standard Time #&gt; [1] &quot;2024-10-23 15:25:07&quot; format(now, tz = &quot;America/New_York&quot;) #Eastern Standard Time #&gt; [1] &quot;2024-10-23 18:25:07&quot; format(now, tz = &quot;Europe/London&quot;) #Greenwich Mean Time #&gt; [1] &quot;2024-10-23 23:25:07&quot; To create a time object from a character, you can use the as.POSIXlt() function with the optional format argument. as.POSIXct(&quot;2021-09-21 13:14:15&quot;, format = &quot;%Y-%m-%d %H:%M:%S&quot;) #&gt; [1] &quot;2021-09-21 13:14:15 EDT&quot; as.POSIXct(&quot;13:14:15, Sep 21, 2021&quot;, format = &quot;%H:%M:%S, %b %d, %Y&quot;) #&gt; [1] &quot;2021-09-21 13:14:15 EDT&quot; Similar as the difference of dates, the difference of two times is also an object of class difftime. You can again use the as.difftime() function to help with getting a time difference object in the given unit. For example, to get the time 2 days 3 hours and 4 minutes later, you can use the following. now + as.difftime(2, units = &quot;days&quot;) + as.difftime(3, units = &quot;hours&quot;) + as.difftime(4, units = &quot;mins&quot;) #&gt; [1] &quot;2024-10-25 21:29:07 EDT&quot; 2.16.3 Exercises From year 1900 to year 2021 (inclusive), calculate the number of leap years. (Hint: for a leap year, February has 29 days instead of 28. The value of as.Date(\"2010-02-29\", format = \"%Y-%m-%d\") is NA) If x &lt;- as.Date(\"69-01-01\", format = \"%y-%m-%d\") and y &lt;- as.Date(\"68-12-31\", format = \"%y-%m-%d\"), what is x - y? Please think about the answer first, then try it in R. What’s the date of the day that is 1000 days later than Feb 14, 2021. What’s the time that is 1 year, 2 days, 3 hours, 4 minutes, and 5 seconds past 8:15pm on July 4, 2021. "],["other-atomic-vector.html", "2.17 Other Atomic Vector Types", " 2.17 Other Atomic Vector Types So far, we have covered the most commonly used atomic vector types, including logical, integer, numeric, and character, when we order by complexity. In this section, we will introduce two more atomic vector types: complex vectors and raw vectors. 2.17.1 Complex Vectors Another atomic vector type in R is complex, which stores complex numbers. Let’s create a complex vector using the c() function. my_complex &lt;- c(1 + 2i, 3 + 4i, -3 - 4i) my_complex #&gt; [1] 1+2i 3+4i -3-4i class(my_complex) #&gt; [1] &quot;complex&quot; typeof(my_complex) #&gt; [1] &quot;complex&quot; str(my_complex) #&gt; cplx [1:3] 1+2i 3+4i -3-4i You can do operations on complex vectors. Like integers and doubles, the operations are performed componentwisely. Keep in mind that \\(i \\times i = -1\\). my_complex_2 &lt;- c(2 + 1i, 2i, 2 + 3i) my_complex + my_complex_2 #&gt; [1] 3+3i 3+6i -1-1i my_complex * my_complex_2 #&gt; [1] 0+ 5i -8+ 6i 6-17i my_complex / my_complex_2 #&gt; [1] 0.800000+0.600000i 2.000000-1.500000i -1.384615+0.076923i It is worth to emphasize that for complex vectors, is.numeric() returns FALSE and is.complex() returns TRUE. is.numeric(my_complex) #&gt; [1] FALSE is.complex(my_complex) #&gt; [1] TRUE For a complex vector \\(z = x + i y\\) with real \\(x\\) and \\(y\\), we have the following table for variable components along with the functions in R. Operation Explanation Values Re(z) the real part \\(x\\) Im(z) the imaginary part \\(y\\) Mod(z) the modulus \\(\\sqrt{x^2 + y^2}\\) Arg(z) the argument \\(arccos(\\frac{x}{\\sqrt{x^2 + y^2}})\\) Conj(z) the conjugate vector \\(x - i y\\) Here, the modulus and argument are also called the polar coordinates. For \\(r = Mod(z)\\), and \\(\\phi = Arg(z)\\), we have \\(x = r*\\cos(\\phi)\\) and \\(y = r*\\sin(\\phi)\\). Now, let’s try these functions on our complex vector my_complex. Re(my_complex) #&gt; [1] 1 3 -3 Im(my_complex) #&gt; [1] 2 4 -4 Mod(my_complex) #&gt; [1] 2.236068 5.000000 5.000000 Arg(my_complex) #&gt; [1] 1.1071487 0.9272952 -2.2142974 Conj(my_complex) #&gt; [1] 1-2i 3-4i -3+4i Another way to create complex vectors is to use the complex() function where you can specify two out of the four arguments, namely the real part, the imaginary part, the modulus, and the argument. Usually, we use a combination of real and imaginary, or modulus and argument. complex(real = 1:5, imaginary = 5:1) #&gt; [1] 1+5i 2+4i 3+3i 4+2i 5+1i complex(modulus = 1:5, argument = 1:5) #&gt; [1] 0.5403023+0.841471i -0.8322937+1.818595i -2.9699775+0.423360i #&gt; [4] -2.6145745-3.027210i 1.4183109-4.794621i Finally, you can use the vector(mode, length) function to create a complex vector of certain length. vector(&quot;complex&quot;, 4) #&gt; [1] 0+0i 0+0i 0+0i 0+0i Note that the default value is 0+0i. 2.17.2 Raw Vectors The raw type of vector holds raw bytes. To create a raw vector, you can use the raw() function with the desired length as its argument, which will be initialized as a zero vector. You can check the class and storage type of the created object are indeed raw. my_raw &lt;- raw(2) my_raw #&gt; [1] 00 00 class(my_raw) #&gt; [1] &quot;raw&quot; typeof(my_raw) #&gt; [1] &quot;raw&quot; Working with the raw vector type is not as easy as the other types we have covered so far. In particular, the implicit coercion doesn’t work here and leads to an error if you try to assign a number to a raw type vector. my_raw[1] &lt;- 20 #&gt; Error in my_raw[1] &lt;- 20: incompatible types (from double to raw) in subassignment type fix You may be wondering, how do we modify the values of a raw type vector? To do that, you can use the as.raw() function with an integer vector as its argument. as.raw(c(0:20, 135, 255)) #&gt; [1] 00 01 02 03 04 05 06 07 08 09 0a 0b 0c 0d 0e 0f 10 11 12 13 14 87 ff It is worth to explain the mechanism of this explicit coercion. The input integer is converted to a length-two string-like value, taking the numeric values 0-9, and the lower case letters a-f. In fact, the representation can be viewed as a Hexadecimal System, which is the numbering system with base 16. The numeric values 0-9 coincide with the corresponding numbers 0-9, while the lower case letters a-f correspond to numbers 10-15. Let’s look at a few examples. \\[\\begin{align} 0b &amp;= 0*16 + 11 = 11\\\\ 87 &amp;= 8*16 + 7 = 135\\\\ ff &amp;= 15*16 + 15 = 255 \\end{align}\\] Note that when the input is less than 0 or larger than 255, the output will be always 00 with a warning displayed. as.raw(-1) #&gt; Warning: out-of-range values treated as 0 in coercion to raw #&gt; [1] 00 as.raw(256) #&gt; Warning: out-of-range values treated as 0 in coercion to raw #&gt; [1] 00 Once you have a raw vector, you can use as.integer() to coerce it to an integer vector. In addition, you can use is.raw() to check whether the input is a raw vector. my_raw[1] &lt;- as.raw(200) as.integer(my_raw) #&gt; [1] 200 0 is.raw(my_raw) #&gt; [1] TRUE is.raw(200) #&gt; [1] FALSE Interesting, the integer values 0-255 has a correspondence with the ASCII characters. However, note that the first 32 values correspond to ASCII control characters, which are not printable. Therefore, the most useful ones are values 32-255. For more details, you can find the corresponding table of the ASCII code and the characters via https://www.ascii-code.com/. You can use the function charToRaw() to convert a string to a raw vector. And its inverse function rawToChar() will decode a raw vector into the corresponding string. This pair of operations can be viewed as an interesting example of encryption and decryption. r02pro_str &lt;- &quot;I love r02pro!&quot; r02pro_raw &lt;- charToRaw(r02pro_str) r02pro_raw #&gt; [1] 49 20 6c 6f 76 65 20 72 30 32 70 72 6f 21 rawToChar(r02pro_raw) #&gt; [1] &quot;I love r02pro!&quot; For example, the character I corresponds to raw value 49, and number 111, the space corresponds to raw value 20, and number 32, and the ! corresponds to raw value 21, and number 33. Now, let’s try something interesting. rawToChar(as.raw(32:126)) #&gt; [1] &quot; !\\&quot;#$%&amp;&#39;()*+,-./0123456789:;&lt;=&gt;?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\\\]^_`abcdefghijklmnopqrstuvwxyz{|}~&quot; You can see that the numbers, lower and upper case letters, and commonly used symbols correspond to values from 32 to 126. 2.17.3 Full Coercion Ordering In Section 2.4, we learned the following coercion rule: \\[\\mbox{logical} &lt; \\mbox{integer} &lt; \\mbox{double} &lt; \\mbox{character}\\] You may be wondering where do the complex and raw vectors lie in this sequence. Let’s first present the rule and show some examples. \\[\\mbox{raw} &lt; \\mbox{logical} &lt; \\mbox{integer} &lt; \\mbox{double} &lt; \\mbox{complex} &lt; \\mbox{character}\\] Let’s mix my_raw with logical, integer, and character values, respectively. c(my_raw, TRUE) #&gt; [1] TRUE FALSE TRUE c(my_raw, 2L) #&gt; [1] 200 0 2 c(my_raw, &quot;test&quot;) #&gt; [1] &quot;c8&quot; &quot;00&quot; &quot;test&quot; Now, let’s mix my_complex with raw, logical, integer, and character, respectively. c(my_complex, my_raw) #&gt; [1] 1+2i 3+4i -3-4i 200+0i 0+0i c(my_complex, TRUE) #&gt; [1] 1+2i 3+4i -3-4i 1+0i c(my_complex, 8L) #&gt; [1] 1+2i 3+4i -3-4i 8+0i c(my_complex, 3.14) #&gt; [1] 1.00+2i 3.00+4i -3.00-4i 3.14+0i c(my_complex, &quot;test&quot;) #&gt; [1] &quot;1+2i&quot; &quot;3+4i&quot; &quot;-3-4i&quot; &quot;test&quot; 2.17.4 Exercises Use complex vectors to verify Euler’s formula: \\[e^{iy} = \\cos(y) + i sin(y).\\] Hint: for a sequence of y values (eg. y_seq &lt;- pi *seq(from = -2, to = 2, by = 0.1)), compute the left hand side and right hand side respectively, and compare them. Tom wants to send out a message and he want to encypt it using raw vectors. He first convert the message into raw vectors, and then convert the raw vector into an integer vector. Suppose he got the following integer vector: 72, 97, 118, 101, 32, 97, 32, 110, 105, 99, 101, 32, 100, 97, 121, 33, please write R code to recover the message. Suppose we have the following vectors of different types. my_raw &lt;- as.raw(62) my_logi &lt;- TRUE my_int &lt;- 6L my_complex &lt;- 3 + 14i my_char &lt;- &quot;Good luck!&quot; Guess the values of the following operations and confirm them in R. c(c(my_raw, my_logi), my_int) c(my_raw, c(my_logi, my_int)) c(c(my_raw, my_logi), my_char) c(my_raw, c(my_logi, my_char)) c(c(my_raw, my_complex), my_char) c(my_raw, my_complex, my_char) c(c(my_raw, my_logi), c(my_int, my_complex), my_char) c(c(my_raw, my_logi), my_int, my_complex, my_char) c(my_raw, my_logi, my_int, my_complex, my_char) c(my_raw, my_logi, c(my_int, my_complex), my_char) "],["object-other-type.html", "Chapter 3 R Objects (II): Other Types", " Chapter 3 R Objects (II): Other Types In Chapter 2, we introduced atomic vectors. In a typical application, we usually need a more complex object type to represent the data. In this chapter, we will introduce a few commonly used object types including matrix in Section 3.1, array in Section 3.2, data frame in Section 3.3, tibble in Section 3.4, and list in Section 3.5. "],["matrix.html", "3.1 Matrix", " 3.1 Matrix Having mastered atomic vectors, which are an 1-dimensional objects containing elements of the same type, we now introduce another object type, called matrix, which is a rectangular array (2-dimensional) that contains elements of the same type, arranged in rows and columns. 3.1.1 Create a matrix from a vector One of most common ways to create a matrix from a vector is to use the function matrix(). In the matrix() function, the first argument is the data vector, and the following arguments of nrow and ncol represent the desired numbers of rows and columns of the matrix. matrix(data = 1:12, nrow = 3, ncol = 4) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 Note that when we supply the arguments in the default order of an R function, we can omit the argument names. As a result, the following expression generates the same matrix. matrix(1:12, 3, 4) Typically, the length of the supplied vector equals the number of rows multiplied by the number of columns. Otherwise, R will use the recycling rule we learned in Section 2.1.2 on the vector to fill in the matrix. This recycling rule is particularly useful to create matrix consisting elements of the same value. matrix(6, 3, 3) #&gt; [,1] [,2] [,3] #&gt; [1,] 6 6 6 #&gt; [2,] 6 6 6 #&gt; [3,] 6 6 6 As mentioned before, some arguments of the function could be omitted for simpler expression and cleaner coding. In this case, you can just specify nrow or ncol if the value of the other one can be implied, and still get the exact same matrices as shown below. matrix(1:12, nrow = 3) matrix(1:12, ncol = 4) Looking at the resulting matrix, you may notice that the matrix is created by filling the columns sequentially with the elements from the input vector. That is, it first fills the first column, then the second column, and so on. If you want to fill by rows instead, you can add the argument byrow = TRUE. matrix(1:12, nrow = 4, byrow = TRUE) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 2 3 #&gt; [2,] 4 5 6 #&gt; [3,] 7 8 9 #&gt; [4,] 10 11 12 After defining a matrix, we can apply various functions to it. x &lt;- matrix(1:12, nrow = 4) dim(x) #the dimension #&gt; [1] 4 3 nrow(x) #the number of rows #&gt; [1] 4 ncol(x) #the number of columns #&gt; [1] 3 t(x) #the transpose #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 2 3 4 #&gt; [2,] 5 6 7 8 #&gt; [3,] 9 10 11 12 Now, let’s check its class using class(), internal storage type using typeof(), structure using str(), and attributes using attributes(). class(x) #&gt; [1] &quot;matrix&quot; &quot;array&quot; typeof(x) #&gt; [1] &quot;integer&quot; str(x) #&gt; int [1:4, 1:3] 1 2 3 4 5 6 7 8 9 10 ... attributes(x) #&gt; $dim #&gt; [1] 4 3 We can see that x is of matrix class, and the storage type is integer. The reason is that when creating consecutive integers using the : operator, R will interpret it as integers. x has one attribute named dim with value 4 3. Attributes are very critical in determining the class as well as the structure of an R object. You can completely change the class and structure of an R object by specifying/changing its attributes. v &lt;- rep(1:3, 2) class(v) str(v) attr(v, &quot;dim&quot;) &lt;- c(2, 3) v class(v) str(v) In this example, you will convert a length-6 vector into a 2-by-3 matrix by setting the \"dim\" attributes. To set the names of a matrix, you can use rownames() and colnames() to set the row names and column names, respectively. rownames(x) &lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;) #row names colnames(x) &lt;- c(&quot;x&quot;,&quot;y&quot;,&quot;z&quot;) #column names In addition, you can use the same functions rownames() and colnames() to extract the row and column names. rownames(x) colnames(x) We can also convert a matrix to a vector, which will arrange the elements of the matrix column by column. as.vector(x) #convert matrix to a vector #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 In addition to numeric matrices, you can also create character matrices from a character vector. char_mat &lt;- matrix(letters[1:6], 2, 3) char_mat #&gt; [,1] [,2] [,3] #&gt; [1,] &quot;a&quot; &quot;c&quot; &quot;e&quot; #&gt; [2,] &quot;b&quot; &quot;d&quot; &quot;f&quot; Another way of creating matrix from a vector is to specify the desired dimensions (length-2 integer vector) to the dim() function. my_vec &lt;- 1:6 my_vec #&gt; [1] 1 2 3 4 5 6 dim(my_vec) &lt;- c(2, 3) my_vec #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 You can see here, my_vec becomes a matrix after we set its dimensions. 3.1.2 Combine vectors or matrices into a matrix To combine two vectors into a matrix, you can use the rbind() or cbind() function to stack the vectors together by row or by column, respectively. z &lt;- 1:4 w &lt;- 5:8 rbind(z, w) #&gt; [,1] [,2] [,3] [,4] #&gt; z 1 2 3 4 #&gt; w 5 6 7 8 cbind(z, w) #&gt; z w #&gt; [1,] 1 5 #&gt; [2,] 2 6 #&gt; [3,] 3 7 #&gt; [4,] 4 8 In addition to combine two vectors, you can also use rbind() and cbind() to combine two matrices. m1 &lt;- matrix(1:6, 2, 3) m2 &lt;- matrix(5:10, 2, 3) rbind(m1, m2) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 #&gt; [3,] 5 7 9 #&gt; [4,] 6 8 10 cbind(m1, m2) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] #&gt; [1,] 1 3 5 5 7 9 #&gt; [2,] 2 4 6 6 8 10 3.1.3 Matrix subsetting Like vector subsetting introduced in 2.5.2, we can do matrix subsetting as well. a. using indices to do matrix subsetting The first method for matrix subsetting is to specify the desired row indices and column indices, separated by ,. For example, we can extract the (1, 1) and (2, 3) element of x using the following codes. x[1, 1] #the element on the first row and first column #&gt; [1] 1 x[2, 3] #the element on the second row and third column #&gt; [1] 10 To get a submatrix with multiple rows and columns, you just need to supply the row and column indices separated by ,. x[1:2, 2:3] #the elements on the first &amp; second row and second &amp; third column #&gt; y z #&gt; a 5 9 #&gt; b 6 10 To keep all the rows or columns, you can leave the corresponding index location empty. x[2, ] #all elements on the second row #&gt; x y z #&gt; 2 6 10 x[, 3] #all elements on the third column #&gt; a b c d #&gt; 9 10 11 12 x[, c(2,3)] #all elements on the second and third columns #&gt; y z #&gt; a 5 9 #&gt; b 6 10 #&gt; c 7 11 #&gt; d 8 12 As you can see from the first two results, if the result is only one-dimensional, R will drop the other index and return a vector instead of a matrix. If you need to keep the result as a matrix, you can add a third “dimension”, drop = FALSE in the subsetting operation. x[2, , drop = FALSE] #&gt; x y z #&gt; b 2 6 10 x[, 3, drop = FALSE] #&gt; z #&gt; a 9 #&gt; b 10 #&gt; c 11 #&gt; d 12 Similar to vectors, you can use negative indices to get all the rows or columns except the specified one(s). x[-2, 3] #all rows except the 2nd row, the 3rd column #&gt; a c d #&gt; 9 11 12 x[-1, -c(2,3)] #all rows except the 1st row, except the 2nd and the 3rd column #&gt; b c d #&gt; 2 3 4 b. using row and column names to do matrix subsetting Just like vector subsetting for named vectors (Section 2.5.2), we can extract a submatrix using the row and columns names. x[&quot;a&quot;, &quot;z&quot;] x[c(&quot;a&quot;, &quot;c&quot;), c(&quot;x&quot;, &quot;y&quot;)] x[&quot;b&quot;,] c. using logical vectors to do matrix subsetting Similar to vector subsetting, you can also use logical vectors to do matrix subsetting. Note that different from vector subsetting, you can supply two logical vectors, one for rows and another for columns. Let’s see some examples. x[c(T, F, T, F), c(F, T, T)] x[c(F, T, F, T), ] x[, c(T, F, F)] In addition to using the logical values directly, you can also create a logical vector and use it on the fly to do matrix subsetting. Let’s say we want to keep the rows with the value on the y column that are greater than 6. To do that, you can create a logical vector x[, \"y\"] &gt; 6, then use it to subset the corresponding rows. x[, &quot;y&quot;] &gt; 6 #logical vector for the rows such that the `y` column &gt; 6 #&gt; a b c d #&gt; FALSE FALSE TRUE TRUE x[x[, &quot;y&quot;] &gt; 6, ] #extract the corresponding rows #&gt; x y z #&gt; c 3 7 11 #&gt; d 4 8 12 Similarly, if we want to keep the columns with the value on the b row less than 7. To do that, you can create a logical vector x[\"b\", ] &lt; 7, then use it to subset the corresponding columns. x[&quot;b&quot;, ] &lt; 7 #logical vector for the columns such that the `b` row &lt; 7 #&gt; x y z #&gt; TRUE TRUE FALSE x[, x[&quot;b&quot;, ] &lt; 7] #extract the corresponding columns #&gt; x y #&gt; a 1 5 #&gt; b 2 6 #&gt; c 3 7 #&gt; d 4 8 Of course, you can combine the two requirements, namely, keep the rows with the value on the y column greater than 6 and the columns with the value on the b row less than 7. x[x[, &quot;y&quot;] &gt; 6, x[&quot;b&quot;, ] &lt; 7] 3.1.4 Modify values in sub-matrices Just as modifying values on sub-vectors (Section 2.5), we can use the same technique for modifying values in sub-matrices. To avoid the changing the original matrix, we will modify the values on an copy of the original matrix. x_copy &lt;- x x_copy[1, 2] &lt;- 10 #update the (1, 2) element x_copy #&gt; x y z #&gt; a 1 10 9 #&gt; b 2 6 10 #&gt; c 3 7 11 #&gt; d 4 8 12 x_copy[1:2, 3] &lt;- c(20, 30) #update the (1:2, 3) submatrix x_copy #&gt; x y z #&gt; a 1 10 20 #&gt; b 2 6 30 #&gt; c 3 7 11 #&gt; d 4 8 12 x_copy[, 2] &lt;- 40 #update the 2nd column to 40 x_copy #&gt; x y z #&gt; a 1 40 20 #&gt; b 2 40 30 #&gt; c 3 40 11 #&gt; d 4 40 12 x_copy[c(2, 4), c(1, 3)] &lt;- 50 x_copy #&gt; x y z #&gt; a 1 40 20 #&gt; b 50 40 50 #&gt; c 3 40 11 #&gt; d 50 40 50 3.1.5 Operators and functions on matrices Now, let’s introduce some commonly used operators and functions on matrices. First of all, if you use arithmetic operators between two matrices, the specified operation will be performed elementwisely, similar to the operation between two vectors. m1 &lt;- matrix(c(2, 1, 1, 2), 2, 2) m2 &lt;- matrix(c(1, 2, 2, 1), 2, 2) m1 + m2 #&gt; [,1] [,2] #&gt; [1,] 3 3 #&gt; [2,] 3 3 m1 * m2 #&gt; [,1] [,2] #&gt; [1,] 2 2 #&gt; [2,] 2 2 m1 / m2 #&gt; [,1] [,2] #&gt; [1,] 2.0 0.5 #&gt; [2,] 0.5 2.0 You can also apply operations between a matrix and a number (a vector of length 1), where the recycling rule introduced in Section 2.1.2 will apply. m1 * 2 To perform the actual matrix multiplication, you can use the operator %*% between two matrices. m1 %*% m2 #&gt; [,1] [,2] #&gt; [1,] 4 5 #&gt; [2,] 5 4 We will next introduce some functions for creating special matrices. To create a diagonal matrix, you can use the diag() function on a vector. diag(1:5) #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 0 0 0 0 #&gt; [2,] 0 2 0 0 0 #&gt; [3,] 0 0 3 0 0 #&gt; [4,] 0 0 0 4 0 #&gt; [5,] 0 0 0 0 5 The diag() function can also be used to extract the diagonal elements of a square matrix. diag(m1) #&gt; [1] 2 2 For a squared matrix \\(A_{n\\times n} = [A_{ij}]\\), you can also calculate its determinant \\(det(A)\\) using det(A). If \\(A\\) is invertible, you can compute its inverse matrix \\(A^{-1}\\) using solve(A). det(m1) #&gt; [1] 3 solve(m1) #&gt; [,1] [,2] #&gt; [1,] 0.6666667 -0.3333333 #&gt; [2,] -0.3333333 0.6666667 m1 %*% solve(m1) ##verify we are getting the inverse of m1 #&gt; [,1] [,2] #&gt; [1,] 1 0 #&gt; [2,] 0 1 To apply a function on all elements of a matrix, you can directly use the function on the matrix object as if it is a vector. The result is equivalent to first convert the matrix into a vector using as.vector() and then apply the function on the vector. sum(x) #&gt; [1] 78 mean(x) #&gt; [1] 6.5 quantile(x, c(0.25, 0.5, 0.75)) #&gt; 25% 50% 75% #&gt; 3.75 6.50 9.25 cumsum(x) #&gt; [1] 1 3 6 10 15 21 28 36 45 55 66 78 3.1.6 Apply functions on each row or each column In many applications, we may want to apply certain function on each row or column. To do this, you can use the apply() function, which takes three arguments by default. The first argument is the matrix. The second argument is the dimension(s) to apply the function on. The third argument is the function to be applied. For example, if you want to calculate the mean and sum of each row for x, you can use apply(x, 1, mean) #calculate the mean of each row #&gt; a b c d #&gt; 5 6 7 8 rowMeans(x) #calculate the mean of each row #&gt; a b c d #&gt; 5 6 7 8 apply(x, 1, sum) #calculate the sum of each row #&gt; a b c d #&gt; 15 18 21 24 rowSums(x) #calculate the sum of each row #&gt; a b c d #&gt; 15 18 21 24 Here, 1 means the first dimension, i.e. the row. You can see that the mean for the row a is (1 + 5 + 9)/3 = 5, and the sum is 1 + 5 + 9 = 15. To get the mean and sum of each row, you can also use rowMeans() and rowSums(). To calculate the mean and sum of each column for x, you can use apply(x, 2, mean) #calculate the mean of each column #&gt; x y z #&gt; 2.5 6.5 10.5 colMeans(x) #&gt; x y z #&gt; 2.5 6.5 10.5 apply(x, 2, sum) #&gt; x y z #&gt; 10 26 42 colSums(x) #&gt; x y z #&gt; 10 26 42 Here, 2 means the second dimension, i.e. the column. You can see that the mean for the column y is (5 + 6 + 7 + 8)/4 = 6.5, and the sum is 5 + 6 + 7 + 8 = 26. In addition to the mean and sum functions, you can use any function defined on a vector. Following are some other examples. apply(x, 2, sd) #calculate the standard deviation of each column #&gt; x y z #&gt; 1.290994 1.290994 1.290994 apply(x, 1, max) #calculate the max of each row #&gt; a b c d #&gt; 9 10 11 12 In addition to the three default arguments for the apply() function, you can add more arguments that will be passed when applying the specified function, i.e. the original third argument. For example, to calculate the first quantile of each column, apply(x, 2, quantile, 0.25) #&gt; x y z #&gt; 1.75 5.75 9.75 If the function you apply returns a vector with more than one elements, the apply() function will create a higher dimensional object. Let’s see an example of calculate the cumulative sum of each row. apply(x, 1, cumsum) #calculate the cumulative sum of each row #&gt; a b c d #&gt; x 1 2 3 4 #&gt; y 6 8 10 12 #&gt; z 15 18 21 24 The mechanism of the cumsum() function is applied on each row of x and the resulting vectors are combined into a matrix. The following reproduces the results using the cbind() function on the cumulative sum results. cbind(cumsum(x[1,]), cumsum(x[2,]), cumsum(x[3,]), cumsum(x[4,])) As another example, you can use the following code to calculate the (0.25, 0.5, 0.75) quantiles for each column of x. apply(x, 2, quantile, c(0.25, 0.5, 0.75)) #&gt; x y z #&gt; 25% 1.75 5.75 9.75 #&gt; 50% 2.50 6.50 10.50 #&gt; 75% 3.25 7.25 11.25 Finally, let’s see an example of the apply() function on a character matrix. We want to combine the strings in each column of the matrix with separator _. apply(char_mat, 2, paste, collapse = &quot;_&quot;) #&gt; [1] &quot;a_b&quot; &quot;c_d&quot; &quot;e_f&quot; 3.1.7 Exercises Use R to create the following matrix #&gt; [,1] [,2] [,3] [,4] [,5] [,6] #&gt; [1,] 2 1 1 1 1 1 #&gt; [2,] 1 2 1 1 1 1 #&gt; [3,] 1 1 2 1 1 1 #&gt; [4,] 1 1 1 2 1 1 #&gt; [5,] 1 1 1 1 2 1 #&gt; [6,] 1 1 1 1 1 2 For matrix X &lt;- matrix(1:16, 4, 4) + diag(4), compute the following questions using R. Compute the column means of X. Create a matrix that contains the 0.4 and 0.7 quantiles for each row of X. Compute the cumulative sum of each row of X. What type of object is the result? And explain the result of the first column. If b &lt;- 1:4, solve a such that \\(Xa = b\\). "],["array.html", "3.2 Array", " 3.2 Array Having learned the 1-dimensional atomic vectors in Chapter 2 and 2-dimensional matrix in Section 3.1, we will now take a look in higher dimensional space, namely array. Array can be viewed as an generalization of vector and matrix to a higher dimensional (\\(&gt;=3\\)) space, and still only contains elements of the same type. 3.2.1 Create an array from a vector To create an array from a vector, you can use the function array(). Let’s see an example and use dim() to get its dimension. x &lt;- array(1:24, c(2,3,4)) x #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 7 9 11 #&gt; [2,] 8 10 12 #&gt; #&gt; , , 3 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 13 15 17 #&gt; [2,] 14 16 18 #&gt; #&gt; , , 4 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 19 21 23 #&gt; [2,] 20 22 24 dim(x) #&gt; [1] 2 3 4 You can see from the result, array has more than two dimensions. To display all elements, R will slice the array into many matrices by fixing the indices except the first two, then display one matrix at a time. As usual, we can learn more about an array by using the str(), class(), typeof(), and attributes() functions. str(x) #&gt; int [1:2, 1:3, 1:4] 1 2 3 4 5 6 7 8 9 10 ... class(x) #&gt; [1] &quot;array&quot; typeof(x) #&gt; [1] &quot;integer&quot; attributes(x) #&gt; $dim #&gt; [1] 2 3 4 We can see that x is a three-dimensional array with integers as its elements. Similarly, you can create a higher-dimensional array. The following example creates a four-dimensional array with all elements equal to 6. y &lt;- array(6, 2:5) y dim(y) 3.2.2 Array subsetting Like vector subsetting in Section 2.5.2 and matrix subsetting in Section 3.1.3, we can do array subsetting as well. To do array subsetting, you can specify the indices for each dimension separated by ,. Since x is a three-dimensional array, you can specify at most 3 indices. If you leave the indices for certain dimensions empty, everything will be kept along the corresponding dimensions. You can also use negative index to dropping specified elements. Let’s see a few examples. x[1, 2, 3] #the (1, 2, 3)-th element of x #&gt; [1] 15 x[, , 2] #the matrix where the index of the 3rd dimension equals 2 #&gt; [,1] [,2] [,3] #&gt; [1,] 7 9 11 #&gt; [2,] 8 10 12 x[2, , 4] #the vector whether the indices of the 1st and 3rd dimension equal 2 and 4. #&gt; [1] 20 22 24 x[-2, 3, -3] #&gt; [1] 5 11 23 Just like subsetting matrices, you can also use logical vectors on each dimension, as well as using names as the indices on a named array. x[x[, 1, 2] == 7,,] #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 7 13 19 #&gt; [2,] 3 9 15 21 #&gt; [3,] 5 11 17 23 3.2.3 Operators and functions on arrays Similar to vectors and matrices, arithmetic operations between arrays are performed elementwisely, with the recycling rule applying when the two arrays are of different dimensions. Let’s see the following example. array_1 &lt;- array(1:8, c(2, 2, 2)) array_2 &lt;- array(8:1, c(2, 2, 2)) array_1 + array_2 #&gt; , , 1 #&gt; #&gt; [,1] [,2] #&gt; [1,] 9 9 #&gt; [2,] 9 9 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] #&gt; [1,] 9 9 #&gt; [2,] 9 9 array_1 * array_2 #&gt; , , 1 #&gt; #&gt; [,1] [,2] #&gt; [1,] 8 18 #&gt; [2,] 14 20 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] #&gt; [1,] 20 14 #&gt; [2,] 18 8 array_1 * 3 #&gt; , , 1 #&gt; #&gt; [,1] [,2] #&gt; [1,] 3 9 #&gt; [2,] 6 12 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] #&gt; [1,] 15 21 #&gt; [2,] 18 24 To apply a function on all elements of an array, you can directly use the function on the array object as if it is a vector, as we did with a matrix. The result is equivalent to first convert the array into a vector using as.vector() and apply the function on the vector. sum(array_2) #&gt; [1] 36 mean(array_2) #&gt; [1] 4.5 quantile(array_2, c(0.25, 0.5, 0.75)) #&gt; 25% 50% 75% #&gt; 2.75 4.50 6.25 cumsum(array_2) #&gt; [1] 8 15 21 26 30 33 35 36 3.2.4 Apply functions along certain dimension(s) Just like when we work with matrices, it is of interest to apply functions not on the whole array, but along certain dimension(s). To do this, you can use the same function apply() as we did in matrices. apply(array_1, 1, mean) #calculate the mean along the first dim #&gt; [1] 4 5 mean(array_1[1, , ]) #verify the first element #&gt; [1] 4 mean(array_1[2, , ]) #verify the second element #&gt; [1] 5 apply(array_1, 2, sum) #calculate the sum along the second dim #&gt; [1] 14 22 apply(array_1, 3, sd) #calculate the sd along the third dim #&gt; [1] 1.290994 1.290994 In the second argument of apply(), in addition to specifying one dimension, you can also supply a vector of dimensions that the function will be applied upon. For example, the following code computes the sum along the first two dimensions. apply(array_1, 1:2, sum) #&gt; [,1] [,2] #&gt; [1,] 6 10 #&gt; [2,] 8 12 sum(array_1[1, 1, ]) #verify the [1, 1] element #&gt; [1] 6 sum(array_1[1, 2, ]) #verify the [1, 2] element #&gt; [1] 10 sum(array_1[2, 1, ]) #verify the [2, 1] element #&gt; [1] 8 sum(array_1[2, 2, ]) #verify the [2, 2] element #&gt; [1] 12 In addition to the three arguments, you can add additional arguments that will be passed when applying the specified function as we did in Section 3.1.6. For example, the follow code generates the 0.75 quantile along the third dimension. apply(array_1, 3, quantile, 0.75) #&gt; [1] 3.25 7.25 3.2.5 Exercises First use R to create the following array a &lt;- array(1:24, c(2, 3, 4)) Compute the mean along the second dimension of a. (Hint: the result will be a vector of length 3.) Compute the first quartile along the first and third dimension of a. (Hint: the result will be a matrix of dimension \\(2\\times 4\\)) Compute the first and third quartile along the first and third dimension of a. (Hint: the result will be an array of dimension \\((2, 2, 4)\\)) "],["dataframe.html", "3.3 Data Frame", " 3.3 Data Frame So far, we have learned atomic vectors (Chapter 2), matrices (Section 3.1), and arrays (Section 3.2). Regardless of their dimensionality, the three different object types share an important features: they all contain elements of the same type (i.e., numeric, character, or logical). In real applications, it is common to have mixed variable types. To accommodate this, let’s introduce a new two-dimensional object type: data frame. 3.3.1 Introduction to Data Frames To create a data frame, you can use the data.frame() function to combine several vectors of the same length into a single object. Let’s see an example of some health conditions of a sheep and a pig over the years 2019, 2020 and 2021. animal &lt;- rep(c(&quot;sheep&quot;, &quot;pig&quot;), c(3,3)) year &lt;- rep(2019:2021, 2) weight &lt;- c(110, 120, 140, NA, 300, 800) height &lt;- c(2.2, 2.4, 2.7, 2, 2.1, 2.3) condition &lt;- c(&quot;excellent&quot;, &quot;good&quot;, NA, &quot;excellent&quot;, &quot;good&quot;, &quot;average&quot;) condition &lt;- factor(condition, ordered = TRUE, levels = c(&quot;average&quot;, &quot;good&quot;, &quot;excellent&quot;)) healthy &lt;- c(rep(TRUE, 5), FALSE) my_data_frame &lt;- data.frame(animal, year, weight, height, condition, healthy) my_data_frame #&gt; animal year weight height condition healthy #&gt; 1 sheep 2019 110 2.2 excellent TRUE #&gt; 2 sheep 2020 120 2.4 good TRUE #&gt; 3 sheep 2021 140 2.7 &lt;NA&gt; TRUE #&gt; 4 pig 2019 NA 2.0 excellent TRUE #&gt; 5 pig 2020 300 2.1 good TRUE #&gt; 6 pig 2021 800 2.3 average FALSE Looking at the data frame my_data_frame, it has 6 columns, each of which represents one variable. The variables are of different types. The animal is factor, year is integer, both weight and height are doubles, condition is ordered factor, and healthy is logical. After creating the data frame, it is useful to examine its class using the class() function and structure using the str() function. class(my_data_frame) #&gt; [1] &quot;data.frame&quot; str(my_data_frame) #&gt; &#39;data.frame&#39;: 6 obs. of 6 variables: #&gt; $ animal : chr &quot;sheep&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; ... #&gt; $ year : int 2019 2020 2021 2019 2020 2021 #&gt; $ weight : num 110 120 140 NA 300 800 #&gt; $ height : num 2.2 2.4 2.7 2 2.1 2.3 #&gt; $ condition: Ord.factor w/ 3 levels &quot;average&quot;&lt;&quot;good&quot;&lt;..: 3 2 NA 3 2 1 #&gt; $ healthy : logi TRUE TRUE TRUE TRUE TRUE FALSE The str() tells us the data frame has 6 observations and 6 variables, along with the type and the first few values of each variable. From the output, you may be puzzled by the $ symbol before each variable name. In fact, you can easily extract a certain column corresponding to a variable with the $ following by its name. my_data_frame$animal #&gt; [1] &quot;sheep&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; &quot;pig&quot; &quot;pig&quot; my_data_frame$weight #&gt; [1] 110 120 140 NA 300 800 This kind of data representation is impossible using matrices since the coercion rule will apply, converting everything into characters. Let’s combine everything into a matrix and check its value. my_mat &lt;- cbind(animal, year, weight, height, condition, healthy) my_mat #&gt; animal year weight height condition healthy #&gt; [1,] &quot;sheep&quot; &quot;2019&quot; &quot;110&quot; &quot;2.2&quot; &quot;3&quot; &quot;TRUE&quot; #&gt; [2,] &quot;sheep&quot; &quot;2020&quot; &quot;120&quot; &quot;2.4&quot; &quot;2&quot; &quot;TRUE&quot; #&gt; [3,] &quot;sheep&quot; &quot;2021&quot; &quot;140&quot; &quot;2.7&quot; NA &quot;TRUE&quot; #&gt; [4,] &quot;pig&quot; &quot;2019&quot; NA &quot;2&quot; &quot;3&quot; &quot;TRUE&quot; #&gt; [5,] &quot;pig&quot; &quot;2020&quot; &quot;300&quot; &quot;2.1&quot; &quot;2&quot; &quot;TRUE&quot; #&gt; [6,] &quot;pig&quot; &quot;2021&quot; &quot;800&quot; &quot;2.3&quot; &quot;1&quot; &quot;FALSE&quot; In the process of creating data frames, you can also name each column. my_data_frame2 &lt;- data.frame(ani = animal, y = year, w = weight, h = height, con = condition, hea = healthy) In Section 2.8, we introduced the very useful function summary(), which returns important summary statistics for a vector. Using summary() on a data frame, you get the summary statistics for each variable. summary(my_data_frame) #&gt; animal year weight height condition #&gt; Length:6 Min. :2019 Min. :110 Min. :2.000 average :1 #&gt; Class :character 1st Qu.:2019 1st Qu.:120 1st Qu.:2.125 good :2 #&gt; Mode :character Median :2020 Median :140 Median :2.250 excellent:2 #&gt; Mean :2020 Mean :294 Mean :2.283 NA&#39;s :1 #&gt; 3rd Qu.:2021 3rd Qu.:300 3rd Qu.:2.375 #&gt; Max. :2021 Max. :800 Max. :2.700 #&gt; NA&#39;s :1 #&gt; healthy #&gt; Mode :logical #&gt; FALSE:1 #&gt; TRUE :5 #&gt; #&gt; #&gt; #&gt; From the results, you can see that depending on the variable type, you get different forms of summary. In real world, it is very common to encounter missing values, and you may want to discard the observations with them. In the object my_data_frame, there are two missing values represented by NA. To remove the observations (rows) with NA values, you can use the na.omit() on the data frame. my_df_nona &lt;- na.omit(my_data_frame) my_df_nona #&gt; animal year weight height condition healthy #&gt; 1 sheep 2019 110 2.2 excellent TRUE #&gt; 2 sheep 2020 120 2.4 good TRUE #&gt; 5 pig 2020 300 2.1 good TRUE #&gt; 6 pig 2021 800 2.3 average FALSE You can see that the 3rd and 4th row are removed since they both have a missing observation. An alternative approach to remove all rows with missing observations is to first use the complete.cases() function to get a logical vector of whether a row has missing elements, and then use data frame subsetting. complete_ind &lt;- complete.cases(my_data_frame) my_data_frame[complete_ind, ] #&gt; animal year weight height condition healthy #&gt; 1 sheep 2019 110 2.2 excellent TRUE #&gt; 2 sheep 2020 120 2.4 good TRUE #&gt; 5 pig 2020 300 2.1 good TRUE #&gt; 6 pig 2021 800 2.3 average FALSE 3.3.2 Adding Observations or Variables in Data Frames Sometimes, you may want to add additional entries to the 1st dimension (i.e., rows/observations) or the 2nd dimension (i.e., columns/variables) to an existing data frame. To add additional observations, you need to put the additional observations or variables into a new data frame, and use the rbind() function. new_obs &lt;- data.frame(animal = &quot;pig&quot;, year = 2018, weight = 200, height = 1.9, condition = &quot;excellent&quot;, healthy = TRUE) rbind(my_data_frame, new_obs) #&gt; animal year weight height condition healthy #&gt; 1 sheep 2019 110 2.2 excellent TRUE #&gt; 2 sheep 2020 120 2.4 good TRUE #&gt; 3 sheep 2021 140 2.7 &lt;NA&gt; TRUE #&gt; 4 pig 2019 NA 2.0 excellent TRUE #&gt; 5 pig 2020 300 2.1 good TRUE #&gt; 6 pig 2021 800 2.3 average FALSE #&gt; 7 pig 2018 200 1.9 excellent TRUE To add an additional variable to the existing data frame, you just need to use the $ operator to name the new variable and use the &lt;- operator to assign values to the new variable. my_data_frame$age &lt;- my_data_frame$year - 2015 my_data_frame #&gt; animal year weight height condition healthy age #&gt; 1 sheep 2019 110 2.2 excellent TRUE 4 #&gt; 2 sheep 2020 120 2.4 good TRUE 5 #&gt; 3 sheep 2021 140 2.7 &lt;NA&gt; TRUE 6 #&gt; 4 pig 2019 NA 2.0 excellent TRUE 4 #&gt; 5 pig 2020 300 2.1 good TRUE 5 #&gt; 6 pig 2021 800 2.3 average FALSE 6 3.3.3 Subsetting and Modifying Data Frames As a two-dimensional object type, subsetting and modifying data frames is very similar to the operations on matrices. a. using indices to do data frame subsetting and modifying The first method for data frame subsetting is to specify the desired row indices and column indices, separated by ,. For example, we can extract the (1, 3) and (2, 4) element of x using the following codes. my_data_frame[1, 3] #&gt; [1] 110 my_data_frame[2, 4] #&gt; [1] 2.4 To modify a specific element of x, we can assign the desired value to it. my_data_frame[1, 3] &lt;- 115 You can check the correponding value of the data frame is modified. my_data_frame Similar to a matrix subsetting, if you omit the indices of one dimension, R will keep everything along that dimension. You can also use negative indices to keep everything except the provides indices. Let’s see some examples. my_data_frame[2, ] #&gt; animal year weight height condition healthy age #&gt; 2 sheep 2020 120 2.4 good TRUE 5 my_data_frame[, 3] #&gt; [1] 115 120 140 NA 300 800 my_data_frame[3] #a single index corresponds to the columns #&gt; weight #&gt; 1 115 #&gt; 2 120 #&gt; 3 140 #&gt; 4 NA #&gt; 5 300 #&gt; 6 800 my_data_frame[c(1,3), -c(2, 3, 4)] #&gt; animal condition healthy age #&gt; 1 sheep excellent TRUE 4 #&gt; 3 sheep &lt;NA&gt; TRUE 6 Similarly, we can modify multiple values at the same time. my_data_frame[1:3, 3] &lt;- c(120, 123, 141) my_data_frame #&gt; animal year weight height condition healthy age #&gt; 1 sheep 2019 120 2.2 excellent TRUE 4 #&gt; 2 sheep 2020 123 2.4 good TRUE 5 #&gt; 3 sheep 2021 141 2.7 &lt;NA&gt; TRUE 6 #&gt; 4 pig 2019 NA 2.0 excellent TRUE 4 #&gt; 5 pig 2020 300 2.1 good TRUE 5 #&gt; 6 pig 2021 800 2.3 average FALSE 6 Note that you generally want to supply a vector with the same length as the number of elements to be modified, or the recycling rule will apply. b. using column names to do data frame subsetting and modifying Since data frames usually have column names, you can do subsetting using multiple column names. my_data_frame[1:2, c(&quot;animal&quot;, &quot;weight&quot;)] #&gt; animal weight #&gt; 1 sheep 120 #&gt; 2 sheep 123 Let’s try to modify this sub data frame. my_data_frame[1:2, c(&quot;animal&quot;, &quot;weight&quot;)] &lt;- data.frame(animal = c(&quot;monkey&quot;, &quot;bear&quot;), weight = c(110, 300)) my_data_frame #&gt; animal year weight height condition healthy age #&gt; 1 monkey 2019 110 2.2 excellent TRUE 4 #&gt; 2 bear 2020 300 2.4 good TRUE 5 #&gt; 3 sheep 2021 141 2.7 &lt;NA&gt; TRUE 6 #&gt; 4 pig 2019 NA 2.0 excellent TRUE 4 #&gt; 5 pig 2020 300 2.1 good TRUE 5 #&gt; 6 pig 2021 800 2.3 average FALSE 6 c. using logical vectors to do data frame subsetting and modifying Using logical vectors to do data frame subsetting can come in handy. Suppose we want to find the condition of the pig in year 2021. is_2021 &lt;- my_data_frame$year == 2021 is_pig &lt;- my_data_frame$animal == &quot;pig&quot; my_data_frame[is_2021 &amp; is_pig, &quot;condition&quot;] #&gt; [1] average #&gt; Levels: average &lt; good &lt; excellent Now, let’s say we want to extract all the observations with an excellent condition. my_data_frame[my_data_frame$condition == &quot;excellent&quot;, ] #&gt; animal year weight height condition healthy age #&gt; 1 monkey 2019 110 2.2 excellent TRUE 4 #&gt; NA &lt;NA&gt; NA NA NA &lt;NA&gt; NA NA #&gt; 4 pig 2019 NA 2.0 excellent TRUE 4 my_data_frame[which(my_data_frame$condition == &quot;excellent&quot;), ] #remove the NA row #&gt; animal year weight height condition healthy age #&gt; 1 monkey 2019 110 2.2 excellent TRUE 4 #&gt; 4 pig 2019 NA 2.0 excellent TRUE 4 Let’s try to modify the condition of the pig in year 2021 to “excellent”. my_data_frame[is_2021 &amp; is_pig, &quot;condition&quot;] &lt;- &quot;excellent&quot; 3.3.4 Exercises Consider the following data frame, animal &lt;- rep(c(&quot;sheep&quot;, &quot;pig&quot;), c(3,3)) weight &lt;- c(110, NA, 140, NA, 300, 800) condition &lt;- c(&quot;excellent&quot;, &quot;good&quot;, NA, &quot;excellent&quot;, &quot;good&quot;, &quot;average&quot;) healthy &lt;- c(rep(TRUE, 5), FALSE) my_data_frame &lt;- data.frame(animal, weight, condition, healthy) my_data_frame #&gt; animal weight condition healthy #&gt; 1 sheep 110 excellent TRUE #&gt; 2 sheep NA good TRUE #&gt; 3 sheep 140 &lt;NA&gt; TRUE #&gt; 4 pig NA excellent TRUE #&gt; 5 pig 300 good TRUE #&gt; 6 pig 800 average FALSE Generate a data frame with rows of my_data_frame containing complete observations. In my_data_frame, fill in the missing values in weight by the median of its non-missing values. Add the following observation to my_data_frame: animal = \"pig\", weight = 900, condition = average, and healthy = FALSE. Extract the sub-data-frame of my_data_frame that contains the columns of animal and healthy and the rows that has weight less than 400 and condition is \"good\" or \"excellent\". "],["tibble.html", "3.4 Tibble", " 3.4 Tibble Having learned data frames in Section 3.3, we would like to introduce a modern version of data frame, named tibbles. Tibbles are data frames with modifications for easier coding. To use the tibble class, you need to install the tibble package, which is part of the tidyverse package. install.packages(&quot;tibble&quot;) 3.4.1 Introduction to tibbles After installing the tibble package, you can load the package and create a tibble using the tibble() function using all vectors as its argument, a process similar to how you create a data frame. library(tibble) animal &lt;- rep(c(&quot;sheep&quot;, &quot;pig&quot;), c(3,3)) year &lt;- rep(2019:2021, 2) healthy &lt;- c(rep(TRUE, 5), FALSE) my_tibble &lt;- tibble(animal, year, healthy) my_tibble #&gt; # A tibble: 6 × 3 #&gt; animal year healthy #&gt; &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; #&gt; 1 sheep 2019 TRUE #&gt; 2 sheep 2020 TRUE #&gt; 3 sheep 2021 TRUE #&gt; 4 pig 2019 TRUE #&gt; 5 pig 2020 TRUE #&gt; 6 pig 2021 FALSE Another way to create a tibble is using the as_tibble() function on an already-created data frame. my_data_frame &lt;- data.frame(animal, year, healthy) as_tibble(my_data_frame) #&gt; # A tibble: 6 × 3 #&gt; animal year healthy #&gt; &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; #&gt; 1 sheep 2019 TRUE #&gt; 2 sheep 2020 TRUE #&gt; 3 sheep 2021 TRUE #&gt; 4 pig 2019 TRUE #&gt; 5 pig 2020 TRUE #&gt; 6 pig 2021 FALSE From the output, we can see that, under the columns’ names, their types are also shown, which is very helpful. Another useful feature of tibble compare to data frame is that when you check its value, the output only shows at most the first 10 rows and the number of columns that can fit the output window, which avoids the console to be overcrowded. x &lt;- 1:1e5 tibble(id = x, value = sin(x)) #&gt; # A tibble: 100,000 × 2 #&gt; id value #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 0.841 #&gt; 2 2 0.909 #&gt; 3 3 0.141 #&gt; 4 4 -0.757 #&gt; 5 5 -0.959 #&gt; 6 6 -0.279 #&gt; 7 7 0.657 #&gt; 8 8 0.989 #&gt; 9 9 0.412 #&gt; 10 10 -0.544 #&gt; # … with 99,990 more rows Be prepared that your console output will be flooded with numbers before running the following code. data.frame(id = x, value = sin(x)) Once we have a tibble, let’s learn its class and structure. class(my_tibble) #&gt; [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; str(my_tibble) #&gt; tibble [6 × 3] (S3: tbl_df/tbl/data.frame) #&gt; $ animal : chr [1:6] &quot;sheep&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; ... #&gt; $ year : int [1:6] 2019 2020 2021 2019 2020 2021 #&gt; $ healthy: logi [1:6] TRUE TRUE TRUE TRUE TRUE FALSE From the result, you can see that in addition to \"data.frame\", the tibble also has classes of \"tbl_df\" and \"tbl\", which contain many useful functions. We will be using tibbles extensively throughout the rest of book due to its advantages over the original data frames. For your convenience, we’ve summarized below the different variables types a tibble can include. Type Section &lt;chr&gt; character vector &lt;int&gt; integer &lt;dbl&gt; double &lt;ord&gt; ordered factor &lt;fct&gt; unordered factor &lt;lgl&gt; logical vector &lt;date&gt; dates &lt;dttm&gt; date-times Since tibble belongs to data frame, all the functions we learned for data frames including adding observations or variables, and subsetting operations can be used in the exact same format. However, the tibble class offers additional functions which makes some tasks easier. 3.4.2 Adding Observations or Variables in Tibbles In a tibble, adding observations has an easier method than that in a data frame, via the add_row() function in the tibble package. add_row(my_tibble, animal = &quot;pig&quot;, year = c(2017, 2018), healthy = TRUE) #&gt; # A tibble: 8 × 3 #&gt; animal year healthy #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; #&gt; 1 sheep 2019 TRUE #&gt; 2 sheep 2020 TRUE #&gt; 3 sheep 2021 TRUE #&gt; 4 pig 2019 TRUE #&gt; 5 pig 2020 TRUE #&gt; 6 pig 2021 FALSE #&gt; 7 pig 2017 TRUE #&gt; 8 pig 2018 TRUE From the results, we can see that multiple rows can be added at the same time by specifying the corresponding values for each variable name. Note the recycling rule applies for other variables with only one value specified. To add an additional variable, in addition to using the $ operator followed by a name as in data frames, you can also use the function add_column(). add_column(my_tibble, weight = c(110, 120, 140, NA, 300, 800), height = c(2.2, 2.4, 2.7, 2, 2.1, 2.3) ) #&gt; # A tibble: 6 × 5 #&gt; animal year healthy weight height #&gt; &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 sheep 2019 TRUE 110 2.2 #&gt; 2 sheep 2020 TRUE 120 2.4 #&gt; 3 sheep 2021 TRUE 140 2.7 #&gt; 4 pig 2019 TRUE NA 2 #&gt; 5 pig 2020 TRUE 300 2.1 #&gt; 6 pig 2021 FALSE 800 2.3 3.4.3 Tibble subsetting and modifying While the tibble subsetting and modifying is very similar to those for data frame, we would like to point out a key difference. First of all, when you use the [ and ] to do tibble subsetting, it always returns a tibble by default, even if only one column is selected. This behavior is different from subsetting data frames using [ and ]. If you are particularly interested in selecting only one column and returning it as a vector, you need to add drop = TRUE in the subsetting process. You can also subset a single row and convert it into a vector by adding the same argument. my_tibble[, 1] #6*1 tibble #&gt; # A tibble: 6 × 1 #&gt; animal #&gt; &lt;chr&gt; #&gt; 1 sheep #&gt; 2 sheep #&gt; 3 sheep #&gt; 4 pig #&gt; 5 pig #&gt; 6 pig my_data_frame[, 1] #vector #&gt; [1] &quot;sheep&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; &quot;pig&quot; &quot;pig&quot; my_tibble[, 1, drop = TRUE] #vector #&gt; [1] &quot;sheep&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; &quot;pig&quot; &quot;pig&quot; 3.4.4 Exercises Consider the following tibble, animal &lt;- rep(c(&quot;sheep&quot;, &quot;pig&quot;), c(3,3)) weight &lt;- c(110, NA, 140, NA, 300, 800) condition &lt;- c(&quot;excellent&quot;, &quot;good&quot;, NA, &quot;excellent&quot;, &quot;good&quot;, &quot;average&quot;) healthy &lt;- c(rep(TRUE, 5), FALSE) my_tibble &lt;- tibble(animal, weight, condition, healthy) my_data_frame &lt;- data.frame(animal, weight, condition, healthy) my_tibble #&gt; # A tibble: 6 × 4 #&gt; animal weight condition healthy #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;lgl&gt; #&gt; 1 sheep 110 excellent TRUE #&gt; 2 sheep NA good TRUE #&gt; 3 sheep 140 &lt;NA&gt; TRUE #&gt; 4 pig NA excellent TRUE #&gt; 5 pig 300 good TRUE #&gt; 6 pig 800 average FALSE Add the following observation to my_tibble: animal = \"pig\", weight = 900, condition = average, and healthy = FALSE. Without running in R, what do you think are the difference between my_tibble[, 1] and my_data_frame[, 1]? How can you reproduce my_data_frame[, 1] by subsetting my_tibble? "],["list.html", "3.5 List", " 3.5 List In the last two sections, we have learned data frames and tibbles whose columns can contain variables of different types. However, they are still of rectangular format, where all variables have the same number of observations. Now, let’s learn the most complex object type in R, namely, the list, which contains a sequence of variables with possibly different number of observations (elements) and even with different types. 3.5.1 Create a list To create a list, you can use the list() function with the elements separated by comma. dig_num &lt;- 1:6 ani_char &lt;- c(&quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;, &quot;pig&quot;, &quot;monkey&quot;, &quot;pig&quot;) x_mat &lt;- matrix(1:12, nrow = 3, ncol = 4) conditions &lt;- c(&quot;Excellent&quot;, &quot;Good&quot;, &quot;Average&quot;, &quot;Fair&quot;, &quot;Good&quot;, &quot;Excellent&quot;) cond_fac &lt;- factor(conditions, ordered = TRUE, levels = c(&quot;Fair&quot;, &quot;Average&quot;, &quot;Good&quot;, &quot;Excellent&quot;)) my_list &lt;- list(dig_num, ani_char, x_mat, cond_fac) my_list #&gt; [[1]] #&gt; [1] 1 2 3 4 5 6 #&gt; #&gt; [[2]] #&gt; [1] &quot;sheep&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; #&gt; #&gt; [[3]] #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 #&gt; #&gt; [[4]] #&gt; [1] Excellent Good Average Fair Good Excellent #&gt; Levels: Fair &lt; Average &lt; Good &lt; Excellent Here, we created a list named my_list, which contains four elements of different types. From the output, at the beginning of each element, its index is represented by the surrounding [[ and ]]. Usually, you want to assign a name for each element and the elements can be accessed by their names later on. my_list &lt;- list(number = dig_num, character = ani_char, matrix = x_mat, factor = cond_fac) my_list #&gt; $number #&gt; [1] 1 2 3 4 5 6 #&gt; #&gt; $character #&gt; [1] &quot;sheep&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; #&gt; #&gt; $matrix #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 #&gt; #&gt; $factor #&gt; [1] Excellent Good Average Fair Good Excellent #&gt; Levels: Fair &lt; Average &lt; Good &lt; Excellent After the elements are named, the output shows the $ followed by the name before each element. Let’s examine the class, structure, and internal storage type of my_list. class(my_list) #&gt; [1] &quot;list&quot; str(my_list) #&gt; List of 4 #&gt; $ number : int [1:6] 1 2 3 4 5 6 #&gt; $ character: chr [1:6] &quot;sheep&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; ... #&gt; $ matrix : int [1:3, 1:4] 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ factor : Ord.factor w/ 4 levels &quot;Fair&quot;&lt;&quot;Average&quot;&lt;..: 4 3 2 1 3 4 typeof(my_list) #&gt; [1] &quot;list&quot; From this example, it is clear that lists are more general than all the object types we have learned. It can contain vectors, matrices, arrays, data frames/tibbles, and even lists. In R, data frames are actually stored as lists. Indeed, they are special lists where each element is a vector (could be of different types) and each element is of the same length. Let’s create a data frame and look at its typeof(). df_ex &lt;- data.frame(dig_num, ani_char) typeof(df_ex) #&gt; [1] &quot;list&quot; length(df_ex) #&gt; [1] 2 For this reason, data frame and matrix are treated completely differently in R. Most functions on lists can be used directly on data frames. Sometimes, you may want to create a list skeleton and fill in the values at a later time. In this case, you can use the vector(mode, length) function. vector(&quot;list&quot;, length = 3) #&gt; [[1]] #&gt; NULL #&gt; #&gt; [[2]] #&gt; NULL #&gt; #&gt; [[3]] #&gt; NULL Note that the default value is NULL, which will be explained in detail in the next Section. 3.5.2 Extract a list element and list subsetting a. Extract a list element To extract a single element from a list, you can use the $ followed by the element name if the element is named, or use the index surrounded by [[ and ]]. After the elements are extracted, you can directly apply desired functions on them without the need to assign the values to another name. my_list$number #a vector #&gt; [1] 1 2 3 4 5 6 #my_list[[1]] #the first element #my_list$matrix #a matrix my_list[[3]] #the third element #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 mean(my_list$number) #&gt; [1] 3.5 rowMeans(my_list$matrix) #&gt; [1] 5.5 6.5 7.5 If you want to do list subsetting by extracting multiple elements, you can follow similar methods as subsetting a vector introduced in Section 2.5.2. b. Use indices to do list subsetting The first method is to use indices to do list subsetting. To get a sublist of the 3rd element of the original list my_list, you can use my_list[3] as below. my_list[3] #the third element of my_list #&gt; $matrix #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 It is worth to do a comparison between the results of my_list[[3]] and my_list[3]. The former is the third element of my_list which is a matrix, while the latter is a list containing a single matrix element. Let’s confirm this by looking at their structures. str(my_list[[3]]) #&gt; int [1:3, 1:4] 1 2 3 4 5 6 7 8 9 10 ... str(my_list[3]) #&gt; List of 1 #&gt; $ matrix: int [1:3, 1:4] 1 2 3 4 5 6 7 8 9 10 ... Of course, you can create a sublist containing multiple element, just like when creating subvectors using indices. my_list[c(1,3)] #the first and third elements of my_list #&gt; $number #&gt; [1] 1 2 3 4 5 6 #&gt; #&gt; $matrix #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 #my_list[-3] #all elements except the third one c. Use names to do list subsetting When the list elements are named, you can also use names around [ and ] to do list subsetting. You can also use a character vector containing the element names. my_list[&#39;number&#39;] #&gt; $number #&gt; [1] 1 2 3 4 5 6 my_list[c(&#39;number&#39;, &#39;matrix&#39;)] #&gt; $number #&gt; [1] 1 2 3 4 5 6 #&gt; #&gt; $matrix #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 3.5.3 List inside a list One interesting aspect of the list type is that you can have lists inside a list. my_big_list &lt;- list(small_list = my_list, number = dig_num) my_big_list #&gt; $small_list #&gt; $small_list$number #&gt; [1] 1 2 3 4 5 6 #&gt; #&gt; $small_list$character #&gt; [1] &quot;sheep&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; #&gt; #&gt; $small_list$matrix #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 #&gt; #&gt; $small_list$factor #&gt; [1] Excellent Good Average Fair Good Excellent #&gt; Levels: Fair &lt; Average &lt; Good &lt; Excellent #&gt; #&gt; #&gt; $number #&gt; [1] 1 2 3 4 5 6 If you want to extract ani_char from my_list, you need to use two layers of extraction operations. my_big_list$small_list$ani_char #&gt; NULL my_big_list[[1]][[2]] #&gt; [1] &quot;sheep&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; You can further put the my_big_list in another list. my_big_big_list &lt;- list(big_list = my_big_list, character = ani_char) my_big_big_list #&gt; $big_list #&gt; $big_list$small_list #&gt; $big_list$small_list$number #&gt; [1] 1 2 3 4 5 6 #&gt; #&gt; $big_list$small_list$character #&gt; [1] &quot;sheep&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; #&gt; #&gt; $big_list$small_list$matrix #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 #&gt; #&gt; $big_list$small_list$factor #&gt; [1] Excellent Good Average Fair Good Excellent #&gt; Levels: Fair &lt; Average &lt; Good &lt; Excellent #&gt; #&gt; #&gt; $big_list$number #&gt; [1] 1 2 3 4 5 6 #&gt; #&gt; #&gt; $character #&gt; [1] &quot;sheep&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; To extract dig_num from my_big_big_list, you now need three layers of extraction operations. my_big_big_list$big_list$small_list[[1]] #&gt; [1] 1 2 3 4 5 6 my_big_big_list[[1]][[1]][[1]] #&gt; [1] 1 2 3 4 5 6 #my_big_big_list[[1]]$small_list[[1]] #mix the two ways for value extraction 3.5.4 Unlist a list Sometime, you may want to unlist a list into a vector. unlist(my_list) #&gt; number1 number2 number3 number4 number5 number6 character1 #&gt; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;sheep&quot; #&gt; character2 character3 character4 character5 character6 matrix1 matrix2 #&gt; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; &quot;1&quot; &quot;2&quot; #&gt; matrix3 matrix4 matrix5 matrix6 matrix7 matrix8 matrix9 #&gt; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; #&gt; matrix10 matrix11 matrix12 factor1 factor2 factor3 factor4 #&gt; &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;4&quot; &quot;3&quot; &quot;2&quot; &quot;1&quot; #&gt; factor5 factor6 #&gt; &quot;3&quot; &quot;4&quot; c(my_list[[1]], my_list[[2]], my_list[[3]], my_list[[4]]) #reproduce the result #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;sheep&quot; &quot;pig&quot; #&gt; [9] &quot;monkey&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; #&gt; [17] &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; #&gt; [25] &quot;4&quot; &quot;3&quot; &quot;2&quot; &quot;1&quot; &quot;3&quot; &quot;4&quot; As you can tell from the result, the unlist() function works in the following steps. It visits each element of the list sequentially according to the indices, one at a time. Each element will be converted into a vector using the as.vector() function. Then converted vectors of each element will be combined into a longer vector using the c() function. During the c() operation, coercion rules will apply. The named of the final vector will the name of each element followed by the index of the corresponding value inside each list element. Here, my_list doesn’t contain an element that is also a list. When a list contains another list as one of its elements, the unlist() function will also apply the unlist operation on the element by default. In fact, the unlist operation will be applied recursively until none of the elements is a list. Please try to run the following example. unlist(my_big_big_list) If you just want to unlist a list at the first level, you can add the argument recursive = FALSE to the unlist() function. Note that the result will still be a list if the original list contains a list. You can check the result of the following code. unlist(my_big_big_list, recursive = FALSE) 3.5.5 Apply functions for each element of a list It is often useful to apply function on each element of a list. To do that, you can use the lapply() function (short for list apply). Let’s look at an example where we want to get the length of each element of my_list. lapply(my_list, length) #&gt; $number #&gt; [1] 6 #&gt; #&gt; $character #&gt; [1] 6 #&gt; #&gt; $matrix #&gt; [1] 12 #&gt; #&gt; $factor #&gt; [1] 6 You can see that the default output of lapply() is another list which is the result of the function applied on each element of the list. In this application, it might to better to use a vector to represent the result. To smplify this process, you can use the sapply() function, which is a user-friendly version and wrapper of lapply() which will return a vector or a matrix when appropriate. sapply(my_list, length) #&gt; number character matrix factor #&gt; 6 6 12 6 Let’s look at another example where we want to compute the quantiles of each element of a list. my_num_list &lt;- list(a = 1:20, b = rep(c(TRUE, FALSE), c(6,3))) sapply(my_num_list, quantile) #&gt; a b #&gt; 0% 1.00 0 #&gt; 25% 5.75 0 #&gt; 50% 10.50 1 #&gt; 75% 15.25 1 #&gt; 100% 20.00 1 3.5.6 List Matrix In Section 3.1, we know that matrices are 2-dimensional objects containing elements of the same type. A natural extension of matrix to the case where different elements can be of different types is called list matrix. Let’s create a list matrix from my_list. Since my_list has 4 elements, you can use the matrix() function to create a \\(2\\times 2\\) matrix of elements. my_list_mat &lt;- matrix(my_list, 2, 2) my_list_mat #&gt; [,1] [,2] #&gt; [1,] integer,6 integer,12 #&gt; [2,] character,6 ordered,6 To extract the elements from a list matrix, you can use the pair of [[ and ]] with the indices inside. Similar to the list subsetting, using the pair of [ and ] will result in a list of length 1. my_list_mat[[1, 2]] #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 my_list_mat[1, 2] #&gt; [[1]] #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 Similar to combining vectors into matrices in Section 3.1.2, you can also combine lists into list matrix using the rbind() or cbind() functions. l1 &lt;- list(num = 1:4, mat = matrix(1:6, 2, 3)) l2 &lt;- list(char = letters[1:5], my_list = list(num = 9:1, char = LETTERS[1:7])) list_mat_r &lt;- rbind(l1,l2) list_mat_c &lt;- cbind(l1,l2) str(list_mat_r) #&gt; List of 4 #&gt; $ : int [1:4] 1 2 3 4 #&gt; $ : chr [1:5] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; ... #&gt; $ : int [1:2, 1:3] 1 2 3 4 5 6 #&gt; $ :List of 2 #&gt; ..$ num : int [1:9] 9 8 7 6 5 4 3 2 1 #&gt; ..$ char: chr [1:7] &quot;A&quot; &quot;B&quot; &quot;C&quot; &quot;D&quot; ... #&gt; - attr(*, &quot;dim&quot;)= int [1:2] 2 2 #&gt; - attr(*, &quot;dimnames&quot;)=List of 2 #&gt; ..$ : chr [1:2] &quot;l1&quot; &quot;l2&quot; #&gt; ..$ : chr [1:2] &quot;num&quot; &quot;mat&quot; typeof(list_mat_r) #&gt; [1] &quot;list&quot; You can see from the result that list_mat_r is still stored as a list, but with the \"dim\" attributes. This relationship is very similar to that between a vector and its converted matrix. 3.5.7 Exercises Consider the following list, dig_num &lt;- 1:6 ani_char &lt;- c(&quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;, &quot;pig&quot;, &quot;monkey&quot;) x_mat &lt;- matrix(1:12, nrow = 3, ncol = 4) my_list &lt;- list(num = dig_num, char = ani_char, mat = x_mat) my_list #&gt; $num #&gt; [1] 1 2 3 4 5 6 #&gt; #&gt; $char #&gt; [1] &quot;sheep&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; &quot;monkey&quot; #&gt; #&gt; $mat #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 What’s the difference between my_list[2] and my_list[3]? What’s the difference between my_list[2:3] and my_list[[2:3]]? Using the sapply function to get the length of each element in my_list. Multiple the 3rd row of mat in my_list by 10. Then, check the new value of my_list. "],["null.html", "3.6 NULL, NaN, and Inf", " 3.6 NULL, NaN, and Inf Having learned the special missing value representation NA in Section 2.15, we will introduce three additional special values, namely the NULL, NaN, and Inf. During the process, we will talk about their relationships to NA as well. All NULL, NaN, and Inf are reserved words in R. Before introducing these three special values, let’s review the structure, internal storage type, and length of NA. It is worth recalling that NA is a length-1 logical constant that indicates a missing value. Keep in mind that NA is different from \"NA\" (a character vector). str(NA) #&gt; logi NA typeof(NA) #&gt; [1] &quot;logical&quot; length(NA) #&gt; [1] 1 3.6.1 NULL First, let’s take a look at str(), typeof() and length() of NULL. str(NULL) #&gt; NULL typeof(NULL) #&gt; [1] &quot;NULL&quot; length(NULL) #&gt; [1] 0 From the output, you’ll see that NULL is a length-0 object often returned by expressions and functions whose value is undefined. a. Undefined field of a list The first scenario of NULL is when you try to access an element of a list that is undefined. my_list &lt;- list(num = 1:3, char = c(&quot;a&quot;, &quot;b&quot;)) my_list$logi #&gt; NULL Here, the result is NULL since logi is not a defined field in my_list. b. Remove an element from a list You can remove an element from a list by assign it the NULL value. length(my_list) #&gt; [1] 2 my_list$num &lt;- NULL length(my_list) #&gt; [1] 1 my_list #&gt; $char #&gt; [1] &quot;a&quot; &quot;b&quot; As you can see from the output, the element num is removed from my_list, leading to the length of my_list being reduced by 1. c. Initialize a list of certain length The NULL value is useful to serve as the default initial value when you want to create a list of certain length using the vector() function. my_list &lt;- vector(mode = &quot;list&quot;, length = 3) my_list #&gt; [[1]] #&gt; NULL #&gt; #&gt; [[2]] #&gt; NULL #&gt; #&gt; [[3]] #&gt; NULL It is worth mentioning that the vector() function is also useful to initialize a vector of given mode and length. vector(&quot;numeric&quot;, length = 2) ##default is 0 #&gt; [1] 0 0 vector(&quot;logical&quot;, length = 2) ##default is FALSE #&gt; [1] FALSE FALSE vector(&quot;integer&quot;, length = 2) ##default is 0 #&gt; [1] 0 0 vector(&quot;character&quot;, length = 2) ##default is empty string #&gt; [1] &quot;&quot; &quot;&quot; To check if an element is NULL, you can’t use the logical comparison == NULL. Instead, you need to use the is.null() function. a &lt;- NULL a == NULL #&gt; logical(0) is.null(a) #&gt; [1] TRUE It is worth explaining the result of a == NULL is logical(0), representing a logical vector of length 0. The underlying reason is that NULL contains no value and is of length 0. As the == comparison returns a logical type object, which in turn leads to a logical vector of length 0. d. NULL values when creating a vector If you create a vector with NULL values, all NULL values will be removed if there exists at least one defined values. If all of them are NULL values, only one of them will be kept, but that vector’s length will be 0. Note that NULL is fundamentally different from NA. NA indicates that there is an underlying value, although the actual value is not available to us. c(NULL, NULL, 1, NULL) #&gt; [1] 1 c(NULL, NULL) #&gt; NULL c(NA, NA) #&gt; [1] NA NA One final point on NULL is that you can technically perform calculations on NULL. However, from the example below, you’ll realize operations on NULL will only change the class, leaving the length unchanged. d &lt;- NULL d &lt;- d + 5 str(d) # the class is changed to numeric, but the length is still 0 #&gt; num(0) 3.6.2 NaN NaN, represents Not a Number, usually appears when you divide 0 by 0, indicating the result is not well-defined. 0/0 #&gt; [1] NaN Again, it is worth to look at str(), typeof() and length() of NaN. str(NaN) #&gt; num NaN typeof(NaN) #&gt; [1] &quot;double&quot; length(NaN) #&gt; [1] 1 As you can see from the results, NaN is a numeric vector of length 1, with the value NaN. To check if a value is NaN, you cannot use the == NaN similar to checking missing values. Instead, you need to use the function is.nan(). a &lt;- NaN a == NaN ##resulting an NA value #&gt; [1] NA is.nan(a) ##the correct way to check if the value is NaN #&gt; [1] TRUE is.nan(c(NA, 1, NaN)) #&gt; [1] FALSE FALSE TRUE 3.6.3 Inf The last special symbol we want to introduce in this section is Inf, which represents positive infinity (\\(\\infty\\)), corresponding to a proper mathematical limit. Similarly, we have negative infinity, denoted as -Inf. 1/0 #&gt; [1] Inf -2/0 #&gt; [1] -Inf Inf &gt; 3 #&gt; [1] TRUE Inf &lt; -1 #&gt; [1] FALSE Inf + Inf #&gt; [1] Inf -Inf + 1e10 #&gt; [1] -Inf 1/0 - 1/0 #it equals 0/0, hencing NaN #&gt; [1] NaN Again, it is worth to look at str(), typeof() and length() of Inf. str(Inf) #&gt; num Inf typeof(Inf) #&gt; [1] &quot;double&quot; length(Inf) #&gt; [1] 1 As you can see from the results, similar to NaN, Inf is a numeric vector of length 1, but with the value Inf. To check whether a value is finite or infinite, you can use the is.finite() and is.infinite() function. is.finite(1/0) #&gt; [1] FALSE is.infinite(-3/0) #&gt; [1] TRUE 3.6.4 A comparison of the four special values in R We would like to summarize the different behaviors of the four special values in R in the following table. Summary NA NULL NaN Inf class() \"logical\" \"NULL\" \"numeric\" \"numeric\" length() 1 0 1 1 check is.na() is.null() is.nan() is.finite() 3.6.5 Exercises Suppose x &lt;- c(NA, NULL, Inf, NaN), answer the following questions. (First, try to solve without using R. Then, confirm with R code) What’s the length of x? What’s the class and the storage type of x? What’s the value of x + 1? Explain the reason for each element in the result. What’s the value of x == x? Explain the reason for each element in the result. "],["summary-r-objects.html", "3.7 Summary of R Objects", " 3.7 Summary of R Objects Through the last chapter and this one, we have covered all major types of R objects including vectors, matrices, arrays, data frames (tibbles), and lists. In this section, we would like to summarize what we have covered and highlight the main differences of the different types of objects in terms of their dimensions and the data types they can contain. Type Section Dim Data Type Vector 2 1 Single Matrix 3.1 2 Single Array 3.2 &gt;=3 Single Data Frame/Tibble 3.3 - 3.4 2 Multiple List 3.5 1 Multiple 3.7.1 Exercises This exercise will guide you through various R operations using a dataset of animals in a zoo. You will practice creating and manipulating vectors, matrices, and data frames, as well as performing basic calculations and filtering. Suppose there are 3 lions, 5 tigers, 7 birds, and 2 monkeys in the zoo. Creating Vectors Create a numeric vector named count that stores the number of each animal: lions, tigers, birds, and monkeys. Create a character vector named animal that stores the names of these animals in the same order. Combining Vectors Combine the count and animal vectors into a new vector zoo_1 &lt;- c(count, animal). What is the data type of zoo_1? Why does it has such a data type? What are the implications of this for numerical calculations? Creating a Matrix Combine the count and animal vectors into a matrix zoo_2 &lt;- cbind(count, animal). What is the data type of zoo_2? Explain why this occurs and how R handles the different data types within a matrix. Creating a Data Frame Create a data frame named zoo_df using the count and animal vectors. Ensure that the data frame has appropriate column names. Display the structure of the data frame using the str() function. What are the data types of each column? Updating the Data Frame Two birds have escaped from the zoo. Update the zoo_df data frame to decrease the bird count by 2. Verify the update by displaying the zoo_df data frame. Filtering the Data Frame Extract and display only the rows of zoo_df that correspond to lions and tigers using subsetting. Adding New Data The zoo has acquired 6 pandas. Add a new row to zoo_df for the pandas with the appropriate count and animal name. Display the updated data frame. Calculating the Total Number of Animals Calculate the total number of animals in the zoo without using the + operator. Adding a Placeholder Row The zoo manager plans to add parrots to the zoo, but he doesn’t know the exact number yet. Add a row for “parrots” with a placeholder value of NA for the count. Display the updated data frame to confirm the change. Calculating the Median Count The zoo manager decides that the number of parrots should be set to the median of the existing animal counts. Calculate the median count, excluding any NA values. Update the count for parrots in the data frame to this median value. Display the final data frame. "],["import-export.html", "Chapter 4 Data Import and Export", " Chapter 4 Data Import and Export So far in this book, you have been creating objects by yourself. When working on real projects, you often need to import existing data into R, or export the created objects or analysis results into a file on the computer. In this chapter, you will learn how to import and export data of different file types. "],["intro-dataset.html", "4.1 Introduction to Data Sets", " 4.1 Introduction to Data Sets In this section, we will introduce two datasets that will be used extensively throughout the rest of the book to illustrate necessary concepts like data import and export, visualization, data manipulation, etc. This chapter will greatly enhance your ability in working independently on your own project by integrating the knowledge and skills from the previous chapters. 4.1.1 Gapminder Data Set We will first introduce a dataset gm2004, located in the R package r02pro, the companion package of this book. The gm2004 dataset is created from the gapminder (https://www.gapminder.org/) website from a wide range of public health related topics. In particular, gm2004 contains 472 observations and 23 health related variables collected in the year 2004. Each observation (row) corresponds to a specific country, with columns representing features like mortality, health spending, and other demographic information. Let’s begin by loading the r02pro and tibble packages since gm2004 is in a tibble format. library(r02pro) library(tibble) After loading the two packages, you can type gm2004 to have a quick look of the dataset. gm2004 #&gt; # A tibble: 472 × 23 #&gt; country year gender conti…¹ region popul…² BMI liver…³ lungc…⁴ chole…⁵ #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Albania 2004 female Europe South… 3090 25.5 5.66 11 4.9 #&gt; 2 Andorra 2004 female &lt;NA&gt; &lt;NA&gt; 78.9 26.3 2.39 14.6 5.48 #&gt; 3 United Ara… 2004 female Asia Weste… 4590 29.3 4.29 17.2 5.31 #&gt; 4 Argentina 2004 female Americ… South… 38900 27.1 3.36 12.7 5.09 #&gt; 5 Armenia 2004 female Asia Weste… 2980 26.7 8.23 10.5 4.79 #&gt; 6 Australia 2004 female Oceania Austr… 20200 26.6 2.28 24 5.26 #&gt; 7 Austria 2004 female Europe Weste… 8250 25 4.12 19.4 5.32 #&gt; 8 Azerbaijan 2004 female Asia Weste… 8540 27 7.09 7.21 4.65 #&gt; 9 Belgium 2004 female Europe Weste… 10500 25.1 2.65 18.4 5.38 #&gt; 10 Burkina Fa… 2004 female Africa Weste… 13400 21.4 10.1 3.43 4.1 #&gt; # … with 462 more rows, 13 more variables: life_expectancy &lt;dbl&gt;, sugar &lt;dbl&gt;, #&gt; # health_spending &lt;dbl&gt;, GDP_per_capita &lt;dbl&gt;, HDI &lt;dbl&gt;, HDI_category &lt;chr&gt;, #&gt; # smoking &lt;dbl&gt;, food_supply &lt;dbl&gt;, owid_edu_idx &lt;dbl&gt;, #&gt; # average_daily_income &lt;dbl&gt;, income_per_person &lt;dbl&gt;, sanitation &lt;dbl&gt;, #&gt; # child_mortality &lt;dbl&gt;, and abbreviated variable names ¹​continent, #&gt; # ²​population, ³​livercancer_newcases, ⁴​lungcancer_newcases, ⁵​cholesterol You can see that gm2004 is a tibble with 472 observations and 23 variables. By default, the output only gives a compact view of the first 10 observations in the tibble along with the first few variables that can fit the window. To view the full dataset, you can use the View() function, which will open the dataset in a new window. View(gm2004) To view the first few rows of the dataset, you can use the head() function, which produces the first 6 observations by default. You can also provide an optional second argument to display any given number of observations. head(gm2004) #&gt; # A tibble: 6 × 23 #&gt; country year gender conti…¹ region popul…² BMI liver…³ lungc…⁴ chole…⁵ #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Albania 2004 female Europe South… 3090 25.5 5.66 11 4.9 #&gt; 2 Andorra 2004 female &lt;NA&gt; &lt;NA&gt; 78.9 26.3 2.39 14.6 5.48 #&gt; 3 United Arab… 2004 female Asia Weste… 4590 29.3 4.29 17.2 5.31 #&gt; 4 Argentina 2004 female Americ… South… 38900 27.1 3.36 12.7 5.09 #&gt; 5 Armenia 2004 female Asia Weste… 2980 26.7 8.23 10.5 4.79 #&gt; 6 Australia 2004 female Oceania Austr… 20200 26.6 2.28 24 5.26 #&gt; # … with 13 more variables: life_expectancy &lt;dbl&gt;, sugar &lt;dbl&gt;, #&gt; # health_spending &lt;dbl&gt;, GDP_per_capita &lt;dbl&gt;, HDI &lt;dbl&gt;, HDI_category &lt;chr&gt;, #&gt; # smoking &lt;dbl&gt;, food_supply &lt;dbl&gt;, owid_edu_idx &lt;dbl&gt;, #&gt; # average_daily_income &lt;dbl&gt;, income_per_person &lt;dbl&gt;, sanitation &lt;dbl&gt;, #&gt; # child_mortality &lt;dbl&gt;, and abbreviated variable names ¹​continent, #&gt; # ²​population, ³​livercancer_newcases, ⁴​lungcancer_newcases, ⁵​cholesterol head(gm2004, 15) #&gt; # A tibble: 15 × 23 #&gt; country year gender conti…¹ region popul…² BMI liver…³ lungc…⁴ chole…⁵ #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Albania 2004 female Europe South… 3.09e3 25.5 5.66 11 4.9 #&gt; 2 Andorra 2004 female &lt;NA&gt; &lt;NA&gt; 7.89e1 26.3 2.39 14.6 5.48 #&gt; 3 United Ara… 2004 female Asia Weste… 4.59e3 29.3 4.29 17.2 5.31 #&gt; 4 Argentina 2004 female Americ… South… 3.89e4 27.1 3.36 12.7 5.09 #&gt; 5 Armenia 2004 female Asia Weste… 2.98e3 26.7 8.23 10.5 4.79 #&gt; 6 Australia 2004 female Oceania Austr… 2.02e4 26.6 2.28 24 5.26 #&gt; 7 Austria 2004 female Europe Weste… 8.25e3 25 4.12 19.4 5.32 #&gt; 8 Azerbaijan 2004 female Asia Weste… 8.54e3 27 7.09 7.21 4.65 #&gt; 9 Belgium 2004 female Europe Weste… 1.05e4 25.1 2.65 18.4 5.38 #&gt; 10 Burkina Fa… 2004 female Africa Weste… 1.34e4 21.4 10.1 3.43 4.1 #&gt; 11 Bangladesh 2004 female Asia South… 1.39e5 20.1 1.97 2.76 4.38 #&gt; 12 Bulgaria 2004 female Europe Easte… 7.69e3 25.4 4.27 9.68 5.06 #&gt; 13 Bahrain 2004 female Asia Weste… 8.89e2 28.4 4.25 17.6 5.18 #&gt; 14 Bosnia and… 2004 female Europe South… 3.77e3 26.2 5.71 15.2 4.76 #&gt; 15 Belarus 2004 female Europe Easte… 9.56e3 26.3 1.88 5.71 5.1 #&gt; # … with 13 more variables: life_expectancy &lt;dbl&gt;, sugar &lt;dbl&gt;, #&gt; # health_spending &lt;dbl&gt;, GDP_per_capita &lt;dbl&gt;, HDI &lt;dbl&gt;, HDI_category &lt;chr&gt;, #&gt; # smoking &lt;dbl&gt;, food_supply &lt;dbl&gt;, owid_edu_idx &lt;dbl&gt;, #&gt; # average_daily_income &lt;dbl&gt;, income_per_person &lt;dbl&gt;, sanitation &lt;dbl&gt;, #&gt; # child_mortality &lt;dbl&gt;, and abbreviated variable names ¹​continent, #&gt; # ²​population, ³​livercancer_newcases, ⁴​lungcancer_newcases, ⁵​cholesterol To get a general idea on the dataset, you can use the summary() function introduced in Section 2.8.5. summary(gm2004) #&gt; country year gender continent #&gt; Length:472 Min. :2004 Length:472 Length:472 #&gt; Class :character 1st Qu.:2004 Class :character Class :character #&gt; Mode :character Median :2004 Mode :character Mode :character #&gt; Mean :2004 #&gt; 3rd Qu.:2004 #&gt; Max. :2004 #&gt; #&gt; region population BMI livercancer_newcases #&gt; Length:472 Min. : 0.8 Min. :19.80 Min. : 1.280 #&gt; Class :character 1st Qu.: 1390.0 1st Qu.:23.00 1st Qu.: 4.438 #&gt; Mode :character Median : 6770.0 Median :25.50 Median : 6.485 #&gt; Mean : 33169.4 Mean :25.21 Mean : 9.288 #&gt; 3rd Qu.: 21400.0 3rd Qu.:26.80 3rd Qu.: 9.893 #&gt; Max. :1330000.0 Max. :34.30 Max. :121.000 #&gt; NA&#39;s :78 NA&#39;s :74 NA&#39;s :84 #&gt; lungcancer_newcases cholesterol life_expectancy sugar #&gt; Min. : 1.830 Min. :3.760 Min. :43.30 Min. : 5.21 #&gt; 1st Qu.: 7.885 1st Qu.:4.420 1st Qu.:62.20 1st Qu.: 46.40 #&gt; Median : 15.200 Median :4.750 Median :71.20 Median : 84.45 #&gt; Mean : 23.282 Mean :4.747 Mean :68.82 Mean : 83.23 #&gt; 3rd Qu.: 32.625 3rd Qu.:5.090 3rd Qu.:75.60 3rd Qu.:115.00 #&gt; Max. :109.000 Max. :5.720 Max. :82.50 Max. :193.00 #&gt; NA&#39;s :64 NA&#39;s :74 NA&#39;s :82 NA&#39;s :124 #&gt; health_spending GDP_per_capita HDI HDI_category #&gt; Min. : 1.700 Min. : 0.289 Min. :0.294 Length:472 #&gt; 1st Qu.: 4.460 1st Qu.: 1.688 1st Qu.:0.512 Class :character #&gt; Median : 6.165 Median : 4.570 Median :0.689 Mode :character #&gt; Mean : 6.534 Mean : 14.063 Mean :0.659 #&gt; 3rd Qu.: 8.150 3rd Qu.: 17.825 3rd Qu.:0.791 #&gt; Max. :17.600 Max. :126.000 Max. :0.931 #&gt; NA&#39;s :92 NA&#39;s :74 NA&#39;s :102 #&gt; smoking food_supply owid_edu_idx average_daily_income #&gt; Min. : 0.300 Min. :1870 Min. : 8.67 Min. : 0.764 #&gt; 1st Qu.: 9.725 1st Qu.:2370 1st Qu.:32.00 1st Qu.: 3.890 #&gt; Median :25.450 Median :2750 Median :50.70 Median : 9.250 #&gt; Mean :24.727 Mean :2748 Mean :49.82 Mean : 17.509 #&gt; 3rd Qu.:36.000 3rd Qu.:3100 3rd Qu.:67.83 3rd Qu.: 18.850 #&gt; Max. :70.100 Max. :3830 Max. :88.70 Max. :187.000 #&gt; NA&#39;s :210 NA&#39;s :124 NA&#39;s :106 NA&#39;s :82 #&gt; income_per_person sanitation child_mortality #&gt; Min. : 779 Min. : 4.39 Min. : 2.96 #&gt; 1st Qu.: 3360 1st Qu.: 46.30 1st Qu.: 9.73 #&gt; Median : 9350 Median : 83.90 Median : 24.90 #&gt; Mean : 17217 Mean : 71.31 Mean : 45.70 #&gt; 3rd Qu.: 21850 3rd Qu.: 97.80 3rd Qu.: 73.10 #&gt; Max. :109000 Max. :100.00 Max. :204.00 #&gt; NA&#39;s :82 NA&#39;s :52 NA&#39;s :78 In the output, we get the summary statistics for each variable. For numeric variables, we get the minimum, 1st quartile, median, mean, 3rd quartile, and the maximum. It also shows the number of NA’s for a particular variable. For character variables, we only get the length of the vector, the class, and the mode. Although the types of each variable are shown in the result when typing gm2004, a more detailed list can be found with the function str(). str(gm2004) #&gt; tibble [472 × 23] (S3: tbl_df/tbl/data.frame) #&gt; $ country : chr [1:472] &quot;Albania&quot; &quot;Andorra&quot; &quot;United Arab Emirates&quot; &quot;Argentina&quot; ... #&gt; $ year : num [1:472] 2004 2004 2004 2004 2004 ... #&gt; $ gender : chr [1:472] &quot;female&quot; &quot;female&quot; &quot;female&quot; &quot;female&quot; ... #&gt; $ continent : chr [1:472] &quot;Europe&quot; NA &quot;Asia&quot; &quot;Americas&quot; ... #&gt; $ region : chr [1:472] &quot;Southern Europe&quot; NA &quot;Western Asia&quot; &quot;South America&quot; ... #&gt; $ population : num [1:472] 3090 78.9 4590 38900 2980 20200 8250 8540 10500 13400 ... #&gt; $ BMI : num [1:472] 25.5 26.3 29.3 27.1 26.7 26.6 25 27 25.1 21.4 ... #&gt; $ livercancer_newcases: num [1:472] 5.66 2.39 4.29 3.36 8.23 2.28 4.12 7.09 2.65 10.1 ... #&gt; $ lungcancer_newcases : num [1:472] 11 14.6 17.2 12.7 10.5 24 19.4 7.21 18.4 3.43 ... #&gt; $ cholesterol : num [1:472] 4.9 5.48 5.31 5.09 4.79 5.26 5.32 4.65 5.38 4.1 ... #&gt; $ life_expectancy : num [1:472] 76.2 81.4 69.2 75.3 73 81.2 79.8 67.3 79.3 55.3 ... #&gt; $ sugar : num [1:472] 58.6 NA 110 136 94.1 128 136 48.8 146 16.6 ... #&gt; $ health_spending : num [1:472] 6.84 7.22 2.32 8.45 4.86 8.43 10.3 7.8 10 6.69 ... #&gt; $ GDP_per_capita : num [1:472] 2.68 39.8 53.9 11.2 2.36 50.3 41.3 2.67 38.4 0.518 ... #&gt; $ HDI : num [1:472] 0.706 0.827 0.809 0.788 0.712 0.906 0.863 0.674 0.897 0.332 ... #&gt; $ HDI_category : chr [1:472] &quot;high&quot; &quot;very high&quot; &quot;very high&quot; &quot;high&quot; ... #&gt; $ smoking : num [1:472] 4 29.2 2.6 25.4 3.7 21.8 40.1 0.9 24.1 11.2 ... #&gt; $ food_supply : num [1:472] 2870 NA 3210 3110 2670 3100 3640 2840 3720 2460 ... #&gt; $ owid_edu_idx : num [1:472] 60.7 65.3 60.7 60.7 72.7 78 66 71.3 71.3 8.67 ... #&gt; $ average_daily_income: num [1:472] 7.7 49.3 187 15.6 6.34 46.8 49.9 10.7 47.2 2.4 ... #&gt; $ income_per_person : Named num [1:472] 8040 45000 80800 19400 7420 42200 49400 7110 46300 1530 ... #&gt; ..- attr(*, &quot;names&quot;)= chr [1:472] NA &quot;k&quot; &quot;k&quot; &quot;k&quot; ... #&gt; $ sanitation : num [1:472] 92.3 100 97.4 89.9 88.9 100 100 72.3 99.5 14.2 ... #&gt; $ child_mortality : num [1:472] 19.2 5.27 9.73 16.5 23.9 5.72 4.9 52.5 4.94 153 ... The str() function lists out all variables in the dataset with their corresponding type, length, and each variable’s first several values. 4.1.2 Small Ames Housing Price Data Set Next, we will introduce the sahp dataset, which is part of the Ames Housing Price data. For your convenience, we have also included sahp in the R package r02pro. Similarly, you can type sahp to have a quick look of the dataset. sahp #&gt; # A tibble: 165 × 12 #&gt; dt_sold bedroom bathroom gar_car oa_qual liv_area lot_area house…¹ kit_q…² #&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 2010-03-25 3 2.5 2 6 1479 13517 2Story Good #&gt; 2 2009-04-10 4 3.5 2 7 2122 11492 2Story Good #&gt; 3 2010-01-15 3 2 1 5 1057 7922 1Story Good #&gt; 4 2010-04-19 3 2.5 2 5 1444 9802 2Story Average #&gt; 5 2010-03-22 3 2 2 6 1445 14235 1.5Fin Average #&gt; 6 2010-06-06 2 2.5 2 6 1888 16492 1Story Good #&gt; 7 2006-06-14 2 3 2 6 1072 3675 SFoyer Average #&gt; 8 2010-05-08 3 2 2 5 1188 12160 1Story Average #&gt; 9 2007-06-14 2 1 1 5 924 15783 1Story Average #&gt; 10 2007-09-01 5 2.5 2 5 2080 11606 2Story Fair #&gt; # … with 155 more rows, 3 more variables: heat_qual &lt;chr&gt;, central_air &lt;chr&gt;, #&gt; # sale_price &lt;dbl&gt;, and abbreviated variable names ¹​house_style, ²​kit_qual You can see that sahp is a tibble with 165 observations and 12 housing variables, including the sale date, price, and other property quality measurements. Let’s again use the summary() function on the dataset. summary(sahp) #&gt; dt_sold bedroom bathroom gar_car #&gt; Min. :2006-01-11 Min. :0.000 Min. :1.000 Min. :0.000 #&gt; 1st Qu.:2007-02-27 1st Qu.:2.000 1st Qu.:1.500 1st Qu.:1.000 #&gt; Median :2008-04-09 Median :3.000 Median :2.000 Median :2.000 #&gt; Mean :2008-04-13 Mean :2.764 Mean :2.197 Mean :1.774 #&gt; 3rd Qu.:2009-06-03 3rd Qu.:3.000 3rd Qu.:2.500 3rd Qu.:2.000 #&gt; Max. :2010-07-24 Max. :5.000 Max. :4.500 Max. :4.000 #&gt; NA&#39;s :1 #&gt; oa_qual liv_area lot_area house_style #&gt; Min. : 2.000 Min. : 438 Min. : 1533 Length:165 #&gt; 1st Qu.: 5.000 1st Qu.:1116 1st Qu.: 7288 Class :character #&gt; Median : 6.000 Median :1450 Median : 9260 Mode :character #&gt; Mean : 6.128 Mean :1481 Mean : 9832 #&gt; 3rd Qu.: 7.000 3rd Qu.:1707 3rd Qu.:11645 #&gt; Max. :10.000 Max. :3390 Max. :39384 #&gt; NA&#39;s :1 #&gt; kit_qual heat_qual central_air sale_price #&gt; Length:165 Length:165 Length:165 Min. : 44.0 #&gt; Class :character Class :character Class :character 1st Qu.:130.0 #&gt; Mode :character Mode :character Mode :character Median :157.9 #&gt; Mean :179.9 #&gt; 3rd Qu.:201.6 #&gt; Max. :545.2 #&gt; NA&#39;s :1 Again, we can use the str() function to a detailed list of each variable along with its type. str(sahp) #&gt; tibble [165 × 12] (S3: tbl_df/tbl/data.frame) #&gt; $ dt_sold : Date[1:165], format: &quot;2010-03-25&quot; &quot;2009-04-10&quot; ... #&gt; $ bedroom : num [1:165] 3 4 3 3 3 2 2 3 2 5 ... #&gt; $ bathroom : num [1:165] 2.5 3.5 2 2.5 2 2.5 3 2 1 2.5 ... #&gt; $ gar_car : num [1:165] 2 2 1 2 2 2 2 2 1 2 ... #&gt; $ oa_qual : num [1:165] 6 7 5 5 6 6 6 5 5 5 ... #&gt; $ liv_area : num [1:165] 1479 2122 1057 1444 1445 ... #&gt; $ lot_area : num [1:165] 13517 11492 7922 9802 14235 ... #&gt; $ house_style: chr [1:165] &quot;2Story&quot; &quot;2Story&quot; &quot;1Story&quot; &quot;2Story&quot; ... #&gt; $ kit_qual : chr [1:165] &quot;Good&quot; &quot;Good&quot; &quot;Good&quot; &quot;Average&quot; ... #&gt; $ heat_qual : chr [1:165] &quot;Excellent&quot; &quot;Excellent&quot; &quot;Average&quot; &quot;Good&quot; ... #&gt; $ central_air: chr [1:165] &quot;Y&quot; &quot;Y&quot; &quot;Y&quot; &quot;Y&quot; ... #&gt; $ sale_price : num [1:165] 130 NA 109 174 138 ... Now, let’s try to answer a few questions using the sahp dataset. 4.1.2.1 Sample Analysis: are two-story houses more expensive than one-story ones? Let’s try to answer this question by doing some analysis. First, let’s create the logical vectors corresponding to two-story and one-story houses. story_2 &lt;- sahp$house_style == &quot;2Story&quot; story_1 &lt;- sahp$house_style == &quot;1Story&quot; Then, we create two vectors containing the prices of the two groups, respectively. sale_price_2 &lt;- sahp$sale_price[story_2] sale_price_1 &lt;- sahp$sale_price[story_1] Finally, we can run the summary() function on both vectors. summary(sale_price_2) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s #&gt; 55.0 137.9 174.0 197.8 231.5 545.2 1 summary(sale_price_1) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 44.0 129.0 160.0 183.0 224.2 465.0 The results from the summary() function clearly represent that the corresponding statistics are larger for two-story houses compared to one-story ones, for all 6 measures. As a result, we can conclude that the two-story houses indeed have higher sale prices than the one-story ones. 4.1.3 Converting Data Types When you import a dataset into R, some variables may not have the desired types. In this case, it would be useful to convert them into the types you want before conducting further data analyses. a. Converting a character vector to an unordered factor Let’s look at the variable house_style in sahp. We can see from the output of str(sahp) that it is of chr type. Let’s check it and confirm the structure with summary(). is.character(sahp$house_style) #&gt; [1] TRUE summary(sahp$house_style) #&gt; Length Class Mode #&gt; 165 character character As briefly mentioned before, using the summary() function on a character vector doesn’t provide us much useful information. Let’s find the unique values of this vector and get the frequency table. unique(sahp$house_style) #&gt; [1] &quot;2Story&quot; &quot;1Story&quot; &quot;1.5Fin&quot; &quot;SFoyer&quot; &quot;SLvl&quot; table(sahp$house_style) #&gt; #&gt; 1.5Fin 1Story 2Story SFoyer SLvl #&gt; 21 81 50 5 8 We can see that there are five house styles along with their frequencies. It turns out to be particularly useful to convert this type of variable into a factor type. Let’s use the function factor() to proceed the conversion and as.factor() to ensure the conversion is successfully completed. house_style_factor &lt;- factor(sahp$house_style) is.factor(house_style_factor) #&gt; [1] TRUE summary(house_style_factor) #&gt; 1.5Fin 1Story 2Story SFoyer SLvl #&gt; 21 81 50 5 8 Instead of calling table() to see the frequencies, we can obtain them by calling just summary(). b. Converting a character vector to an ordered factor Now, let’s take a look at another variable called kit_qual, measuring the kitchen quality. Again, let’s check the unique values. unique(sahp$kit_qual) #&gt; [1] &quot;Good&quot; &quot;Average&quot; &quot;Fair&quot; &quot;Excellent&quot; In addition to having four different quality values, they have an internal ordering among them. In particular, we know Fair &lt; Average &lt; Good &lt; Excellent. To reflect this intrinsic order, you can convert this variable into an ordered factor using the same factor() function, setting ordered = TRUE and specifying the levels in the ascending order of the desired ordering. kit_qual_ordered_factor &lt;- factor(sahp$kit_qual, ordered = TRUE, levels = c(&quot;Fair&quot;, &quot;Average&quot;, &quot;Good&quot;, &quot;Excellent&quot;)) #covert to ordered factor summary(kit_qual_ordered_factor) #&gt; Fair Average Good Excellent #&gt; 9 85 57 14 str(kit_qual_ordered_factor) #&gt; Ord.factor w/ 4 levels &quot;Fair&quot;&lt;&quot;Average&quot;&lt;..: 3 3 3 2 2 3 2 2 2 1 ... c. Converting a character vector to a logical vector Lastly, let’s look at the variable central_air, representing a house’s AC condition. As before, let’s get the unique elements. unique(sahp$central_air) #&gt; [1] &quot;Y&quot; &quot;N&quot; Intuitively, you can create a logical vector representing whether the house has central AC or not. central_air_logi &lt;- sahp$central_air == &quot;Y&quot; summary(central_air_logi) #&gt; Mode FALSE TRUE #&gt; logical 16 149 str(central_air_logi) #&gt; logi [1:165] TRUE TRUE TRUE TRUE TRUE TRUE ... Another scenario would be creating an additional variable from the existing ones. For example, we know the overall quality (oa_qual) of the house ranges from 2 to 10. table(sahp$oa_qual) #&gt; #&gt; 2 3 4 5 6 7 8 9 10 #&gt; 2 1 10 47 44 31 21 6 2 If we want to crate a new variable representing houses of good quality with a oa_qual greater than 5, this can be achieved by creating a new logical variable named good_qual as shown below. good_qual &lt;- sahp$oa_qual &gt; 5 summary(good_qual) #&gt; Mode FALSE TRUE NA&#39;s #&gt; logical 60 104 1 str(good_qual) #&gt; logi [1:165] TRUE TRUE FALSE FALSE TRUE TRUE ... 4.1.4 Recover Modified Values When you are working with a dataset provided by a package, you may accidentally modify some values in the original dataset. In this situation, there’s no need to panic, as this mistake can be easily recovered by setting the data into its “factory” setting (i.e. the original version inside the package). To do this, you just need to use the data() function with the dataset name as its argument. Let’s try to modify one value of sahp and recover the data set afterward. However, it is strongly recommended to develop the habit of saving an independent copy of dataset under a different object name, especially with those provided by a loaded package. We encourage you to label your code with necessary, clear comments along with this process. It is a good habit that can greatly enhance your efficiency of coding while avoiding unnecessary errors. sahp[1,2] #get the original value #&gt; # A tibble: 1 × 1 #&gt; bedroom #&gt; &lt;dbl&gt; #&gt; 1 3 sahp[1,2] &lt;- 5 #modify the value sahp[1,2] #verify the modified value #&gt; # A tibble: 1 × 1 #&gt; bedroom #&gt; &lt;dbl&gt; #&gt; 1 5 data(sahp) #recover the data sahp[1,2] #verify the value is recovered #&gt; # A tibble: 1 × 1 #&gt; bedroom #&gt; &lt;dbl&gt; #&gt; 1 3 "],["export-data.html", "4.2 Exporting Data to Delimited Files", " 4.2 Exporting Data to Delimited Files 4.2.1 Set the working directory First, we will introduce an important concept called Working Directory. In order to perform data export and data import, you are recommended to set the working directory, since we usually use a path relative to the working directory for interacting with files on the computer in R. To set the working directory, you can click Session on the menu and click Set Working Directory. Figure 4.1: Set Working Directory There are three options under this menu: To Source File Location: this will set the working directory as the directory of the current R script. To Files Pane Location: this will set the working directory as the directory of the Files Pane on the bottom right of RStudio. Choose Directory…: this will open up a window from which you can choose any desired directory. Keep in mind that if you choose to work under a RStudio project, you might notice an additional choice under the Set Working Directory tab: To Project Directory: this will set the working directory as the directory of your current RStudio project. After selecting one of these options, we can see a line of code containing the function setwd() executed in the console. Indeed, this menu operation is equivalent to using the setwd() function with the argument being the full path or relative path of the desired directory. Another related function is getwd(), which tells us the absolute path representing the current working directory. When you see an error message saying that a file is not found, it is a good idea to check the current working directory and check whether it is correct. getwd() For illustration purposes, we will create a folder called “data” using the function dir.create() under the current working directory and export/import to/from files in this folder. dir.create(&quot;data&quot;) 4.2.2 Delimited files In most applications, you will interact with the so-called delimited file. In a delimited file, each row represents a single observation, and it has values separated by the delimiter. In principle, any character (including letters, numbers, or symbols) can be used as a delimiter, with the most commonly used ones being the follow. Delimiter Symbol Common File Extension comma , .csv space .txt tab \\t .tsv 4.2.3 Write an object into a .csv file First, let’s work with one popular kind of delimited files called comma-separated value file, usually with the file extension .csv. In a .csv file, the delimiter is comma (,). Let’s work with the gm2004 dataset and export a part of it (first five rows and first four columns) to a .csv file. library(r02pro) gm_small &lt;- gm2004[1:5, 1:4] gm_small #&gt; # A tibble: 5 × 4 #&gt; country year gender continent #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Albania 2004 female Europe #&gt; 2 Andorra 2004 female &lt;NA&gt; #&gt; 3 United Arab Emirates 2004 female Asia #&gt; 4 Argentina 2004 female Americas #&gt; 5 Armenia 2004 female Asia Now, let’s write the data frame gm_small into a file called “gm_small.csv” in the currently working directory. To write an object into a .csv file, you can use the write_csv() function in the readr package. Since readr is a sub-package of tidyverse, you can load the package directly if the tidyverse package is installed. library(readr) write_csv(gm_small, &quot;data/gm_small.csv&quot;) Note here, we are writing the tibble gm_small into a file named “gm_small.csv” in the folder “data”. “data/gm_small.csv” is an example of relative file path. You can also use the absolute file path on your computer, though it is not as collaboration friendly as the relative path, since your collaborator may have a different file structure from yours. You can verify the .csv file has been indeed created and open the file with RStudio or any text editor to verify its contents. Figure 4.2: File Contents We can see that all the information has been exported to the .csv file, with commas separating the values on each observation. In particular, you may find out the first row of the file corresponds to the column names. If you don’t want to include the column names, you can set the argument col_names = FALSE. write_csv(gm_small, &quot;data/gm_small_no_colname.csv&quot;, col_names = FALSE) By default, write_csv() writes the data into a file in which NA is used to represent all the missing values, just like in a tibble. If you want to use another string to represent the missing values in the file, you can set the argument na to be the string. write_csv(gm_small, &quot;data/gm_small_missing.csv&quot;, na = &quot;This value is missing!&quot;) 4.2.4 Write an object into a general delimited file As introduced at the beginning, there are different types of delimited files, depending on the specific delimiter of your choice. The function write_delim() enables us to write an object into a delimited file with any chosen delimiter. The usage of write_delim() is almost identical to write_csv(), except that it has an additional argument delim, which specifies the delimiter to be used. Let’s see the following example with * as the delimiter. write_delim(gm_small, &quot;data/gm_small_star.csv&quot;, delim = &quot;*&quot;) 4.2.5 Exercises Use R to create the following data frame and assign it to the name my_data. #&gt; word number letter #&gt; 1 one 1 a #&gt; 2 two NA b #&gt; 3 &lt;NA&gt; 3 c #&gt; 4 four 4 d #&gt; 5 five 5 e First set working directory to the location of your .R or .Rmd file, then write R code to first create a directory called my_data, and export my_data into a .csv file named “my_data_no_name.csv” without column names into this newly created directory. Write R code to export my_data into a delimited file called “my_data_na.csv” to the same directory created in Q1 with # as the delimiter and use 999 as the indicator for missing values. "],["import-data.html", "4.3 Importing Data from Delimited Files", " 4.3 Importing Data from Delimited Files Knowing how to export data into delimited files, let us now see how to import data from delimited files. 4.3.1 Import .csv Files using read_csv() To import .csv files, we can use the function read_csv() in the readr package, which is a sub-package of tidyverse. If you have already installed tidyverse, you can directly load the readr package. After loading the readr package, you can try to import the data from “gm_small.csv” which we created in Section 4.2.3. Please make sure the .csv file is located in the folder “data” relative to the current working directory. Otherwise, you need to change the working directory accordingly using the methods introduced in Section 4.2.1. library(readr) gm_small &lt;- read_csv(&quot;data/gm_small.csv&quot;) #&gt; Rows: 5 Columns: 4 #&gt; ── Column specification ──────────── #&gt; Delimiter: &quot;,&quot; #&gt; chr (3): country, gender, continent #&gt; dbl (1): year #&gt; #&gt; ℹ Use `spec()` to retrieve the full column specification for this data. #&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. We can see that there is a message showing the Column specification during the import process. In particular, we see country is of type character, and both year and HDI are of type double. We can also check the value of gm_small and its structure. gm_small #&gt; # A tibble: 5 × 4 #&gt; country year gender continent #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Albania 2004 female Europe #&gt; 2 Andorra 2004 female &lt;NA&gt; #&gt; 3 United Arab Emirates 2004 female Asia #&gt; 4 Argentina 2004 female Americas #&gt; 5 Armenia 2004 female Asia str(gm_small) #&gt; spc_tbl_ [5 × 4] (S3: spec_tbl_df/tbl_df/tbl/data.frame) #&gt; $ country : chr [1:5] &quot;Albania&quot; &quot;Andorra&quot; &quot;United Arab Emirates&quot; &quot;Argentina&quot; ... #&gt; $ year : num [1:5] 2004 2004 2004 2004 2004 #&gt; $ gender : chr [1:5] &quot;female&quot; &quot;female&quot; &quot;female&quot; &quot;female&quot; ... #&gt; $ continent: chr [1:5] &quot;Europe&quot; NA &quot;Asia&quot; &quot;Americas&quot; ... #&gt; - attr(*, &quot;spec&quot;)= #&gt; .. cols( #&gt; .. country = col_character(), #&gt; .. year = col_double(), #&gt; .. gender = col_character(), #&gt; .. continent = col_character() #&gt; .. ) #&gt; - attr(*, &quot;problems&quot;)=&lt;externalptr&gt; We can see that the tibble gm_small is generated along with the correct column types. In order to introduce the various options associated with read_csv() function, let’s move on to the topic of inline .csv files next. 4.3.2 Read Inline .csv Files The read_csv() function not only can read files into R, it also accept inline input as its argument. While the inline input may not be commonly used in practice, it is particularly useful for learning how to use the function, and be able to handle various importing cases when dealing with real life datasets. Let’s see an example. read_csv(&quot;x,y,z 1,3,5 2,4,6&quot;) #&gt; Rows: 2 Columns: 3 #&gt; ── Column specification ──────────── #&gt; Delimiter: &quot;,&quot; #&gt; dbl (3): x, y, z #&gt; #&gt; ℹ Use `spec()` to retrieve the full column specification for this data. #&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. #&gt; # A tibble: 2 × 3 #&gt; x y z #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 3 5 #&gt; 2 2 4 6 This inline input example is equivalent to reading a .csv file with contents identical to those in quotes. You can see that a tibble with size of 2 by 3 is generated with the column names being x, y and z. From the argument, we can see that by default, the first row of the input data will be interpreted as the column names. a. No column names If the first row of the input data doesn’t correspond to the variable names, you need to set col_names = FALSE as an additional argument in read_csv(). read_csv(&quot;x,y,z 1,3,5 2,4,6&quot;, col_names = FALSE) #&gt; Rows: 3 Columns: 3 #&gt; ── Column specification ──────────── #&gt; Delimiter: &quot;,&quot; #&gt; chr (3): X1, X2, X3 #&gt; #&gt; ℹ Use `spec()` to retrieve the full column specification for this data. #&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. #&gt; # A tibble: 3 × 3 #&gt; X1 X2 X3 #&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 x y z #&gt; 2 1 3 5 #&gt; 3 2 4 6 Now, a tibble of 3 rows and 3 columns was generated, with the column names being X1, X2, and X3. Note that these are the default naming conventions in the function when you don’t supply the column names in the file. Another thing worth mentioning is that all three variables are of character types, due to the fact that there are character values for all variables (“x”, “y”, and “z”). b. Skip the first few lines Sometimes, the first few lines of your data file may be descriptions of the data, which you want to skip when importing into R. We can set the skip argument in the read_csv() function to skip a certain number of lines. read_csv(&quot;The first line The second line The third line x,y,z 1,3,5&quot;, skip = 3) #&gt; Rows: 1 Columns: 3 #&gt; ── Column specification ──────────── #&gt; Delimiter: &quot;,&quot; #&gt; dbl (3): x, y, z #&gt; #&gt; ℹ Use `spec()` to retrieve the full column specification for this data. #&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. #&gt; # A tibble: 1 × 3 #&gt; x y z #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 3 5 It is clear from the result that the first 3 lines of the input data are skipped. c. Skip the comments Another useful argument in cases when we have comments in the data file is the comment argument, which tells R to skip all text after the string specified in the comment argument. read_csv(&quot;x,y,z #variable names 1,3,5 #the first observation 2,4,6 #the second observation&quot;, comment = &quot;#&quot;) #&gt; Rows: 2 Columns: 3 #&gt; ── Column specification ──────────── #&gt; Delimiter: &quot;,&quot; #&gt; dbl (3): x, y, z #&gt; #&gt; ℹ Use `spec()` to retrieve the full column specification for this data. #&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. #&gt; # A tibble: 2 × 3 #&gt; x y z #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 1 3 5 #&gt; 2 2 4 6 4.3.3 Handling Missing Values In many real data sets, we may have missing values. You may recall that R uses NA to represent the missing values. If the data set was prepared by an R user, it probably already uses NA to represent all missing values. In this case, life is easy since read_csv() will automatically interpret all NAs as missing values. read_csv(&quot;x,y,z 999,3,5 NA,-999,6&quot;) #&gt; Rows: 2 Columns: 3 #&gt; ── Column specification ──────────── #&gt; Delimiter: &quot;,&quot; #&gt; dbl (3): x, y, z #&gt; #&gt; ℹ Use `spec()` to retrieve the full column specification for this data. #&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. #&gt; # A tibble: 2 × 3 #&gt; x y z #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 999 3 5 #&gt; 2 NA -999 6 In a typical application, however, the person who prepared the data may use other strings to represent missing values. For example, if 999 and -999 are used as the indicators for missing values, you can set the argument na to be the vector containing those values. Note that NA will still be interpreted as missing values automatically. read_csv(&quot;x,y,z 999,3, yes NA,-999, no 12, 12, NA&quot;, na = c(&quot;999&quot;,&quot;-999&quot;)) #&gt; Rows: 3 Columns: 3 #&gt; ── Column specification ──────────── #&gt; Delimiter: &quot;,&quot; #&gt; chr (2): x, z #&gt; dbl (1): y #&gt; #&gt; ℹ Use `spec()` to retrieve the full column specification for this data. #&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. #&gt; # A tibble: 3 × 3 #&gt; x y z #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 &lt;NA&gt; 3 yes #&gt; 2 NA NA no #&gt; 3 12 12 NA You can see from the output tibble that all the missing values are now denoted as NA. ::: {.infobox .caution data-latex=“{caution}”} Note that the quotation marks around 999 and -999 are necessary since the na argument is expecting a character vector. read_csv(&quot;x,y,z 999,3,5 999,-999,6&quot;, na = c(999,-999)) #&gt; Error in enc2utf8(na): argument is not a character vector You can see an error message, stating that it is expecting character values, but got double values. 4.3.4 Importing Data From a Delimited File You now know how to import data from a .csv file using the read_csv() function. More generally, read_delim() allows us to import data from a delimited file with any chosen delimiter. The usage of read_delim() is almost identical to read_csv(), except that it has an additional argument delim, which specifies the delimiter to be used. Let’s see the following example with * as the delimiter. Note that we are using the “my_animals_star.csv” file generated in Section 4.2.4. my_animals &lt;- read_delim(&quot;data/gm_small_star.csv&quot;, delim = &quot;*&quot;) Let’s try to use read_csv() instead to check what will you get. read_csv(&quot;data/gm_small_star.csv&quot;) #&gt; Rows: 5 Columns: 1 #&gt; ── Column specification ──────────── #&gt; Delimiter: &quot;,&quot; #&gt; chr (1): country*year*gender*continent #&gt; #&gt; ℹ Use `spec()` to retrieve the full column specification for this data. #&gt; ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. #&gt; # A tibble: 5 × 1 #&gt; `country*year*gender*continent` #&gt; &lt;chr&gt; #&gt; 1 Albania*2004*female*Europe #&gt; 2 Andorra*2004*female*NA #&gt; 3 United Arab Emirates*2004*female*Asia #&gt; 4 Argentina*2004*female*Americas #&gt; 5 Armenia*2004*female*Asia You will see that the imported data has only one variable named country*year*HDI since the function will interpret the whole thing as a single variable. 4.3.5 Import Data Using the Menu Besides writing codes involving read_csv() or read_delim() to import data, you can also take advantage of the interactive menu RStudio provides. To do this, you can click on the Import Dataset button in the Environment panel on the top right of RStudio shown in the following figure. Figure 4.3: Import Dataset Menu Here, you can see quite a few options which are summarized in the following table. Table 4.1: Import Data from Menu Choice Name From Text (readr) Delimited Files (.csv, .txt, and others) From Excel Excel Files (.xls and .xlsx) From SPSS SPSS Files (.sav) From SAS SAS Files (.sas7bdat and.sas7bcat) From Stata Stata Files (.dta) We have been focusing on importing delimited files in this section. We will cover importing Excel files in Section 4.4. Working with SPSS, SAS, and Stata files will be covered in Section 4.5. For importing a .csv file, .txt file, or any other file with a delimiter, you can choose the From Text (readr) option. Then, you can click Browse… and select the data file. We will select the “gm_small_star.csv” file in the “data” folder. After a file is selected, you can see the Data Preview which is showing the first several rows of the data. Note that the first row shows the column names and their associate types in parentheses. For each column, you can click the drop-down menu after the type to change its type. Figure 4.4: Import Data Preview From this figure, you can see that the preview only shows one column named “country*year*HDI”. Apparently, the separator “*” is not properly interpreted during the process. To fix this problem, we can look at the Import Options in the left area. Figure 4.5: Import Options Let’s summarize a few commonly used options, their corresponding arguments in the read_csv() or read_delim() function, and meanings. Table 4.2: Menu Options and its Corresponding Arguments in read_delim() and Meanings Option Argument Meaning Name - The object name you would like to assign to. Skip skip The number of rows to skip at the beginning of the file. First Row as Names col_names Whether you want to use the first row as column names. TRUE or FALSE. Delimiter delim The delimiter of the data file. Comment comment The character indicating the starting of comment. The contents after the comment character will be ignore in each line. NA na The way NA is represented in the data file. Code Preview - The R code to be executed for importing the data In our case, we will change the value of “Delimiter” to “*” (Note that you need to select “Other..”, and enter “*” manually.) Figure 4.6: Import Options (Star) Note that when you change the delimiter, the Data Preview window also change correspondingly. Figure 4.7: Data Preview (Star) After changing the delimiter to *, we are seeing the expected data with three columns: dig_num, ani_char, and conditions. The code in the Code Preview window will change accordingly, which is a great way to learn on how they work. The new codes in the Code Preview window is as below. library(readr) gm_small_star &lt;- read_delim(&quot;data/gm_small_star.csv&quot;, delim = &quot;*&quot;, escape_double = FALSE, trim_ws = TRUE) View(gm_small_star) 4.3.6 Exercises For the “my_data_na.csv” file you created in Exercise 2 in Section 4.2, write R code to read the file into an object with name my_data. First, look at the code below. d1 &lt;- read_csv(&quot;x,y,z 1,3,5 2,4,6&quot;, col_names = FALSE) Which of the following are the column names of the d1? X1, X2, and X3 x, y, and z First, look at the code below. d1 &lt;- read_csv(&quot;The first line The second line The third line x,y,z 1,3,5&quot;) What will be the column name(s) of the d1? "],["import-excel.html", "4.4 Exporting to and Importing from Excel Files", " 4.4 Exporting to and Importing from Excel Files Now, you know how to export to and import from delimited files. In this section, you will learn how to export to and import from Excel files with extensions .xls and .xlxs. 4.4.1 Export data into Excel files To export data into an Excel file, you can use the writexl package. Let’s first install the package. install.packages(&quot;writexl&quot;) Now, we can load the writexl package and use the write_xlsx() function to write data into an Excel file with extension .xlsx. Let’s first load the data from “gm_small.csv” and write it to “gm_small.xlsx”. library(writexl) library(readr) gm_small &lt;- read_csv(&quot;data/gm_small.csv&quot;) write_xlsx(gm_small, &quot;data/gm_small.xlsx&quot;) By default, the column names of the data frame/tibble will be written to the first row of the Excel file. To skip the column names, you can set col_names = FALSE in the write_xlsx() function. In addition to writing a single data frame to an Excel file, write_xlsx() can also write multiple data frames into a single Excel file, with each Excel sheet containing one data frame. To do that, you need to supply a list of data frames as the first argument in write_xlsx(). Let’s take a look at the following example which write both gm_small and sahp (a tibble in the r02pro package introduced in Section 4.1.2) into an Excel file named “two_data.xlsx”. library(r02pro) two_data &lt;- list(gapminder = gm_small, sahp = sahp) write_xlsx(two_data, &quot;data/two_data.xlsx&quot;) You can open this file with Excel and verify its contents. 4.4.2 Import Excel Files (.xls and .xlsx ) using read_excel() After learning how to export data into an Excel file, let’s see how to read an existing Excel file into R. We can use the read_excel() function in the readxl package to import Excel files. Here, readxl is another subpackage in the tidyverse package. Thus we can directly load the package if the tidyverse package is already installed. Let’s import the Excel file “two_data.xlsx” we just created into R. library(readxl) my_df &lt;- read_excel(&quot;data/two_data.xlsx&quot;) head(my_df) #&gt; # A tibble: 5 × 4 #&gt; country year gender continent #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Albania 2004 female Europe #&gt; 2 Andorra 2004 female &lt;NA&gt; #&gt; 3 United Arab Emirates 2004 female Asia #&gt; 4 Argentina 2004 female Americas #&gt; 5 Armenia 2004 female Asia We can see from the result that although the file contains two sheets, the function will import the first sheet by default. To import the second sheet, you can set the sheet argument to the sheet name (sahp) or the position of the sheet (2). sahp_1 &lt;- read_excel(&quot;data/two_data.xlsx&quot;, sheet = &quot;sahp&quot;) #sahp_1 &lt;- read_excel(&quot;two_data.xlsx&quot;, sheet = 2) #same result as the previous line head(sahp_1) #&gt; # A tibble: 6 × 12 #&gt; dt_sold bedroom bathroom gar_car oa_qual liv_area lot_area house…¹ #&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 2010-03-25 00:00:00 3 2.5 2 6 1479 13517 2Story #&gt; 2 2009-04-10 00:00:00 4 3.5 2 7 2122 11492 2Story #&gt; 3 2010-01-15 00:00:00 3 2 1 5 1057 7922 1Story #&gt; 4 2010-04-19 00:00:00 3 2.5 2 5 1444 9802 2Story #&gt; 5 2010-03-22 00:00:00 3 2 2 6 1445 14235 1.5Fin #&gt; 6 2010-06-06 00:00:00 2 2.5 2 6 1888 16492 1Story #&gt; # … with 4 more variables: kit_qual &lt;chr&gt;, heat_qual &lt;chr&gt;, central_air &lt;chr&gt;, #&gt; # sale_price &lt;dbl&gt;, and abbreviated variable name ¹​house_style If we only want to import a portion of the data, say the first 5 rows and the first 4 columns, then we can set the argument range = \"A1:D5\", just like the range in an excel file. Note that the index starts with the first row, which may correspond to the column names. sahp_2 &lt;- read_excel(&quot;data/two_data.xlsx&quot;, sheet = &quot;sahp&quot;, range = &quot;A1:D5&quot;) sahp_2 #&gt; # A tibble: 4 × 4 #&gt; dt_sold bedroom bathroom gar_car #&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2010-03-25 00:00:00 3 2.5 2 #&gt; 2 2009-04-10 00:00:00 4 3.5 2 #&gt; 3 2010-01-15 00:00:00 3 2 1 #&gt; 4 2010-04-19 00:00:00 3 2.5 2 Note that read_excel() can read both .xls and xlsx file types. 4.4.3 Import Excel file using the menu Besides using read_excel() to import Excel files, you can again use the interactive menu we introduced in Section 4.3. As introduced in Table 4.1, to import Excel files, you can select From Excel after choosing the Import Dataset option. As before, you can click Browse… and select the data file. Let’s select the “two_data.xlsx” file we just created. Similar to importing the delimited files, we can see the first several rows in the Data Preview window. The first row shows the column names and their associate types in parentheses. For each column, you can click the dropdown menu after the type to change its type. Now, let’s discuss several options in the Import Options section and their corresponding arguments in the read_excel() function. Table 4.3: Menu Options and its Corresponding Arguments in read_excel() and Meanings Option Argument Meaning Name - The object name you would like to assign to. Sheet sheet The Sheet you want to import from. Range range The data range you want to import. Max Rows n_max The maximum number of rows to import. Skip skip The number of rows to skip at the beginning of the file. NA na The way NA is represented in the data file. First Row as Names col_names Whether you want to use the first row as column names. TRUE or FALSE. Code Preview - The R code to be executed for importing the data Note that similar as importing delimited files, when you change these options, the code in the Code Preview window will change accordingly, which is a great way to learn on how they work. 4.4.4 Exercises Use R to create the following data frame and assign it to the name df1. #&gt; word1 number1 #&gt; 1 one 1 #&gt; 2 two NA #&gt; 3 &lt;NA&gt; 3 Then, use R to create the following data frame and assign it to the name df2. #&gt; word2 number2 #&gt; 1 three 3 #&gt; 2 &lt;NA&gt; 4 #&gt; 3 five 5 Then create a list named my_list with df1 as the first element and df2 as the second element. Write R code to set working directory to the desktop, then export my_list into an excel file named list.xlsx. How many sheets are there in the excel file? What are the contents in each sheet? Write R code to import the first two rows and the first column of the second sheet from the excel file you just created. And verify the object value. "],["import-other.html", "4.5 Exporting to and Importing from SPSS, SAS, and Stata Files", " 4.5 Exporting to and Importing from SPSS, SAS, and Stata Files Now, you know how to export and import data from delimited files and Excel files. In the section, you will learn how to export and import data from other statistical software including SPSS, SAS, and Stata. We will use the package haven, another member of the tidyverse family. 4.5.1 Export and Import SPSS Files Let’s first load the package haven, and prepare a data frame for exporting. library(tibble) library(haven) dig_num &lt;- 7:1 ani_char &lt;- c(&quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;, &quot;pig&quot;, &quot;monkey&quot;, NA, &quot;pig&quot;) conditions &lt;- c(&quot;Excellent&quot;, &quot;Good&quot;, NA, &quot;Fair&quot;, &quot;Good&quot;, &quot;Good&quot;, &quot;Excellent&quot;) my_animals&lt;- tibble(dig_num, ani_char,conditions) my_animals #&gt; # A tibble: 7 × 3 #&gt; dig_num ani_char conditions #&gt; &lt;int&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 7 sheep Excellent #&gt; 2 6 pig Good #&gt; 3 5 monkey &lt;NA&gt; #&gt; 4 4 pig Fair #&gt; 5 3 monkey Good #&gt; 6 2 &lt;NA&gt; Good #&gt; 7 1 pig Excellent The data frame my_animals will be used as in Section 4.2. You can use the function write_sav() to export a data frame into a SPSS .sav file. write_sav(my_animals, &quot;data/my_animals.sav&quot;) To read a SPSS file ending in .sav or .por, you can use the function read_spss() which will automatically call read_sav() for .sav files and read_por() for .por files. my_animals_spss &lt;- read_spss(&quot;data/my_animals.sav&quot;) head(my_animals_spss) #&gt; # A tibble: 6 × 3 #&gt; dig_num ani_char conditions #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 7 &quot;sheep&quot; &quot;Excellent&quot; #&gt; 2 6 &quot;pig&quot; &quot;Good&quot; #&gt; 3 5 &quot;monkey&quot; &quot;&quot; #&gt; 4 4 &quot;pig&quot; &quot;Fair&quot; #&gt; 5 3 &quot;monkey&quot; &quot;Good&quot; #&gt; 6 2 &quot;&quot; &quot;Good&quot; 4.5.2 Export and Import SAS Files You can use the function write_sas() to export a data frame into a SAS .sas7bdat file. write_sas(my_animals, &quot;data/my_animals.sas7bdat&quot;) To import a SAS file, you can use the function read_sas(). my_animals_sas &lt;- read_sas(&quot;data/my_animals.sas7bdat&quot;) head(my_animals_sas) #&gt; # A tibble: 6 × 3 #&gt; dig_num ani_char conditions #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 7 &quot;sheep&quot; &quot;Excellent&quot; #&gt; 2 6 &quot;pig&quot; &quot;Good&quot; #&gt; 3 5 &quot;monkey&quot; &quot;&quot; #&gt; 4 4 &quot;pig&quot; &quot;Fair&quot; #&gt; 5 3 &quot;monkey&quot; &quot;Good&quot; #&gt; 6 2 &quot;&quot; &quot;Good&quot; 4.5.3 Export and Import Stata Files Lastly, let’s talk about Stata files. You can use the function write_dta() to export a data frame into a Stata .dta file. write_dta(my_animals, &quot;data/my_animals.dta&quot;) To read a Stata file ending in .dta, you can use the function read_dta(). my_animals_stata &lt;- read_dta(&quot;data/my_animals.dta&quot;) head(my_animals_stata) #&gt; # A tibble: 6 × 3 #&gt; dig_num ani_char conditions #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 7 &quot;sheep&quot; &quot;Excellent&quot; #&gt; 2 6 &quot;pig&quot; &quot;Good&quot; #&gt; 3 5 &quot;monkey&quot; &quot;&quot; #&gt; 4 4 &quot;pig&quot; &quot;Fair&quot; #&gt; 5 3 &quot;monkey&quot; &quot;Good&quot; #&gt; 6 2 &quot;&quot; &quot;Good&quot; 4.5.4 Import using the menu Similarly as Sections 4.3 and 4.4, you can also use the menu in Table 4.1 to import SPSS, SAS, and Stata Files. 4.5.5 Exercise Export the first 8 observations in the sahp dataset (in r02pro package) to SPSS, SAS, and Stata file formats, respectively. Import the files from Q1 to R and verify their contents. "],["save-object.html", "4.6 Save and Restore Objects and Workspace", " 4.6 Save and Restore Objects and Workspace Now, you know how to export and import data frames (or tibbles) to and from various types of files. In this section, you will learn how to save and restore one or more objects that can be of any types, and even the whole workspace that includes all the named objects. To get started, let’s first clear our workspace using rm(list = ls()) and create a few objects with different types. rm(list = ls()) dig_num &lt;- 7:1 ani_char &lt;- c(&quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;, &quot;pig&quot;, &quot;monkey&quot;, NA, &quot;pig&quot;) Recall that we can use ls() to get a vector of strings giving the names of the objects in the current environment. ls() #&gt; [1] &quot;ani_char&quot; &quot;dig_num&quot; 4.6.1 Save and Restore Objects using .RData In R, you can use the function save() to save one or more objects into an .RData file. Note that you want to make sure to change the working directory as needed. Let’s see the following example where we save the object dig_num into a file named “dig_num.RData”. save(dig_num, file = &quot;data/dig_num.RData&quot;) Before introducing how to restore objects, let’s first remove dig_num from our workspace using the rm() function and check its value. rm(dig_num) dig_num #&gt; Error in eval(expr, envir, enclos): object &#39;dig_num&#39; not found You can see an error since dig_num has been removed from the workspace. To restore it, you can use the function load() with the corresponding .RData file in double quotes as its argument. load(&quot;data/dig_num.RData&quot;) dig_num #&gt; [1] 7 6 5 4 3 2 1 You can verify from the value of dig_num that we have successfully restored the object dig_num from the file “dig_num.RData”. To save more than one objects into a single file, you just need to enter them as additional arguments in the save() function. save(dig_num, ani_char, file = &quot;data/dig_num_and_ani_char.RData&quot;) To save everything in the workspace, you can use the function save.image() with the desired file name in double quotes as the argument. save.image(&quot;data/all.RData&quot;) To verify that “all.RData” indeed contains all the named object, let’s try the following. rm(list = ls()) #remove everything from the workspace. ls() #confirm the workspace is empty. #&gt; character(0) load(&quot;data/all.RData&quot;) #restore from &quot;all.RData&quot;. ls() #check what&#39;s in the workspace. #&gt; [1] &quot;ani_char&quot; &quot;dig_num&quot; 4.6.2 Save and Restore a Single Object using saveRDS() and readRDS() Before introducing the new method, there is one drawback of load() worth noting: if the imported .RData file contains objects with the same names as in the current workspace, all these objects in the current workspace will be silently overwritten without any warning! Let’s see the following example. dig_num &lt;- 3.14 dig_num #&gt; [1] 3.14 load(&quot;data/all.RData&quot;) dig_num #&gt; [1] 7 6 5 4 3 2 1 We can see that the value of dig_num was indeed silently overwritten by the load() function, which could be sometimes dangerous. To avoid this issue, another pair of functions to save and restore a single object is saveRDS() and readRDS(). The usage of saveRDS() is almost identical to save() except we usually use a file with extension “.rds” to store the object. saveRDS(dig_num, file = &quot;data/dig_num.rds&quot;) To highlight the different behaviors of readRDS() and load(), let’s change the dig_num again. dig_num &lt;- 666 dig_num #&gt; [1] 666 To restore the object in an “rds” file, we use the readRDS() in the following way. dig_num_new &lt;- readRDS(&quot;data/dig_num.rds&quot;) dig_num_new #&gt; [1] 724 dig_num #&gt; [1] 666 As it is clear from this example, you need to assign the output of the readRDS() function to a name, which helps to prevent any objects been overwritten silently. In fact, the saveRDS() only saves the value of the object without the object name. For this reason, you are recommended to use the function pair saveRDS() and readRDS() if you want to save and load a single R object. While save() and load() may be simpler to use when saving and loading multiple objects, you want to be extremely careful with the overwriting issues we discussed here. In fact, you can also use saveRDS() and readRDS() for multiple objects if you create a list containing all the objects. saveRDS(list(dig_num = dig_num, ani_char = ani_char), file = &quot;data/multi.rds&quot;) Now, let’s try to change the value of dig_num, and recover its original value using readRDS(). dig_num &lt;- 999 dig_num #&gt; [1] 999 my_list &lt;- readRDS(&quot;data/multi.rds&quot;) my_list$dig_num #&gt; [1] 7 6 5 4 3 2 1 4.6.3 Exercises Define a vector my_vec &lt;- 1:8 and a list my_list &lt;- list(my_num = 5:10, my_char = letters[1:5]). Save my_vec and my_list to a single .RData file named “my_vec_list.RData”. Then clear the workspace, restore these two objects from the .RData file, and verify their values. Save both my_vec and my_list in Q1 to a single .rds file named “my_vec_list.rds”. Then clear the workspace, restore these two objects from the .rds file, and verify their values. "],["data-visualization.html", "Chapter 5 Basic Data Visualization", " Chapter 5 Basic Data Visualization Equipped with the knowledge of different R objects in Chapters 2 and 3, and knowing how to import data sets in Chapter 4, we are ready to dive into the colorful world of data visualization. In this chapter, you will learn the most commonly used kinds of plots that can be generated in R. "],["scatterplot.html", "5.1 Scatterplot", " 5.1 Scatterplot Starting from this section, you will learn various kinds of plots, that involves one or more variables in a data set. Let’s first look at the gapminder data set gm2004. We would like to learn the relationship between sugar and cholesterol. To visualize the relationship between two continuous variables, one of the most commonly used plots is the scatterplot, which is a 2-dimensional plot with a collection of all the datapoints, where the x-axis and y-axis correspond to the two variables, respectively. 5.1.1 Using the plot() function In base R, you can use the plot() function to generate a scatterplot with the first argument as the variable on the x-axis and the second argument as the variable on the y-axis. library(r02pro) plot(gm2004$sugar, gm2004$cholesterol) From the scatterplot, you can see a clear increasing trend between sugar and cholesterol, which is consistent with our intuition. The plot() function provides a rich capability of customization by setting the graphical parameters. We summarize a few commonly used parameters for scatterplots as below. Parameter Meaning Example col Color “red” xlab A title for the x-axis “Sugar” ylab A title for the y-axis “Cholesterol” main An overall title for the plot “Cholesterol vs. Sugar” pch Shape of the points 2 cex Size of text and symbols 2 A collection of shapes and their associated integers are as below. Figure 5.1: All Possible Shapes Let’s see the effect of these parameters in the following example. plot(gm2004$sugar, gm2004$cholesterol, col = &quot;red&quot;, xlab = &quot;Sugar&quot;, ylab = &quot;Cholesterol&quot;, main = &quot;Cholesterol vs. Sugar&quot;, pch = 2, cex = 2) 5.1.2 Interacting and Saving the plot from plot() After generating the plot, there are many convenient options in the “Plots” panel of RStudio that allow us to interact with the plot. Figure 5.2: Plots Panel Options Here are a few options. Zoom: The figure will be detached as a separate window in RStudio. You can then drag it around or adjust its size freely just like any other window. Export (Save as Image): You can choose the Image Format, change the Directory, customize the File Name, and set the Width and Height. Export (Save as PDF): You can choose the PDF Size, Orientation (Portrait or Landscape), Directory, and File Name. Export (Copy to Clipboard): This option is useful if you just want to immediately paste the picture into another document such as a Word document, Preview, or email message. Before copying, you can also customize the width and height. In addition to using the menu options, you can also write script to automatically save the plot to your desired local directory. To do that, you need to do the following three steps: Specify a file which will serve as the output device for the plot() function. You can use functions png(), jpeg(), png(), and pdf() with the target file name as the argument. Run the plot() function. Run dev.off() to close the connection. Let’s see an example. pdf(&quot;data/cholestrol_vs_sugar.pdf&quot;) plot(gm2004$sugar, gm2004$cholesterol) dev.off() Note that when you use the .pdf format, you can have multiple plots generated from the plot() before running dev.off(). In this case, the output .pdf file will contain multiple pages where each page corresponds to a plot. 5.1.3 Using the ggplot() function Although the plot() function gets the work done, the ggplot2 package provides a superior user experience which allows us to create complex plots with ease. Since the ggplot2 package is a member of the tidyverse package, you don’t need to install it separately if tidyverse was already installed. Let’s first load the package ggplot2 and create a scatterplot. library(ggplot2) ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol)) Aside from the expected scatterplot, you can see a warning message “Removed 128 rows containing missing values (geom_point).” This indicates that there are 128 rows in gm2004 that contains missing values for sugar and/or cholesterol (see Section 2.15 for a detailed treatment of missing values) and they are removed during the plotting process. The removal of missing values for relevant variables is a default behavior for all plots generated by the ggplot2 package. Now, let’s walk through the mechanism of ggplot2. In a nutshell, ggplot2 implements the grammar of graphics, a coherent system for describing and building graphs. A more detailed description on the grammar of graphics can be found in Wickham (2010). Let’s break it down into two steps. In ggplot2, we always start with the function ggplot() with a data frame or tibble as its argument. ggplot(data = gm2004) After running this code, you can see an empty plot. This is because ggplot does not yet know which variables or what type of plots you want to create. To generate a scatterplot, you can add a layer using the + operator followed by the geom_point() function. The geom_point() is one of the many available geoms in ggplot. Inside geom_point(), you need to set the value of the mapping argument. The mapping argument takes a functional form as mapping = aes(), where the aes is short for aesthetics. For example, you can use aes() to tell ggplot to use which variable on the x-axis and which variable on the y-axis. Let’s take another look at this example. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol)) Here, inside the aes() function, we set x = sugar and y = cholesterol, indicating that the variable sugar will appear on the x-axis and cholesterol will appear on the y-axis. When creating a ggplot, we recommend starting a new line after each + and also put the arguments of the aes() function on separate lines for better readability. Now, let’s look at another example. We would like to explore the relationship between GDP_per_capita and life_expectancy. ggplot(data = gm2004) + geom_point(mapping = aes(x = GDP_per_capita, y = life_expectancy)) We can see that life_expectancy in general increases (in a non-linear fashion) as GDP_per_capita increases, which is also consistent with our knowledge. From the figure, you can see that there is a pretty heavy left tail for GDP_per_capita. To fix this problem, you can actually use a log transformation of GDP_per_capita in the scatterplot. Note that you can directly use the transformed form inside the aesthetic mapping, without the need to separately add the transformation as a variable. ggplot(data = gm2004) + geom_point(mapping = aes(x = log10(GDP_per_capita), y = life_expectancy)) After the logarithm transformation, you can see a relationship that is more linear. 5.1.4 Interact and Save the plot from ggplot() After generating the plot using ggplot(), you can use exactly the same menu options for interacting the plot as for plot(). However, the mechanism for saving plots from ggplot() is completely different from that of plot(). To save a plot from ggplot(), you just need to use the ggsave() function after generating the plot without first setting up the connection to the file. The ggsave() function is very smart in the sense that it will automatically save the plot to the desired format depending on the extension of the given file name. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol)) ggsave(&quot;data/cholestrol_vs_sugar_ggplot.pdf&quot;) #save the plot as a .pdf file ggsave(&quot;data/cholestrol_vs_sugar_ggplot.jpg&quot;) #save the plot as a .jpg image 5.1.5 Exercises Using the sahp dataset, create a scatterplot to visualize the relationship between liv_area (on the x-axis) and sale_price (on the y-axis) without using any package, then set labels according to variable names and change all points to red. Finally, save the plot to data/sale_price_vs_liv_area.jpg and discuss the findings. Using the gm2004 dataset, create a scatterplot to visualize the relationship between sanitation (on the x-axis) and life_expectancy (on the y-axis) using the ggplot2 package. Finally, save the plot to data/life_expectancy_vs_sanitation.pdf and discuss the findings. References "],["aes-constant-value.html", "5.2 ggplot Aesthetics (I): Constant-Valued Aesthetics", " 5.2 ggplot Aesthetics (I): Constant-Valued Aesthetics Having learned how to generate a basic scatterplot using geom_point() in Section 5.1, we are now ready to introduce one of the most important ingredients in a geom, namely, the aesthetics. Aesthetics include distinct features that you can change that affect the appearances of a plot, including color, shape, and size. There are in general three kinds of aesthetics: Constant-Valued Aesthetics: this type of aesthetics change the corresponding feature of a plot globally (for example, color = \"red\" will make everything red). This type of aesthetic specification appears as an argument of the geoms (for example geom_point()). This will be the focus of our current section. Local Aesthetic Mapping: this type of aesthetics (for example, color) will take possibly different values (different color values) for different data points depending on the mapped variables, only for the current geom. This type of aesthetic specification appears as an argument of the aes() function of the corresponding geom. We will cover this type of aesthetic in the next Section (Section 5.3). Global Aesthetic Mapping: this type of aesthetics will use possibly different values for different data points depending on the mapped variable, at the global level, which will be passed to all individual geoms. This type of aesthetic specification appears as an argument of the aes() function, which is an argument of the ggplot() function. We will cover this type of aesthetic in Section 5.7, where multiple geoms are used. Note that although we will introduce aesthetics via the example of scatterplot, they are used for all kinds of plots which will be covered at a later time. Let’s first review the code we used to generate the scatterplot between sugar and cholestrol in the gm2004 dataset. library(ggplot2) library(r02pro) ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol)) Now, let’s see how to set Constant-Valued Aesthetic in geom_point(). a. Color To change the color of all points, you can add a color argument in the geom_point() function. Note that it is placed outside of the aes() function, which is different from aesthetic mappings, to be covered in the next section. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol), color = &quot;blue&quot;) Clearly, all points are changed to blue. b. Size Similarly, you can set the size aesthetic in the geom_point() function to change the size of the all points. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol), size = 3) Note that it is very common to set multiple constant valued aesthetic in a geom function. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol), color = &quot;blue&quot;, size = 3) You may notice that the points are now bigger than before. Looking at the plot, some points are overlapping with each other, which is sometimes called overplotting. To solve this issue, you can change the transparency level of the points by setting the alpha aesthetic. c. Transparency ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol), color = &quot;blue&quot;, size = 3, alpha = 0.5) By setting alpha = 0.5, the points become more visible and the overplotting problem is largely alleviated. d. Shape Lastly, we can also change the shape of the points from the default 1 (circle) to other shapes by the shape argument in geom_point(). ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol), color = &quot;blue&quot;, size = 3, alpha = 0.5, shape = 2) Now, we have all points blue, size of 3, of triangle shape, and of transparency level 0.5. Recall the collection of all shapes is available in Figure 5.1. You are welcome to try different combinations of global aesthetics. 5.2.1 Exercises Using the sahp dataset, create a scatterplot with ggplot2 to visualize the relationship between lot_area (on the x-axis) and sale_price (on the y-axis) with all points of color purple and size 2. Using the gm2004 dataset, create a scatterplot with ggplot2 to visualize the relationship between BMI (on the x-axis) and cholesterol (on the y-axis) with all points of color pink, size 3, transparency 0.3, and shape of diamond. "],["aes-local-map.html", "5.3 ggplot Aesthetics (II): Local Aesthetics Mapping", " 5.3 ggplot Aesthetics (II): Local Aesthetics Mapping In Section 5.2, we introduced the first kind of aesthetics, namely Constant-Valued Aesthetics, where we set constant values to aesthetics that change features of the plot globally. In some applications, however, you may want to highlight different groups of the data with different values of aesthetics. In this section, we will dive deep into this topic: Local Aesthetics Mapping. Believe it or not, we’ve already seen this kind of aesthetic mapping when we first introduced ggplot in Section 5.1.3. library(ggplot2) library(r02pro) ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol)) In the aes() function, x and y can also be viewed as aesthetics. It is clear to see that we are not setting x and y as constants. Instead, we map the variable sugar to x and the variable cholesterol to y. The x and y coordinates control the location of each data points depending on the variables of sugar and cholesterol, which is the essence of scatterplot. Now, let’s see how to do local aesthetic mappings for color, size, shape, and so on. 5.3.1 Basic Local Aesthetics Mapping a. Color Let’s say you want to use different colors for male and female on the scatterplot. To do this, you can map the discrete variable gender to the color aesthetic by setting color = gender as an argument in the aes() function. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol, color = gender)) From this figure, we can clearly see that different genders are shown in distinct colors. Also, for the same value of sugar, it appears that the value of cholestrol could be a bit smaller for male than that for female. In addition, ggplot() automatically created a legend to show the correspondence between the genders and colors. Can we map a continuous variable to the color aesthetic? The answer is positive. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol, color = population)) Here, you can see that the color of the points changes smoothly according to the value of population, the details of which is shown in the legend. In particular, the darker points represent smaller populations while the lighter ones correspond to bigger populations. b. Size In addition to color, you can also map a discrete variable to the size aesthetic. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol, size = gender), alpha = 0.5) #&gt; Warning: Using size for a discrete variable #&gt; is not advised. #&gt; Warning: Removed 128 rows containing missing #&gt; values (`geom_point()`). You can see from the plot that the sizes of the points are now different according to the gender. To alleviate the overplotting issue, we added a contant-valued aesthetic alpha = 0.5 to the geom_point() function, making all points more transparent. Please pay close attention to the location where we put the argument: Contant-Valued Aesthetic: the aesthetic specification is put inside the geom_point() function. Local Aesthetics Mapping: the aesthetic mapping is put inside the aes() function, which is itself an argument of the geom_point() function. There is a warning message: “Using size for a discrete variable is not advised.” The reason is that different sizes may implicitly indicate a particular ordering of the groups, which are usually not clear for a discrete variable. Now, let’s try to map a continuous variable BMI to the size aesthetic. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol, size = BMI), alpha = 0.5) Note that now the size of the points changes according to the corresponding BMI value, i.e. the larger points represent higher BMIs values and the smaller ones correspond to lower BMI values. It is worth noting that the legend only shows three representative BMI values (20, 25, and 30) and their corresponding sizes, however, we have other sizes shown on the plot depending on exact BMI values. c. Shape We can also map a discrete variable to the shape aesthetic. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol, shape = continent)) Now, the shape of the points are different for each continent. Can we map a continuous variable to the shape aesthetic? Let’s try it out. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol, shape = BMI)) You will see an error message: “A continuous variable can not be mapped to shape”. This is because shape is of a discrete nature in the sense that different shapes have no natural ordering and the number of possible shapes is finite where the continuous variable could take infinitely many different values. d. Multiple Aesthetic Mappings Just like Constant Valued Aesthetics, you can have multiple aesthetic mappings in ggplot, which can involve multiple mapped variables. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol, shape = gender, color = HDI_category)) Here, we differentiate gender by different shapes and differentiate HDI_category by different colors. Note that HDI_category represent the Human Development Index for each country. We can see that countries with low HDI has smaller values of sugar and cholesterol in general. Also note that there are two legends on the plot showing the color and shape, respectively. 5.3.2 Customize the Local Aesthetics Mapping So far, we have introduced the basic local aesthetics mapping, where the default aesthetic values are used. Sometimes, you may want to use specific aesthetic values (colors, shapes) for particular values of the mapped variable. a. Customize colors for discrete variables Let’s start with the color aesthetic. To customize the colors with discrete variable, you can add a layer to the ggplot with function scale_colour_manual with argument values containing a character vector consisting of the desired colors in order. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol, color = gender)) + scale_colour_manual(values = c(&quot;orange&quot;,&quot;purple&quot;)) Now, the female group has color orange and the male group has color purple. b. Remove the NA level Let’s try to map continent to color. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol, color = continent)) The plot shows us the Africa countries in general have a lower value of sugar as well as a small value of cholestrol. On the other hand, the American and European countries have large values of sugar and cholestrol. You may noticed that this is a level NA for the continent due to missing values. To address this issue, you can use the remove_missing() function to remove observations with a missing value of continent. ggplot(data = remove_missing(gm2004, vars = &quot;continent&quot;)) + geom_point(mapping = aes(x = sugar, y = cholesterol, color = continent)) Now, only the five continents are displayed. Note that here, we add the argument vars = \"continent\" in the remove_missing() function. This works by removing the observations only if the continent variable is missing. Without such an argument, an observation will be removed as long as there is at least one variable missing. For a dataset like gm2004 that contain many variables, we recommend explicitly specify the variables that need to be considered for missingness. Here, the vars can take the value of a character vector, containing all variables that you want to consider for missingness. c. Customize color for continuous variables To customize the color for continuous variables, you can add a layer scale_color_continuous() which specify the lower-value color and the high-value color for the variable. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol, color = BMI)) + scale_color_continuous(low = &quot;green&quot;, high = &quot;red&quot;) Now, we mapped the BMI to the color aesthetic and the lower values of BMI are mapped to green while the higher values are mapped to red. d. Customize the shape for discrete variables Similarly, you can also customize the shapes for each level of the discrete variable. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol, shape = gender)) + scale_shape_manual(values = c(6, 3)) Here, we have the female and male being mapped to shape 6 and 3, respectively. Recall that all possible shapes are shown in Figure 5.1. 5.3.3 Customize the legend order for discrete variables Let’s review the following plot where we map continent to the color aesthetic. ggplot(data = remove_missing(gm2004, vars = &quot;continent&quot;)) + geom_point(mapping = aes(x = sugar, y = cholesterol, color = continent)) Looking at the legend, you can see that different continent values are in alphabetical order as introduced in Section 2.10 when you learned the ordering of character vectors. Sometimes, you may want to arrange these values in a different order in the plot. To achieve this, you can add a layers scale_color_discrete() with the argument breaks that specifies the desired order on the legend. ggplot(data = remove_missing(gm2004, vars = &quot;continent&quot;)) + geom_point(mapping = aes(x = sugar, y = cholesterol, color = continent)) + scale_color_discrete(breaks = c(&quot;Oceania&quot;, &quot;Europe&quot;, &quot;Asia&quot;, &quot;Americas&quot;,&quot;Africa&quot;)) Note that only the legend order changed with the corresponding mapped values unchanges. Now, let’s map gender to the shape aesthetic. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol, shape = gender)) To customize the legend order, you can add another layers called scale_shape_discrete() with the desired legend order. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol, shape = gender)) + scale_shape_discrete(breaks = c(&quot;male&quot;, &quot;female&quot;)) You may find a pattern here that to customize a ggplot where a certain aesthetic is considered, we need to use the corresponding customization function like scale_color_discrete() for the color aesthetic and scale_shape_discrete() for the shape aesthetic. 5.3.4 Create Logical Variables and Map to Aesthetics Lastly, you can also create logical variables on the fly and map them to aesthetics, without defining them as new variables. For example, if you want to differentiate the points according to whether the value of BMI is larger than 25, a logical variable BMI &gt; 25 can be created. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol, color = BMI &gt; 25), size = 2) Now, let’s see another example where we want to differentiate countries in Africa vs. other continents. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol, shape = continent != &quot;Africa&quot;), size = 2) Clearly, you can easily create new logical variables using any logical operations on existing variables, and map them into any aesthetics just like for the existing categorical variables. 5.3.5 Exercises Use ggplot2 package to answer the following questions. Using the sahp dataset, create a scatterplot to visualize the relationship between liv_area (on the x-axis) and sale_price (on the y-axis). Use different colors for different house_style, different shapes to distinguish central_air, and points are of the size 2. Using the gm2004 dataset, create a scatterplot to visualize the relationship between BMI (on the x-axis) and cholesterol (on the y-axis) where the points are purple and the size of the points are determined by the BMI values. Using the gm2004 dataset, create a scatterplot to visualize the relationship between sugar (on the x-axis) and cholesterol (on the y-axis) where the points are red when HDI_category is high or very high and the points are purple when HDI_category is low or medium and the size depend on the value of population. Please also remove the NA level in HDI_category. Discuss your findings. "],["customization.html", "5.4 Customization in ggplot", " 5.4 Customization in ggplot In this section, we would like to digress a little bit to show some possible customizations on the axes, labels, and titles. Let’s first review the following scatterplot introduced in Section 5.1. library(ggplot2) library(r02pro) ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol)) Before introducing customization, let’s introduce a way to save the current plot and add additional layers, to avoid repetition of codes. For example, we can break down the previous code into the following two steps. step_1 &lt;- ggplot(data = gm2004) step_1 + geom_point(mapping = aes(x = sugar, y = cholesterol)) This is equivalent to the previous plot. Let’s save the whole plot into an R object. my_plot &lt;- ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol)) 5.4.1 Customization of Labels and Titles a. Customize x and y labels and title By default, the x and y labels are the variables names, and there is no title for the plot. You can customize the x and y labels using the xlab() and ylab() function, and add a title with the ggtitle() function. my_plot_2 &lt;- my_plot + xlab(&quot;Sugar (grams per person and day)&quot;) + ylab(&quot;Cholesterol (mmol/L)&quot;) + ggtitle(&quot;Cholesterol vs. Sugar&quot;) my_plot_2 b. Customize the font of the x and y breaks In addition, you can further customize the font of the x and y breaks using the theme() function with the argument axis.text. my_plot_2 + theme(axis.text = element_text(size = 25, color = &quot;red&quot;)) c. Customize the font of labels To customize the font, you can use axis.title argument to change the size, color, and face of the labels. my_plot_2 + theme(axis.title = element_text(size = 18, color = &quot;red&quot;, face = &quot;italic&quot;)) d. Customize the font of the title Similarly, you can use the plot.title argument to customize the font of the title. my_plot_2 + theme(plot.title = element_text(size = 24, color = &quot;magenta&quot;, face = &quot;bold&quot;)) e. Center the title Sometimes, we may want to center the title. We can achieve this by setting the hjust parameter. my_plot_2 + theme(plot.title = element_text(size = 24, color = &quot;magenta&quot;, face = &quot;bold&quot;, hjust = 0.5)) f. Mix Apparently, you are free to mix all the different customizations. Let’s see an example as below. my_plot_2 + theme(axis.title = element_text(size = 18, color = &quot;red&quot;, face = &quot;italic&quot;), axis.text = element_text(size = 12, color = &quot;blue&quot;), plot.title = element_text(size = 24, color = &quot;magenta&quot;, face = &quot;bold&quot;, hjust = 0.5)) g. Save as a theme As you can see from the code, the code gets complicated if we want to customize many things at the same time. To save time, you can actually save the desired into an R object and reuse it later. mytheme &lt;- theme(axis.title = element_text(size = 18, color = &quot;red&quot;, face = &quot;italic&quot;), axis.text = element_text(size = 12, color = &quot;blue&quot;), plot.title = element_text(size = 24, color = &quot;magenta&quot;, face = &quot;bold&quot;, hjust = 0.5)) Then, we can generate the same plot with mytheme using g1 + mytheme For a different plot, we can also use the same mytheme. ggplot(data = gm2004) + geom_point(mapping = aes(x = log10(GDP_per_capita), y = life_expectancy)) + mytheme 5.4.2 Customizing the Breaks on the x and y Axes In the above plot, the breaks on the x axis are 0, 50, 100, 150, and 200. The breaks on the y axis are 4.0, 4.5, 5.0, and 5.5. Sometimes, we may want to customize the breaks, e.g. to show a finer scale. To do this, we can use the scale_x_continous() and scale_y_continuous() functions. Both functions take an argument called breaks which is a numeric vector specifying the desired breaks on the x and y axes. my_plot + scale_x_continuous(breaks = seq(from = 0, to = 200, by = 25)) + scale_y_continuous(breaks = seq(from = 4, to = 5.5, by = 0.25)) In this example, we have customized the breaks for sugar to be a equally-spaced sequence from 0 to 200 with increment 25, and the breaks for cholesterol to be another equally-spaced sequence from 4 to 5.5 with increment 0.25. When the specified breaks do not cover the full range of the data, you will see the breaks changed but all the data points are still visible. my_plot + scale_x_continuous(breaks = seq(from = 0, to = 150, by = 25)) + scale_y_continuous(breaks = seq(from = 4, to = 4.5, by = 0.25)) On the other hand, if the specified breaks go beyond the value of the data, ggplot() will only show the breaks values within the data range. my_plot + scale_x_continuous(breaks = seq(from = 0, to = 300, by = 25)) + scale_y_continuous(breaks = seq(from = 4, to = 8, by = 0.25)) 5.4.3 Zoom In to a Specific Region of the Data Sometimes, you want to zoom in to the specific region of the data to see a finer detail. To do this, you can use the coord_cartesian() function with arguments xlim and ylim for specifying the desired region. Let’s say we want to focus on the houses with sugar between 25 and 75. my_plot + coord_cartesian(xlim = c(25, 75)) Let’s narrow down further to sugar between 25 and 75 and cholesterol between 4.5 to 5.0. my_plot + coord_cartesian(xlim = c(25, 75), ylim = c(4.5, 5)) 5.4.4 Generate Log-Scale Plot Recall that we generated the following scatterplot between GDP_per_capita and life_expectancy, where we took a logarithm transformation of GDP_per_capita. ggplot(data = gm2004) + geom_point(mapping = aes(x = log10(GDP_per_capita), y = life_expectancy)) For this particular log() transformation, an alternative is to generate a Log-scale Plot by setting the trans argument in the scale_y_continous() function. The log-scale plot is a popular way for displaying numerical data over a very wide range of values in a compact fashion. The default value of trans is \"identity\", meaning no transformation. There are many different trans choices including log, exp, log10, sqrt, and others. ggplot(data = gm2004) + geom_point(mapping = aes(x = GDP_per_capita, y = life_expectancy)) + scale_x_continuous(trans = &quot;log10&quot;) Although the two figures look visually identical, the log-scale plot may be more intuitive to interpret than the plot on the transformed variable on the x-axis. 5.4.5 Coordinate Flip In some situations, you may want to flip the x and y coordinates. To do this, you just need to add coord_flip() to the existing ggplot. In a future section, we will see other type of transformation for coordinates. my_plot + coord_flip() 5.4.6 Exercises Use the sahp data set to answer the following questions. Create a scatterplot between lot_area (x-axis) and sale_price (y-axis), with the breaks on the x-axis being an equally-spaced sequence from 0 to 40000 with increment 5000, and the breaks on the y-axis being (0, 200, 300, 550). And set the labels on the axes to be “Lot Area” and “Sale Price”, and the title to be “Sale Price vs. Lot Area”. Then, apply mytheme to the plot. For the plot in Q1, create a zoom-in plot where lot_area is between 10000 and 15000, and sale_price is between 200 and 300. For the plot in Q1, create a corresponding log-log plot, where both the x-axis and y-axis are in log-scale. "],["line-plot.html", "5.5 Line Plots", " 5.5 Line Plots In this section, we will introduce the line plot, which is very useful for visualizing trends and often used in time series. Let’s work on the sahp dataset, where we would like to study the trend of the sale price as a function of the sold date of the house. 5.5.1 Line Plots via plot() To generate a line plot, you can use the plot() function by setting the argument type = \"l\". library(r02pro) plot(sahp$dt_sold, sahp$sale_price, type = &quot;l&quot;) Wow, this doesn’t look pretty at all. The reason that we get such a chaotic plot is due to the working mechanism of plot(). The plot() works by first getting the location of the value pairs of dt_sold and sale_price. Then, connect the points in the order of the observations. As a result, before calling the plot() function, you need to first sort the observations (in Section 2.7) according to the variable on the x-axis, which is dt_sold in this example. dt_sold_order &lt;- order(sahp$dt_sold) plot(sahp$dt_sold[dt_sold_order], sahp$sale_price[dt_sold_order], type = &quot;l&quot;, xlab = &quot;Date Sold&quot;, ylab = &quot;Sale Price&quot;) Note that here we added the labels for the x and y axes like we did for scatterplots. In the line plots, we would like to introduce two additional graphical parameters that we can customize in the plot() function. Parameter Meaning Example lty The line type “dashed” lwd The line width 2 The line type can be either a integer from 0 to 6 or the corresponding character string, which is summarize in the following figure. Figure 5.3: All Possible Line Types Let’s see an example with the two parameters. plot(sahp$dt_sold[dt_sold_order], sahp$sale_price[dt_sold_order], type = &quot;l&quot;, xlab = &quot;Date Sold&quot;, ylab = &quot;Sale Price&quot;, lty = 2, lwd = 2) The plot() function also offers the capability to show the points and line on the same plot by changing type = \"b\". plot(sahp$dt_sold[dt_sold_order], sahp$sale_price[dt_sold_order], type = &quot;b&quot;, xlab = &quot;Date Sold&quot;, ylab = &quot;Sale Price&quot;) 5.5.2 Line Plots via geom_line() In addition to the plot() function in base R, we can use the geom_line() function in the ggplot family. library(tidyverse) ggplot(data = sahp) + geom_line(mapping = aes(x = dt_sold, y = sale_price)) The generated line plot looks essentially the same as that generated by plot(). It is worth noting that here, the points are connected not by the order of the observations, but by the values of the variable on the x-axis, i.e. dt_sold, which avoids the need to sort the observations by the x-axis. 5.5.3 Constant-Valued Aesthetics in Line Plots Like in Scatterplots, you can also set Constant-Valued Aesthetics (see Section 5.2) in line plots. a. Color We can change the color of the line by setting the color aesthetic to a constant value. ggplot(data = sahp) + geom_line(mapping = aes(x = dt_sold, y = sale_price), color = &quot;red&quot;) b. Line Type One useful aesthetic in geom_line() that was not applicable in geom_point() is linetype, which controls the line type. The collection of different line types is available in Figure 5.3. ggplot(data = sahp) + geom_line(mapping = aes(x = dt_sold, y = sale_price), linetype = &quot;dashed&quot;) c. Size Similar to scatterplots, you can also set the size aesthetic in a line plot. While the size controls the size of the points in a scatterplot, the size aesthetic controls the width of the line. ggplot(data = sahp) + geom_line(mapping = aes(x = dt_sold, y = sale_price), size = 2) 5.5.4 Mapping Variables to Aesthetics in Line Plots In addition to constant-valued aesthetics, you can also Map Variables to Aesthetics (see Section 5.3) in line plots to highlight different groups. a. Color ggplot(data = sahp) + geom_line(mapping = aes(x = dt_sold, y = sale_price, color = kit_qual)) Here, the observations are divided into groups according to the value of kit_qual and separate line plots are generated for each group, represented by different colors. b. Line Type Similarly, we can also map variables to the linetype aesthetic, which uses different line types for each group. ggplot(data = sahp) + geom_line(mapping = aes(x = dt_sold, y = sale_price, linetype = kit_qual)) 5.5.5 Exercises First, create a data set sahp_2006 by running the following code sahp_2006 &lt;- sahp[format(sahp$dt_sold, &quot;%Y&quot;) &lt; 2007, ] #all houses sold before 2007 Then, use sahp_2006 to answer the following questions. Using plot() to create a line plot of dt_sold (on the x-axis) and sale_price (on the y-axis) to show the trend of the sale price as a function of the sold date of the house, then give title “DS” for the x-axis and title “SP” for the y-axis and make the line to be a “twodash” line. Using the ggplot2 package to create a line plot of dt_sold (on the x-axis) and sale_price (on the y-axis) with different linetypes depending on the value of house_style. "],["smoothline.html", "5.6 Smoothline Fits", " 5.6 Smoothline Fits Now, you know how to create scatterplots and line plots with many possible customizations via specifying different aesthetics. In addition to scatterplots, a very useful type of plots that can capture the trend of pairwise relationship is the smoothline fits. 5.6.1 Creating Smoothline Fits using geom_smooth() To create a smoothline fit, you can use the geom_smooth() function in the ggplot2 package. Let’s say you want to find the trend between cholesterol and sugar in the gm2004 dataset. library(ggplot2) library(r02pro) ggplot(data = gm2004) + geom_smooth(mapping = aes(x = sugar, y = cholesterol)) #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; Perhaps it is helpful to review the code for generating a scatterplot between cholesterol and sugar. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol)) We can see that the only difference between these two codes is the use of different geoms. In fact, the mechanism of geom_smooth() is that it fits a smooth line according to the points of the given variable pair. By default, it uses the loess method (locally estimated scatterplot smoothing), which is a popular nonparametric regression technique. In addition to the smoothline, it also generates a shaded area, representing the confidence interval around the fitted smoothline. 5.6.2 Constant-Valued Aesthetics in Smoothline Fits Just like in scatterplots (Section 5.2), you can also set Constant-Valued Aesthetics for smoothline fits. a. Confidence Interval (Hide or Display) As mentioned before, the default smoothline fit display a confidence interval around the smooth curve. To hide this shaded area, you can add the argument se = FALSE as a Constant-Valued aesthetic. ggplot(data = gm2004) + geom_smooth(mapping = aes(x = sugar, y = cholesterol), se = FALSE) #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; b. Confidence Interval Level The default confidence interval is at 95% level. To control the level, you can set the aesthetic level to a desired value. ggplot(data = gm2004) + geom_smooth(mapping = aes(x = sugar, y = cholesterol), level = 0.9) #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; c. Smoothing Method In addition to the default loess method for smoothline fit, geom_smooth() also provides other smoothing methods. We can set the method aesthetic to change the smoothing method. For example, method = \"lm\" represents a linear line fit. ggplot(data = gm2004) + geom_smooth(mapping = aes(x = sugar, y = cholesterol), method = &quot;lm&quot;) #&gt; `geom_smooth()` using formula = &#39;y #&gt; ~ x&#39; d. Color Similar to Scatterplot, you can also set color to change the color of the line. Note that the color aesthetic is available for almost all geoms. ggplot(data = gm2004) + geom_smooth(mapping = aes(x = sugar, y = cholesterol), color = &quot;violet&quot;) #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; e. Size Similar to Scatterplot, you can also set the size aesthetic. While the size controls the size of the points in a scatterplot, the size aesthetic controls the width of the smoothline. ggplot(data = gm2004) + geom_smooth(mapping = aes(x = sugar, y = cholesterol), size = 3) #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; f. Line Type Another useful aesthetic that was not applicable in geom_point() is linetype, which controls the linetypes for each smoothline. The collection of different linetypes is available in Figure 5.3. ggplot(data = gm2004) + geom_smooth(mapping = aes(x = sugar, y = cholesterol), linetype = 2) #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; Note that it is common to use multiple constant-valued aesthetics. ggplot(data = gm2004) + geom_smooth(mapping = aes(x = sugar, y = cholesterol), color = &quot;purple&quot;, size = 2, method = &quot;lm&quot;, level = 0.99, linetype = 2) #&gt; `geom_smooth()` using formula = &#39;y #&gt; ~ x&#39; This generates a smoothline fit with purple color, line width 2, linear smoothing, 0.99 confidence level, and dashed line. 5.6.3 Local Aesthetics Mapping in Smoothline Fits As in scatterplots (Section 5.3), you can also map variables to aesthetics in smoothline fits. a. Group When we map a variable to the group aesthetic, geom_smooth will first divide all the data points into different groups according to the variable value, and then fit a separate smoothline for each group. ggplot(data = gm2004) + geom_smooth(mapping = aes(x = sugar, y = cholesterol, group = gender)) #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; You can see that two smoothlines are generated. However, it is not clear from the plot which group each smoothline corresponds to. To better differentiate the two groups, you can map the variable to other aesthetics like color. b. Color As in geom_point(), we can map the variable to the color aesthetic. ggplot(data = gm2004) + geom_smooth(mapping = aes(x = sugar, y = cholesterol, color = gender)) #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; This is a more informative plot than the one using group aesthetic as you can see the two smoothlines have different colors according to the value of gender. We can observe that when the value of sugar is low, it appears that female has a larger cholesterol value than male and the difference becomes smaller as the sugar value increases. c. Line Type We can also use different line types to differentiate a variable by the linetype aesthetic. ggplot(data = gm2004) + geom_smooth(mapping = aes(x = sugar, y = cholesterol, linetype = gender)) #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; The plot shows a dashed line for the smoothline corresponding to gender = \"male\", and a solid line for the smoothline corresponding to gender == \"female\". d. Size You can also map gender to the size aesthetic, which controls the width of each smoothline fit. ggplot(data = gm2004) + geom_smooth(mapping = aes(x = sugar, y = cholesterol, size = gender)) #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; Note that similar to geom_point(), you can see a warning message: “Using size for a discrete variable is not advised.” It is worth to mention that shape is not a valid aesthetic for geom_smooth as it doesn’t make sense to talk about the shape of a line. ggplot(data = gm2004) + geom_smooth(mapping = aes(x = sugar, y = cholesterol, shape = gender)) #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; When you try to map a variable to the shape aesthetic, geom_smooth() will show a warning message “Warning: Ignoring unknown aesthetics: shape”, and use the group aesthetic instead. Naturally, you can mix different local aesthetic mappings as well as different constant-valued aesthetics on the same plot. ggplot(data = gm2004) + geom_smooth(mapping = aes(x = sugar, y = cholesterol, color = gender, linetype = gender), size = 2, se = FALSE) #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; 5.6.4 Exercises Using the sahp dataset with the ggplot2 package, answer the following questions. Create a smoothline fit to visualize the relationship between lot_area (on the x-axis) and sale_price (on the y-axis). Create several smoothlines with different colors corresponding to the value of kit_qual to visualize the relationship between lot_area (on the x-axis) and sale_price (on the y-axis). Create smoothlines without confidence interval around and with different linetypes to distinguish whether the house has more than 2 bedrooms to visualize the relationship between lot_area (on the x-axis) and sale_price (on the y-axis) . "],["multi-geom.html", "5.7 ggplot Aesthetics (III): Global Aesthetic Mapping", " 5.7 ggplot Aesthetics (III): Global Aesthetic Mapping So far, you have learned how to create scatterplots using geom_point(), line plots using geom_line(), and smoothline fits using geom_smooth(). It is sometimes useful to combine multiple geoms in the same plot. Let’s first review the scatterplot and smoothline fit between sugar and cholesterol. library(r02pro) library(tidyverse) ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol)) ggplot(data = gm2004) + geom_smooth(mapping = aes(x = sugar, y = cholesterol)) 5.7.1 Multiple geoms To combine multiple geoms, you can simply use + to add them. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol)) + geom_smooth(mapping = aes(x = sugar, y = cholesterol)) #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; As expected, you see all the points and the smoothline fit on the same plot, which contains very rich information. As usual, you can add aesthetics to both geoms. Let’s first map gender to the color aesthetic for geom_smooth(). ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol)) + geom_smooth(mapping = aes(x = sugar, y = cholesterol, color = gender)) #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; To verify the two smoothline fits are indeed fitted from the data points in the two groups, you can map gender to the color aesthetic for geom_point() as well. In addition, let’s also map population to the size aesthetic. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol, color = gender, size = population)) + geom_smooth(mapping = aes(x = sugar, y = cholesterol, color = gender)) #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; The plot is reassuring that the two smoothline fits indeed correspond to the data points in the two groups defined by gender. In addition to mapping variables to aesthetics, you can also add Constant-Valued aesthetics for each geom. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol, color = gender, size = population), shape = 2, alpha = 0.9) + geom_smooth(mapping = aes(x = sugar, y = cholesterol, color = gender), linetype = 2, se = FALSE) #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; Now, let’s see an example of combining the scatterplot with the line plot using the sahp dataset. Let’s focus on the houses that were sold before 2007. sahp_2006 &lt;- sahp[format(sahp$dt_sold, &quot;%Y&quot;) &lt; 2007, ] #all houses sold before 2007 ggplot(data = sahp_2006) + geom_line(mapping = aes(x = dt_sold, y = sale_price)) Next, we will add the line plot on top of the scatterplot. ggplot(data = sahp_2006) + geom_line(mapping = aes(x = dt_sold, y = sale_price)) + geom_point(mapping = aes(x = dt_sold, y = sale_price)) Clearly, having both the scatterplot and the line plot make the plot more informative. 5.7.2 Global Aesthetic Mapping In Sections 5.2 and 5.3, we introduced the Constant-Valued Aesthetics and Local Aesthetic Mapping. Now, we are going to introduce the final way of specifying aesthetics, namely the Global Aesthetic Mapping. In contrast to the local aesthetic mapping where the mapping only works at the local level, the global aesthetic mapping will impact all the geoms considered in the entire ggplot. Let’s take another look at the example where we have a scatterplot and a smoothline fit for the relationship between cholesterol and sugar. ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol)) + geom_smooth(mapping = aes(x = sugar, y = cholesterol)) You may notice that the arguments inside geom_point() and geom_smooth() are identical. The global aesthetic mapping allows us to simplify codes by specifying the mapping only once at the ggplot() level. Let’s take a look at how it works. ggplot(data = gm2004, mapping = aes(x = sugar, y = cholesterol)) + geom_point() + geom_smooth() Clearly, this code is simpler to read and avoid repetition. As another example, for the combination of scatterplot and line plot, we can also take advantage of the global aesthetic mapping. ggplot(data = sahp_2006, mapping = aes(x = dt_sold, y = sale_price)) + geom_line() + geom_point() Naturally, we can add additional aesthetic mappings to the aes() function. ggplot(data = gm2004, mapping = aes(x = sugar, y = cholesterol, color = gender)) + geom_point() + geom_smooth() #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; 5.7.2.1 Extend Global Aesthetic Mappings In addition to the global aesthetic mappings, you can add additional local aesthetic mappings to each geom. ggplot(data = gm2004, mapping = aes(x = sugar, y = cholesterol, color = gender)) + geom_point(mapping = aes(size = population)) + geom_smooth() #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; Here, the global aesthetic mapping x = sugar, y = cholesterol, and color = gender are passed to geom_point() and geom_smooth(). And we have an additional local aesthetic mapping size = population for geom_point(). 5.7.2.2 Overwrite Global Aesthetic Mappings When you add the same aesthetic mapping in the local geom as one of the global mappings, the corresponding global aesthetic mapping will be overwritten. ggplot(data = gm2004, mapping = aes(x = sugar, y = cholesterol, color = gender)) + geom_point(mapping = aes(color = continent)) + geom_smooth() #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; Here, the global aesthetic mapping color = gender is first passed to both geom_point() and geom_smooth(). However, since there is a local aesthetic mapping for color (color = continent) in geom_point(), the local aesthetic mapping will overwrite the global one, resulting countries in different continents having different colors. Note that the legend may look a bit weird as it contains a mix of values for continent and gender under the name gender. This is an artifact of the ggplot implementation. As a result, it is recommended to avoid this kind of overwriting behavior. 5.7.2.3 No Global Constant-Valued Aesthetics Let’s review the difference between the Constant-Valued Aesthetic and the Global Aesthetic Mapping. The constant-valued aesthetic sets the aesthetic value for all points/lines on the graph (for example, color = red will make all points red) for a single geom. It doesn’t interfere with the other geoms. The global aesthetic mapping is an aesthetic mapping (for example, color = gender will use different colors for different gender values) that will be passed into all available geoms considered in the single plot. It is worth noting that we can’t set the constant-valued aesthetic at the global level, i.e.there is no Global Constant-Valued Aesthetics. Let’s try to change all the points and lines to purple by adding color = \"purple\" in ggplot(). ggplot(data = gm2004, mapping = aes(x = sugar, y = cholesterol), color = &quot;purple&quot;) + geom_point() + geom_smooth() #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; As you can see from the output, the argument color = \"purple\" was ignored during the plotting process. To achieve this, you need to use color = \"purple\" as constant-valued aesthetics for both geoms as below. ggplot(data = gm2004, mapping = aes(x = sugar, y = cholesterol)) + geom_point(color = &quot;purple&quot;) + geom_smooth(color = &quot;purple&quot;) #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; 5.7.2.4 Mixing the three types of aesthetics Now, let’s see an example where all three types of aesthetics are used. ggplot(data = gm2004, mapping = aes(x = sugar, y = cholesterol)) + geom_point(mapping = aes(size = population), color = &quot;magenta&quot;) + geom_smooth(mapping = aes(color = gender), se = FALSE) #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; 5.7.3 Exercises Using the sahp dataset in the r02pro package, using the ggplot2 package to answer the following questions. With lot_area on the x-axis and sale_price on the y-axis, create a plot that contains both the scatterplot and smoothline fits, where we use different colors in the scatterplot to distinguish whether heat_qual is excellent and different linetypes for the smoothline fits depending on whether house_style is 2Story. Create a plot of liv_area (on the x-axis) and sale_price (on the y-axis) that contains both the scatterplot and the smoothline fit. In the plot from Q2, using different colors for both the scatterplot and the smoothline fit to distinguish whether the house has more than 3 bedrooms and make all points to be size 2. If you run the following code ggplot(data = sahp, mapping = aes(x = liv_area, y = sale_price), color = &quot;green&quot;) + geom_point() + geom_smooth() Do you think all the points and the smoothline will be green? If not, explain the reason and make them green. Run ggplot(data = sahp, mapping = aes(x = liv_area, y = sale_price, color = house_style)) + geom_point(mapping = aes(color = bedroom &gt; 3)) + geom_smooth(mapping = aes(color = bedroom &gt; 3)) Explain why you only see two colors in the plot although the house_style is mapped to color? "],["bar-charts.html", "5.8 Bar Charts and Pie Charts via geom_bar()", " 5.8 Bar Charts and Pie Charts via geom_bar() For visualizing the relationship between two continuous variables, we have learned various kinds of plots, including scatterplot (Sections 5.1 - 5.3), line plot (Section 5.5), and smoothline fit (Section 5.6), In this section, we will introduce two new kinds of plots for discrete variables, called bar chart and pie chart. A bar chart uses rectangular bars with heights or lengths proportional to the values they represent, in order to visualize a discrete variable. A pie chart divides a circle into slices to represent numerical proportions. 5.8.1 An Introduction to Bar Chart In the sahp dataset, you may be interested in the distribution of kitchen quality of the house (denoted in the kit_qual variable). To generate a bar chart, you can use the function geom_bar(). library(ggplot2) library(r02pro) ggplot(data = sahp) + geom_bar(mapping = aes(x = kit_qual)) In the bar chart, the x-axis displays different values of kit_qual, and the y-axis displays the number of observations with each kit_qual value. To verify this, let’s check how many house have kit_qual equals “Excellent”. sum(sahp$kit_qual == &quot;Excellent&quot;) #&gt; [1] 14 We can see the answer 14 matches the value on the bar chart. You may have noticed that the y-axis count is not a variable in sahp! This is also the reason that we don’t need to specify the y argument in the aes() function. In this sense, bar charts are very different from many other graphs like scatterplots, which plot the raw values of datasets. Sometimes, we would like to find out the proportion for each value of x, then we can display a bar chart of proportion, rather than count. To do this, we need to add y = after_stat(prop) and group = 1 as additional arguments in the aes() function. The after_stat(prop) is a statistical function used to calculate proportions. The group = 1 implies that all the observations belong to one single group when calculating the proportions. We will try to set group to another variable in the next part. ggplot(data = sahp) + geom_bar(mapping = aes(x = kit_qual, y = after_stat(prop), group = 1)) In addition to relying on geom_bar() to compute the frequencies or the proportions, we can also manually use the frequencies or proportions if we have the information in a data frame. Let’s first create a data frame that contains the frequencies and proportions of each kit_qual value. freq &lt;- table(sahp$kit_qual) prop &lt;- freq/nrow(sahp) kit_qual_stat &lt;- data.frame(kit_qual = names(freq), freq = as.vector(freq), prop = as.vector(prop)) kit_qual_stat #&gt; kit_qual freq prop #&gt; 1 Average 85 0.51515152 #&gt; 2 Excellent 14 0.08484848 #&gt; 3 Fair 9 0.05454545 #&gt; 4 Good 57 0.34545455 Now, you can directly use the data frame kit_qual_stat to generate the bar chart. Here, you need to set x = kit_qual and y = freq in aes(), and stat = \"identity\" as an argument in the geom_bar() function. To use proportions instead of frequencies, you can use y = prop instead of y = freq. ggplot(kit_qual_stat) + geom_bar(aes(x = kit_qual, y = freq), stat = &quot;identity&quot;) ggplot(kit_qual_stat) + geom_bar(aes(x = kit_qual, y = prop), stat = &quot;identity&quot;) You can easily check that the plots are identical to the previous bar charts. 5.8.2 Reordering Bars in Bar Charts In our bar chart example, the bars are ordered alphabetically by default. Sometimes, we may want to reorder the bars according to certain criterion. a. Reorder in ascending/descending order of heights To order the bars in ascending/descending order of their heights, you can use the fct_reorder() function in the forcats package to reorder the factor. library(forcats) ggplot(data = sahp) + geom_bar(mapping = aes(x = fct_reorder(kit_qual, kit_qual, length))) #increasing order The above code reorders the bar chart to the increasing order of their heights. The fct_reorder() is a very powerful function used to reorder the levels of a factor according to a certain criterion. The function fct_reorder(.f, .x, .fun = median) has three arguments: .f: the discrete variable/factor to reorder .x: one variable .fun: the function to be applied to .x The levels of f are reordered so that the values of .fun(.x) are in ascending order. In our example, we reorder the levels of kit_qual such that the length of kit_qual is in ascending order, i.e. the bars are in ascending order of their heights. To reorder in descending order of heights, you can add an additional argument .desc = TRUE in the fct_reorder() function. ggplot(data = sahp) + geom_bar(mapping = aes(x = fct_reorder(kit_qual, kit_qual, length, .desc = TRUE))) #decreasing order b. Manual Reorder In addition to reordering according to certain function values, you can use the function fct_relevel() to manually reorder the bars in a bar chart. In our example of kit_qual, perhaps a common thought is to order the levels from the worst quality to the best quality. ggplot(data = sahp) + geom_bar(mapping = aes(x = fct_relevel(kit_qual, c(&quot;Fair&quot;, &quot;Average&quot;, &quot;Good&quot;, &quot;Excellent&quot;)))) As you can imagine, the second argument of fct_relevel() contains the desired order of the factors, which will be reflected in the order of the bars. 5.8.3 Aesthetics in Bar Charts As before, we can use aesthetics to control the appearance of bar charts. First, let’s look at a new aesthetic called fill, which fills the bar with different colors according to the value of the mapped variable (usually another discrete variable). From this section on, we will not separately discuss the constant-valued aesthetics and aesthetics mappings. If necessary, you are welcome to review the previous sections on aesthetics for scatterplots, line plots, and smoothline fits. Here, we want to look at the distribution of kit_qual for different values of central_air. ggplot(data = sahp) + geom_bar(mapping = aes(x = kit_qual, fill = central_air)) We can see that each bar is divided into stacked sub-bars with different colors. The different colors in each sub-bar correspond to the value of central_air. And the height of each sub-bar represents the count for the cases with a particular value of kit_qual and another value of central_air. Let’s verify the first bar. sum(sahp$kit_qual == &quot;Average&quot; &amp; sahp$central_air == &quot;Y&quot;) #&gt; [1] 74 Clear, the result matches the blue portion of the first bar. When we map a variable to the fill aesthetic, the appearance of different subbars can be customized using the position argument as a constant-valued aesthetic in geom_bar(). a. Stacked Bars The default value of the position argument is \"stack\", which generated a collection of stacked bars with different colors. ggplot(data = sahp) + geom_bar(mapping = aes(x = kit_qual, fill = central_air), position = &quot;stack&quot;) b. Dodged Bars Using the stacked bars, it is sometimes difficult to compare the counts for different sub-bars. To make the comparison easier, you can use position = \"dodge\". ggplot(data = sahp) + geom_bar(mapping = aes(x = kit_qual, fill = central_air), position = &quot;dodge&quot;) Now, the plot places the sub-bars beside one another, which makes it easier to compare individual counts for each combination of kit_qual and central_air. c. Filled Bars ggplot(data = sahp) + geom_bar(mapping = aes(x = kit_qual, fill = central_air), position = &quot;fill&quot;) position = \"fill\" works like stacking, but makes each set of stacked bars the same height. Perhaps the y axis should be labeled as “proportion” rather than “count”. This makes it easier to compare proportions of different values of central_air for different values of kit_qual. For example, we can see that the proportion of central_air = TRUE is much higher for kit_qual = \"Good\" than that for kit_qual = \"Fair\". Lastly, you can also use the polar coordinates. ggplot(data = sahp) + geom_bar(mapping = aes(x = kit_qual)) + coord_polar() 5.8.4 Pie Charts It turns out pie charts can be generated in a similar fashion as bar charts, by adding an argument in the geom_bar() function. Let’s try to generate a pie chart for kit_qual. The idea is to first generate a single stacked bar with each sub-bar corresponding to different kit_qual values. ggplot(kit_qual_stat) + geom_bar(aes(x = &quot;&quot;, y = prop, fill = kit_qual), stat = &quot;identity&quot;) Then, to get a pie chart, you just need to add an additional layer to change the coordinates from Cartesian coordinates into polar coordinates using the coord_polar() function. ggplot(kit_qual_stat, aes(x = &quot;&quot;, y = prop, fill = kit_qual)) + geom_bar(stat = &quot;identity&quot;) + coord_polar(&quot;y&quot;) + theme_void() Sometimes, you may want to add texts on to the pie chart to represent the percentages of each category. You can do that by using the geom_text() function with label and position arguments specified. ggplot(kit_qual_stat, aes(x = &quot;&quot;, y = prop, fill = kit_qual)) + geom_bar(stat = &quot;identity&quot;) + geom_text(aes(label = round(100*prop, 2)), position = position_stack(vjust = 0.5)) + coord_polar(&quot;y&quot;) + theme_void() 5.8.5 Exercises Use the sahp data set to answer the following questions. Create a bar chart to represent the distribution of the number of available car spaces in the garage (gar_car). For the bar chart in Q1, divide each bar into sub-bars according to whether oa_qual &gt; 5. What findings do you have in this plot? For the bar chart in Q2, change the position of the sub-bar to reflect the proportion for oa_qual &gt; 5 for each value of gar_car. Create a pie chart to represent the distribution of the number of available car spaces in the garage (gar_car) with the corresponding percentages displays inside the pie chart. "],["histogram.html", "5.9 Histograms", " 5.9 Histograms In Section 5.8, we learned how to use geom_bar() to generate bar charts for visualizing the distributions of discrete variables. You may be wondering, how about visualizing continuous variables? One popular plot is called histograms. In this section, we will return to the gm2004 data set. 5.9.1 Using the hist() function To generate a histogram, you can simply use hist() with the variable as the argument. library(r02pro) hist(gm2004$cholesterol) On the x-axis, the histogram displays the range of values for the cholesterol value. Then, the histogram divides the x-axis into bins with equal width, and a bar is erected over the bin with the y-axis showing the corresponding number of observations (called Frequency on the y-axis label). 5.9.2 Using the geom_histogram() function In addition to using the hist() function in base R. The geom_histogram() function in the ggplot2 package provides richer functionality. Let’s take a quick look. library(ggplot2) ggplot(data = gm2004) + geom_histogram(mapping = aes(x = cholesterol)) #&gt; `stat_bin()` using `bins = 30`. #&gt; Pick better value with `binwidth`. We could see a message, saying “stat_bin() using bins = 30” which implies the histogram has 30 bins by default. Next, we introduce three different ways to customize the bins. a. Use Aesthetic bins. We can change the number of bins with the constant-valued aesthetic bins. ggplot(data = gm2004) + geom_histogram(mapping = aes(x = cholesterol), bins = 5) We can see that the histogram now has 5 bins and each bin has the same width. b. Use Aesthetic binwidth. And from the message, another way to change the number of bins is to specify the binwidth, which is another constant-valued aesthetic. ggplot(data = gm2004) + geom_histogram(mapping = aes(x = cholesterol), binwidth = 0.2) c. Manually Set the Bins. If desired, you can manually set the bins via the breaks argument in the geom_histogram() function. ggplot(data = gm2004) + geom_histogram(mapping = aes(x = cholesterol), breaks = seq(from = 3.5, to = 6, by = 0.5)) The breaks argument is a numeric vector specifying how the bins are constructed. Let’s verify the height of the first bin. #verify the first bin count sum(gm2004$cholesterol &lt; 4, na.rm = TRUE) #&gt; [1] 15 The number matches to the height of the first bin. Not that we need to add na.rm = TRUE as an argument since there are missing values. 5.9.3 Aesthetics in geom_histogram() Next, we introduce the aesthetics in histograms, which are very similar to those in bar charts. For example, we can map a variable to the fill aesthetic. ggplot(data = gm2004) + geom_histogram(mapping = aes(x = cholesterol, fill = gender), bins = 5) We can see that like the bar chart, the bar for each bin is now divided into sub-bars with different colors. The different colors in each sub-bar correspond to the values of gender. And the height of each sub-bar represents the count for the cases with the cholesterol in this particular bin and the specific value of gender. We observe that while the male and female group behave similarly in the middle bins, many more countries has a small mean cholesterol value for males than those for females. Just like geom_bar(), we have a global aesthetic called position, which does position adjustment for different sub-bars. The default position value is again \"stack\" if you don’t specify it. a. Stacked Bars ggplot(data = gm2004) + geom_histogram(mapping = aes(x = cholesterol, fill = gender), position = &quot;stack&quot;, bins = 5) As expected, we get the same histogram as before. b. Dodged Bars The second option for position is \"dodge\", which places the sub-bars beside one another, making it easier to compare individual counts for the combination of a bin of cholesterol and gender. ggplot(data = gm2004) + geom_histogram(mapping = aes(x = cholesterol, fill = gender), position = &quot;dodge&quot;, bins = 5) c. Filled Bars Another option for optional is position = \"fill\". It works like stacking, but makes each set of stacked bars the same height. ggplot(data = gm2004) + geom_histogram(mapping = aes(x = cholesterol, fill = gender), position = &quot;fill&quot;, breaks = seq(from = 3.5, to = 6, by = 0.5)) Just like geom_bar(), the y axis may be labeled as “proportion” rather than “count”, to be more precise. This makes it easier to compare proportions of different values of gender for different bins of cholesterol. For example, we can see that the proportion of gender = \"male\" is 100% for cholesterol values smaller than 4. 5.9.4 Density Estimate Using Histograms In addition to using histograms to visualize the distribution of a discrete variable, you can also construct a density density of variable using a proper normalization. To generate such a density estimate, you can add y = ..density.. as a mapping in the aes() function in geom_historgram(). Let’s see an example as below. ggplot(data = gm2004) + geom_histogram(mapping = aes(x = cholesterol, y = ..density..), breaks = seq(from = 3.5, to = 6, by = 0.5)) Let’s try to calculate the height of the first bar together. We know that the total area of the bars is 1, agreeing with the definition of density. First, we get the area of the first bar. Then we divide it by the width to get the height. cholesterol_no_na &lt;- na.omit(gm2004$cholesterol) sum(cholesterol_no_na &lt; 4)/length(cholesterol_no_na) #area of the first bar #&gt; [1] 0.03768844 sum(cholesterol_no_na &lt; 4)/length(cholesterol_no_na) /0.5 #height of the first bar #&gt; [1] 0.07537688 You can see that the height matches the y axis for the first bar. 5.9.5 Exercises Use the sahp data set to answer the following questions. Create three different histograms on the living area (liv_area) for each of the following settings Use 10 bins Set the binwidth to be 300 Set the bins manually to an equally-spaced sequence from 0 to 3500 with increment 500. Create histograms on the living area (liv_area) with 5 bins, and show the information of different kit_qual values in each bar. What conclusions can you draw from this plot? "],["density-plot.html", "5.10 Density Plots", " 5.10 Density Plots In Section 5.9, we have learned to use geom_histogram() as a way to visualize the distribution of a continuous variable. In addition, we also showed that it can be used to generate a piece-wise constant estimate of the probability density function. Today, we will introduce another popular visualization method for continuous data, namely the density plots. First, let’s review the geom_histogram() for estimating the density function. library(ggplot2) library(r02pro) ggplot(data = gm2004) + geom_histogram(mapping = aes(x = cholesterol, y = ..density..)) #&gt; `stat_bin()` using `bins = 30`. #&gt; Pick better value with `binwidth`. There are 30 bins by default. You may notice that this density estimate is not smooth, sometimes we may prefer a smoothed estimate. Then, we can use the geom_density() function to achieve this. ggplot(data = gm2004) + geom_density(aes(x = cholesterol)) This plot shows the so-called “kernel density estimate”, a popular way to estimate the probability density function from sample. The density estimate can be viewed as a smoothed version of the histogram. We can combine the two plots together using global aesthetic mapping. ggplot(data = gm2004, aes(x = cholesterol)) + geom_histogram(aes(y = ..density..)) + geom_density(color = &quot;red&quot;, size = 2) #&gt; `stat_bin()` using `bins = 30`. #&gt; Pick better value with `binwidth`. Here, we added some global aesthetics in geom_density() to make the density plot red and the line width by setting size = 2. It is clear that the density plot is a useful alternative to the histogram for visualizing continuous data. 5.10.1 Aesthetics in Density Plots Now, let’s introduce some commonly used aesthetics for density plots. a. Color ggplot(data = remove_missing(gm2004, vars = &quot;HDI_category&quot;)) + geom_density(aes(x = cholesterol, color = HDI_category)) Here, we divide the data into four groups according to the value of HDI_category (human development index category), then generate separate density estimates with different colors. It is interesting to observe that the countries with very high HDI values have higher cholesterol values compared with countries with lower HDI values. Here, we can also manually reorder the factor levels just like in Bar Chart: library(forcats) my_gm2004 &lt;- remove_missing(gm2004, vars = &quot;HDI_category&quot;) my_gm2004$HDI_category &lt;- fct_relevel(my_gm2004$HDI_category, c(&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;, &quot;very high&quot;)) ggplot(data = my_gm2004) + geom_density(aes(x = cholesterol, color = HDI_category)) Here, a copy of the original dataset was created with the missing value of HDI_category removed and the level reordered manually. b. Fill Another way to generate different density estimates is to use the fill aesthetic. Let’s see the following example. ggplot(data = remove_missing(gm2004, vars = &quot;HDI_category&quot;)) + geom_density(aes(x = cholesterol, fill = HDI_category)) The fill aesthetic also divides the data into groups according to HDI_category, then generate separate density estimates. The difference between fill and color aesthetics is that fill generates shaded areas below each density curve with different colors while color generates density curves with different colors. As we can see from the plot, there is a substantial overlap of the shaded areas. To fix this issue, we can change the transparency of the shades by adjusting the value of the alpha aesthetic. ggplot(data = remove_missing(gm2004, vars = &quot;HDI_category&quot;)) + geom_density(aes(x = cholesterol, fill = HDI_category), alpha = 0.5) We can now see all shaded areas in a clear way. c. Linetype We can also use different linetypes for different curves. ggplot(data = remove_missing(gm2004, vars = &quot;HDI_category&quot;)) + geom_density(aes(x = cholesterol, linetype = HDI_category)) d. Constant-Valued Aesthetics As usual, we can also set constant-valued aesthetics for geom_density() and combine it with the mapped aesthetics. ggplot(data = remove_missing(gm2004, vars = &quot;HDI_category&quot;)) + geom_density(aes(x = cholesterol, linetype = HDI_category), size = 1, color = &quot;red&quot;) Here, the size controls the width of the density curve. 5.10.2 Exercises Use the sahp data set to answer the following questions. Create density plot on the living area (liv_area) with dashed lines and different colors for different values of kit_qual. What conclusions can you draw from the plot? Try to create density plot for kit_qual. Do you think this plot is informative? If not, create a plot that captures the distribution of kit_qual. "],["boxplots.html", "5.11 Boxplots", " 5.11 Boxplots So far, we have learned two ways to visualize a continuous variable, namely the histograms (Section 5.9) and density plots (Section 5.10). Now, we introduce another popular plot for visualizing the distribution of a continuous variable: the boxplot. Let’s say we want to generate a boxplot for the variable sale_price in the sahp dataset. 5.11.1 Using the boxplot() function To generate a boxplot, you can just use boxplot() with the variable as the argument. library(r02pro) sale_price &lt;- na.omit(sahp$sale_price) boxplot(sale_price) The boxplot compactly summarize the distribution of a continuous variable by visualizing five summary statistics (the median, two hinges, and two whiskers), and show all “outlying” points individually. All five summary statistics on the boxplot are related to the summary statistics we learned in Section 2.8. Let’s first review the summary function and the inter quartile range (IQR). summary(sale_price) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 44.0 130.0 157.9 179.9 201.6 545.2 IQR(sale_price) #&gt; [1] 71.6125 Let’s discuss the five lines on the boxplot. The solid line in the middle represents the median value, which is 157.95. The lower solid line, also known as the lower hinge, is the first quartile Q1 = 129.9625. The upper solid line, also known as the upper hinge, is the third quartile Q3 = 201.575. The lower whisker is the smallest observation value that is greater than or equal to Q1 - 1.5 * IQR. To find this value, we first calculate Q1 - 1.5 * IQR = 22.54375. Then, the smallest observation larger than 22.54375 is lower_whisker_loc &lt;- which(sale_price &gt;= quantile(sale_price, 0.25) - 1.5 * IQR(sale_price)) min(sale_price[lower_whisker_loc]) #&gt; [1] 44 The upper whisker is the largest observation value that is smaller than or equal to Q3 + 1.5 * IQR. Similarly, the value is upper_whisker_loc &lt;- which(sale_price &lt;= quantile(sale_price, 0.75) + 1.5 * IQR(sale_price)) max(sale_price[upper_whisker_loc]) #&gt; [1] 308.03 To summarize, the five lines on the boxplot, from the top to bottom, are upper whisker (&lt;= Q3 + 1.5*IQR) upper hinge (Q3) median (50-th percentile) lower hinge (Q1) lower whisker (&gt;= Q1 - 1.5*IQR) For the observations that are larger than the upper whisker or smaller than the lower whisker, the points are shown individually as outliers. 5.11.2 Using the geom_boxplot() function As before, we will spend more time to discuss geom_boxplot() as it provides more functionality. Let’s first create the boxplot for sale_price. library(tidyverse) ggplot(data = sahp) + geom_boxplot(aes(x = &quot;&quot;, y = sale_price)) Note that here we set x = \"\" since no information is needed on the x-axis. In addition to the default summary statistics, we can add other values to the boxplot, for example, we can add the mean value to the plot. ggplot(data = sahp, aes(x = &quot;&quot;, y = sale_price)) + geom_boxplot() + geom_point(stat = &quot;summary&quot;, fun = &quot;mean&quot;, shape = 20, size = 4, color = &quot;red&quot;) The geom_point() function will first calculate the mean hwy, and add it to the boxplot. Note that we used some global aesthetics for geom_point(). 5.11.3 Compare distributions in different groups One common use of boxplot is to compare the distribution of a continuous variable in different groups. To do this, you just need to set the x-axis to be the discrete variable that encodes the different groups. Let’s say we want to compare the sale_price for houses with different kit_qual. ggplot(data = sahp) + geom_boxplot(aes(x = kit_qual, y = sale_price)) ggplot(data = gm2004 %&gt;% remove_missing(vars=&quot;HDI_category&quot;)) + geom_boxplot(aes(x = HDI_category, y = log(GDP_per_capita))) This plot shows the boxplots of sale_price for different values of kit_qual side-by-side, which makes the comparison of distributions straightforward. Just like in bar charts, you may want to arrange the boxplots in a particular order. For example, to order the boxplots in ascending order of the sale_price, you can use ggplot(data = remove_missing(sahp, vars = &quot;sale_price&quot;)) + geom_boxplot(aes(x = fct_reorder(kit_qual, sale_price, median), y = sale_price)) To order it by the mean sale_price in descending order, you can use ggplot(data = remove_missing(sahp, vars = &quot;sale_price&quot;)) + geom_boxplot(aes(x = fct_reorder(kit_qual, sale_price, mean, .desc = TRUE), y = sale_price)) If you want to generate a flipped version of the boxplot, you can add coord_flip() to the ggplot() function. Actually, this works with any ggplot. ggplot(data = sahp) + geom_boxplot(aes(x = kit_qual, y = sale_price)) + coord_flip() As an alternative, you can also switch the x and y arguments. ggplot(data = sahp) + geom_boxplot(aes(x = sale_price, y = kit_qual)) Now, you have learned how to compare the distributions of a continuous variable for different groups implied by a discrete variable. How about groups implied by a continuous variable? To do this, you can use the function cut_width() to convert a continuous variable to a discrete one by dividing the observations into different groups, just like in histograms. Let’s try to convert the continuous variable oa_qual into a discrete one. cut_width(sahp$oa_qual, width = 2) #&gt; [1] (5,7] (5,7] (3,5] (3,5] (5,7] (5,7] (5,7] (3,5] (3,5] (3,5] #&gt; [11] (5,7] (5,7] (3,5] (7,9] (5,7] (3,5] (3,5] (3,5] (5,7] (5,7] #&gt; [21] (3,5] (7,9] (7,9] &lt;NA&gt; (5,7] (3,5] (3,5] (3,5] (3,5] (7,9] #&gt; [31] (7,9] (7,9] (5,7] (7,9] (5,7] (3,5] (5,7] (5,7] (3,5] (3,5] #&gt; [41] (9,11] (3,5] (3,5] (3,5] (7,9] (3,5] (5,7] (3,5] (5,7] (5,7] #&gt; [51] (3,5] (5,7] (5,7] (3,5] (5,7] (5,7] (7,9] (7,9] (3,5] (5,7] #&gt; [61] (5,7] (5,7] (5,7] (5,7] (3,5] (3,5] (5,7] (5,7] (3,5] (5,7] #&gt; [71] (5,7] (3,5] (7,9] (5,7] (3,5] (7,9] (7,9] (3,5] [1,3] (5,7] #&gt; [81] (5,7] (5,7] (3,5] (5,7] (5,7] (3,5] (3,5] (5,7] (3,5] (3,5] #&gt; [91] (7,9] (5,7] (5,7] (5,7] (5,7] (3,5] (5,7] (3,5] (9,11] (5,7] #&gt; [101] (5,7] (7,9] (3,5] (5,7] (3,5] (5,7] (5,7] (3,5] (3,5] (5,7] #&gt; [111] (5,7] (5,7] (7,9] (7,9] (7,9] (5,7] (7,9] (5,7] (5,7] (5,7] #&gt; [121] (5,7] (5,7] (3,5] (3,5] (5,7] (5,7] (3,5] (7,9] (5,7] (5,7] #&gt; [131] (3,5] (7,9] (5,7] (5,7] (5,7] (5,7] (5,7] [1,3] (3,5] (5,7] #&gt; [141] (3,5] (5,7] (5,7] (3,5] (3,5] (3,5] (3,5] (3,5] (3,5] (5,7] #&gt; [151] (7,9] (7,9] (3,5] (5,7] (7,9] [1,3] (7,9] (7,9] (5,7] (5,7] #&gt; [161] (7,9] (5,7] (3,5] (5,7] (3,5] #&gt; Levels: [1,3] (3,5] (5,7] (7,9] (9,11] The working mechanism of cut_width() is that it makes groups of width width and create a factor with the levels be the different groups. For example, the first observation has oa_qual = 6, belong to the (5,7] group. Note there are also functions cut_interval() and cut_number() which also discretise continuous variable into a discrete one by making groups with equal range and equal number of observations, respectively. Now, you can compare the distributions of a continuous variable on the constructed groups from another continuous variable. ggplot(data = remove_missing(sahp, vars=&quot;oa_qual&quot;)) + geom_boxplot(aes(x = cut_width(oa_qual, width = 2), y = sale_price)) This agrees perfectly with our intuition that houses with higher overall quality have higher sale prices. 5.11.4 Aesthetics in boxplot Before talking about aesthetics, let’s create a boxplot of sale_price for different values of house_style. ggplot(data = na.omit(sahp), aes(x = house_style, y = sale_price)) + geom_boxplot() + scale_x_discrete(limits=c(&quot;1Story&quot;, &quot;2Story&quot;)) Note that we only show the two boxplots with house_style equaling \"1Story\" or \"2Story\". To simply the codes, it is sometimes helpful to store the intermediate plot object and build additional plots on top of it. For example, we can generate the same boxplot using the following two steps. g &lt;- ggplot(data = na.omit(sahp), aes(x = house_style, y = sale_price)) + scale_x_discrete(limits=c(&quot;1Story&quot;, &quot;2Story&quot;)) g + geom_boxplot() a. Map the grouping variable to color First, let’s try to map the variable house_style to the color aesthetic. g + geom_boxplot(mapping = aes(color = house_style)) We can see that the boxplots have different colors according to the value of house_style. b. Map the grouping variable to fill You can also use the fill aesthetic to fill in the boxes with different colors according to the value of house_style. g + geom_boxplot(mapping = aes(fill = house_style)) c. Map a third variable to color So far, we have only mapped the discrete variable on the x-axis to the aesthetic. You can map a third variable to an aesthetic if a further refined comparision is needed. Let’s try to map the oa_qual &gt; 5 to color. g + geom_boxplot(mapping = aes(color = oa_qual &gt; 5)) You will get a boxplot for each combination of house_style and oa_qual grouped by the variable house_style, just like when we create the bar charts in Section 5.8. As before, you can also cut a continuous variable and map it to aesthetic. g + geom_boxplot(mapping = aes(color = cut_width(oa_qual, 2))) d. Map a third variable to fill Similarly, you can also map the variable to the fill aesthetic. g + geom_boxplot(mapping = aes(fill = oa_qual &gt; 5)) e. Constant-Valued Aesthetics In addition to mapping variables to aesthetics, you can also use Constant-Valued Aesthetics in boxplot. For example, to make the box green and the lines and points red, you can use g + geom_boxplot(fill = &quot;green&quot;, color = &quot;red&quot;) If you want to change the shape and size of the outliers, you can set the arguments outlier.shape and outlier.size. g + geom_boxplot(outlier.color = &quot;green&quot;, outlier.shape = 2, outlier.size = 3) 5.11.5 Notched Boxplots In addition to the regular boxplot, there is a more sophisticated version, called notched boxplot. We can generate such a boxplot by setting the global aesthetic notch = TRUE in the geom_boxplot() function. ggplot(data = sahp) + geom_boxplot(aes(x = &quot;&quot;, y = sale_price), notch = TRUE) In a notched box plot, a notch is generated around the median, with the vertical width on each side being 1.58 times IQR divided by the squared root of the sample size: \\(1.58 * IQR / sqrt(n)\\). This gives a roughly 95% confidence interval for the median. As a result, if the notches of two boxplots do not overlap, it offers evidence of a statistically significant difference between the two medians. In this example, the upper and lower points of the notch are median(sale_price) + 1.58*IQR(sale_price)/sqrt(length(sale_price)) #&gt; [1] 166.7854 median(sale_price) - 1.58*IQR(sale_price)/sqrt(length(sale_price)) #&gt; [1] 149.1146 5.11.6 Exercises Use the sahp data set to answer the following questions. Create a boxplot on the living area (liv_area) and find out the following values on the boxplot using R codes. solid line in the middle lower hinge upper hinge lower whisker upper whisker Create a boxplot to compare the distribution of living area (liv_area) for different values of kitchen quality (kit_qual). What conclusions can you draw from the plot? For the boxplot in Q2, for different kit_qual values, add the following three points to the plot. minimum liv_area value (in red) maximum liv_area value (in blue) the mean liv_area value (in green) For the boxplot in Q2, order it by the mean lot_area value in ascending order. For the boxplot in Q2, use different colors to represent whether oa_qual is larger than 5. "],["arrange-multi-plots.html", "5.12 Arrange Multiple Plots", " 5.12 Arrange Multiple Plots So far, you have mastered many geoms, and you know one popular way to add the information of additional variables to a plot is mapping them to certain aesthetics. Another way to achieve this goal is to divide the data into different groups according to the additional variables, generate different plots for each group, and arrange the plots into facets. This is particularly useful for categorical variables. Let’s use the sahp dataset and generate a scatterplot for sale_price vs. liv_area and save it as g. library(ggplot2) library(r02pro) g &lt;- ggplot(data = na.omit(sahp)) + geom_point(mapping = aes(x = liv_area, y = sale_price)) 5.12.1 Facet wrap The first function is called facet_wrap(), which generate separate plots for each category and wrap the plots into 2d panels. Let’s first divide to data according to oa_qual. g + facet_wrap(&quot;oa_qual&quot;) You can see that there are nine different scatterplots between sale_price and liv_area according to the value of oa_qual. The scatterplots are nicely arranged in a 3-by-3 grid with the value of oa_qual on top of each subplot. Note that the scales of all nine plots are the same, which make it straightforward to compare between different groups. On the other hand, the points for some of the groups (e.g., oa_qual == 5) are scrambled together, making us difficult to see the details. To make the subplots having their own scales, you can set scales = \"free\". g + facet_wrap(&quot;oa_qual&quot;, scales = &quot;free&quot;) From the plot, it is clear that each subplot has its own scale depending on the data range in the subset of the data. If you want to make the subplots to have fixed scale only on the x-axis or the y-axis, you can set scales = \"free_y\" or scales = \"free_x\" respectively. In addition to the default layout, you can set the desired number of rows or columns. For example, to arrange the plots in two rows for the variable kit_qual, you can use g + facet_wrap(&quot;kit_qual&quot;, nrow = 2) In addition to using one variable to form the subgroups, you can also use multiple variables by using a vector of their names in the facet_wrap() function. g + facet_wrap(c(&quot;kit_qual&quot;,&quot;central_air&quot;)) This will show the plots for combinations of kit_qual and central_air. For example, the top left plot is the scatterplot between liv_area and sale_price for houses with kit_qual == \"Average\" and central_air == \"N\". Let’s find out how many different values are there for kit_qual and central_air. unique(sahp$kit_qual) #&gt; [1] &quot;Good&quot; &quot;Average&quot; &quot;Fair&quot; &quot;Excellent&quot; unique(sahp$central_air) #&gt; [1] &quot;Y&quot; &quot;N&quot; Clearly, there are in total eight possible combinations of values for these two variables. Upon a careful look, you may realize there is no plot for kit_qual == \"Excellent\" and central_air == \"N\". The reason is due to the fact there are no houses satisfying both criteria. Let’s verify as follows. sum(sahp$kit_qual == &quot;Excellent&quot; &amp; sahp$central_air == &quot;N&quot;) #&gt; [1] 0 Note that the facet_wrap() function can be combined with any geoms we have learned. Let’s see an example of bar charts. a&lt;- ggplot(data = sahp) + geom_bar(mapping = aes(x = kit_qual)) a + facet_wrap(&quot;house_style&quot;) 5.12.2 Facet grid g + facet_grid(rows = vars(kit_qual), cols = vars(central_air)) In addition to facet wrap, you can also use the function facet_grid() to form a matrix of plots defined by row and column faceting variables. It is mostly useful when you have two discrete variables, and most combinations of the variables exist in the data. Comparing with the plot generated by facet_wrap(), facet_grid() will also show empty plots if there are no observations with certain combinations, e.g. kit_qual == \"Excellent\" and central_air == \"N\". This particular way to arrange plots is very informative. Similar to facet_wrap(), you can also allow the scales of each subplot to be different by setting the scales argument. g + facet_grid(rows = vars(kit_qual), cols = vars(central_air), scales = &quot;free&quot;) 5.12.3 Exercises Use the sahp data set to answer the following questions. Create a boxplot for liv_area and assign it to the name my_boxplot. Using my_boxplot in Q1, generate separate plots according to the value of bedroom. What conclusions can you draw from the plot? Using my_boxplot in Q1, generate a matrix of subplots with kitchen quality (kit_qual) as the row and whether the house has central ac (central_air) as the column. Do you see a subplot for all combinations of kit_qual and central_air? If not, explain the reason. "],["review-basic-visualization.html", "5.13 Review of Basic Visualization", " 5.13 Review of Basic Visualization In this chapter, we have introduced the most commonly used plots for visualization. It is helpful to review what we have learned so far. 5.13.1 Summary of geoms Names Funs Section One continuous variable (e.g. cholesterol or sale_price) Histogram geom_histogram(aes(x = cholesterol)) 5.9 Density Plot geom_density(aes(x = cholesterol)) 5.10 Boxplot geom_boxplot(aes(x = \"\", y = sale_price)) 5.11 One discrete variable (e.g. kit_qual) Bar Chart geom_bar(mapping = aes(x = kit_qual)) 5.8.1 Pie Chart geom_bar(aes(x = kit_qual), stat = \"identity\") + coord_polar(\"y\") 5.8.4 Two continuous variables (e.g. sugar and cholesterol) Scatterplot geom_point(mapping = aes(x = sugar, y = cholesterol)) 5.1 Line Plot geom_line(mapping = aes(x = dt_sold, y = sale_price)) 5.5 Smoothline geom_smooth(mapping = aes(x = sugar, y = cholesterol)) 5.6 Two discrete variables (e.g. kit_qual and central_air): Bar Chart geom_bar(mapping = aes(x = kit_qual, fill = central_air)) 5.8.3 One continuous variable and one discrete variable (e.g. kit_qual and sale_price): Boxplot geom_boxplot(aes(x = kit_qual, y = sale_price)) 5.11.3 5.13.2 The grammatical structure of ggplot() Next, we review the grammatical structure of ggplot(). Code Info ggplot(data = &lt;DATA&gt;) + data to be used &lt;GEOM_FUNCTION&gt;( geom for generating the desirable plot mapping = aes(&lt;MAPPINGS&gt;), aesthetic mappings, this may include the x and y axes and other features like color, shape, fill, linetype, size, etc. stat = &lt;STAT&gt;, statistical transformation, for example, when we create the errorbar position = &lt;POSITION&gt;) + position, like stack, dodge, fill &lt;COORDINATE_FUNCTION&gt; + such as flipping the x and y axes &lt;FACET_FUNCTION&gt; + facet_wrap() and facet_grid(), create multiple plots for different subsets of the data &lt;SCALE_FUNCTION&gt; + customize the x and y breaks &lt;THEME_FUNCTION&gt; customize labels, title, and fonts 5.13.3 A complex ggplot() example To conclude this chapter, let’s look at an example with all components. library(r02pro) library(tidyverse) ggplot(data = na.omit(sahp)) + geom_bar( mapping = aes(x = kit_qual, fill = oa_qual &gt; 5), stat = &quot;count&quot;, #Default stat for geom_bar, can be removed position = &quot;fill&quot;) + coord_flip() + facet_wrap(vars(house_style)) + scale_y_continuous(breaks = seq(from = 0, to = 1, by = 0.2)) + theme(plot.title = element_text(size = 24, color = &quot;magenta&quot;)) + xlab(&quot;Kitchen quality&quot;) + ylab(&quot;Proportion&quot;) + ggtitle(&#39;A bar chart in proportion of kitchen quality&#39;) This plot shows a bar chart using the data sahp for the variable kit_qual, map the variable oa_qual &gt; 5 to the fill aesthetic and with fill position, with the x and y coordinates flipped, faceted using the variable house_style, and with the breaks on the y axis, the title and its font, the label on the y axis being customized. "],["adv-visual.html", "Chapter 6 Advanced Data Visualization", " Chapter 6 Advanced Data Visualization In Chapter 5, we introduced the most commonly used plots. If you skipped the previous chapter, it may be worthwhile to briefly review Section 5.13. In this chapter, we will introduce more types of plots and various customization. "],["jitter-count.html", "6.1 Jitter and Count Plots", " 6.1 Jitter and Count Plots In Section 5.1, we have seen that scatterplot is a useful tool to visualization the relationship between two continuous variables. You may be wondering what will happen if we use it on two discrete variables. 6.1.1 Overplotting As an example, let’s look at the gm2004 dataset, and generate a scatterplot between continent and HDI_category. library(r02pro) library(tidyverse) ggplot(data = remove_missing(gm2004, vars = c(&quot;continent&quot;, &quot;HDI_category&quot;))) + geom_point(mapping = aes(x = continent, y = HDI_category)) #overplotting From the plot, you may immediately realize that there are many possible overlapping data points. Indeed, there will be at most 20 distinct points on the plot since there are 5 continents and 4 different HDI categories. This phenomenon is called overplotting. Overplotting is not desirable since it hides useful information about the joint distribution. For example, we don’t know which value pairs out of the 20 possibilities appear more frequently in the data. To solve the overplotting issues, we introduce two solutions, namely jittering and count plots. 6.1.2 Jittering The first method for solving the overplotting issue is to add a small random perturbation to all datapoints, i.e., jittering. You can use the geom_jitter() function which works by first perturb the data points and then generate a scatterplot. ggplot(data = remove_missing(gm2004, vars = c(&quot;continent&quot;, &quot;HDI_category&quot;))) + geom_jitter(mapping = aes(x = continent, y = HDI_category)) For the jittered plot, we can clearly see which pair of continent and HDI_category have more observations. By default, the perturbation will be performed both vertically and horizontally with the same amount of 40% of the resolution of the data. To customize the amount of jittering, you can specify the arguments width as the amount of horizontal jittering and height as the amount of vertical jittering in the unit of the resolution of the data. To turn off the horizontal jittering, you can specify width = 0. ggplot(data = remove_missing(gm2004, vars = c(&quot;continent&quot;, &quot;HDI_category&quot;))) + geom_jitter(mapping = aes(x = continent, y = HDI_category), width = 0.1, height = 0.1) Now, we can see that Africa has a large number of countries with low HDI category while Europe has almost all countries in the high or very high HDI category. 6.1.3 Counts Plots When we want to visualize the distribution of a pair of discrete variables, another method to solve the overplotting issue is the counts plot, which uses circles of different sizes to represent the frequency of each value pair. You can use the function geom_count() to generate a counts plot. ggplot(data = remove_missing(gm2004, vars = c(&quot;continent&quot;, &quot;HDI_category&quot;))) + geom_count(mapping = aes(x = continent, y = HDI_category), width = 0.1, height = 0.1) From this plot, you can clearly tell the frequency of each value pair by the legend showing the relationship between the size of the circle and the count. 6.1.4 Exercises For the sahp dataset, answer the following questions. Create a scatterplot between bedroom and bathroom. What issue do you think this plot have? Provide two different plots to address this issue. "],["violin.html", "6.2 Violin Plots", " 6.2 Violin Plots In this section, we introduce how to combine music with R via creating violin plots. In fact, the violin plot elegantly combines density plot (Section 5.10) and boxplot (Section 5.11) and into a single plot. 6.2.1 The basic violin plot Let’s say we want to generate a basic violin plot for the variable cholesterol in the gm2004 dataset. library(r02pro) library(ggplot2) ggplot(data = gm2004, aes(x = &quot;&quot;, y = cholesterol)) + geom_violin() To introduce the detail of the generation process of violin plot, it is helpful to review the density plot. ggplot(data = gm2004, aes(y = cholesterol)) + geom_density() Looking at these two plots, it is easy to see that the basic violin plot is nothing but a Mirrored Density Plot with the kernel density estimates on each side. 6.2.2 Violin plot with boxplot Usually, the violin plot includes the boxplot inside it, providing extra information about the data. To do this, we just add the boxplot layer on top of the violin plot. ggplot(data = gm2004, aes(x = &quot;&quot;, y = cholesterol)) + geom_violin() + geom_boxplot(width = 0.1) Here, we set the aesthetic width = 0.1 in the boxplot to make it thinner. Just like in the boxplot, we can compare the distributions of a continuous variable for different values of a discrete variable. We can achieve this by mapping the discrete variable to the x axis. ggplot(data = gm2004, aes(x = continent, y = cholesterol)) + geom_violin() + geom_boxplot(width = 0.1) We can restrict the x-axis to a subset of the possible continent values. ggplot(data = gm2004, aes(x = continent, y = cholesterol, color = continent)) + geom_violin() + geom_boxplot(width = 0.1) + scale_x_discrete(limits=c(&quot;Africa&quot;, &quot;Americas&quot;, &quot;Asia&quot;)) Similarly, we can map a third variable to an aesthetic. ggplot(data = gm2004, aes(x = continent, y = cholesterol, fill = gender)) + geom_violin() + geom_boxplot(width = 0.1) + scale_x_discrete(limits=c(&quot;Africa&quot;, &quot;Americas&quot;, &quot;Asia&quot;)) As you can see, the boxplot doesn’t align well inside the violin plot. To fix this issue, you can add the global aesthetic position = position_dodge(0.9) to both geoms. ggplot(data = gm2004, aes(x = continent, y = cholesterol, fill = gender)) + geom_violin(position = position_dodge(0.9)) + geom_boxplot(width = 0.1, position = position_dodge(0.9)) + scale_x_discrete(limits=c(&quot;Africa&quot;, &quot;Americas&quot;, &quot;Asia&quot;)) You can also try to add other Constant-Valued Aesthetics to both geoms to change their appearances. ggplot(data = gm2004, aes(x = continent, y = cholesterol, color = continent)) + geom_violin(color = &quot;violet&quot;, size = 2) + geom_boxplot(width = 0.1, color = &quot;blue&quot;, size = 1) + scale_x_discrete(limits=c(&quot;Africa&quot;, &quot;Americas&quot;, &quot;Asia&quot;)) "],["add-auxiliary.html", "6.3 Line Segments", " 6.3 Line Segments It is sometimes helpful to add line segments as auxiliary lines to existing plots to provide additional information. 6.3.1 Using abline() with plot() Let’s first review the scatterplot between liv_area and sale_price. library(r02pro) plot(sahp$liv_area, sahp$sale_price) In this plot, you may want to add some auxiliary lines. You can use the function abline() after a call of plot() to do this. To add a vertical line, you can set the parameter v; to add a horizontal line, you can set the parameter h. plot(sahp$liv_area, sahp$sale_price) abline(v = 2000, col = &quot;purple&quot;) ##Add a vertical line at liv_area = 2000 plot(sahp$liv_area, sahp$sale_price) abline(h = 300, col = &quot;blue&quot;) ##Add a horizontal line at sale_price = 2000 Note that the v and h arguments can also be vectors with more than one values, which will lead to multiple vertical or horizontal lines. The corresponding argument col can also be a vector with multiple values. plot(sahp$liv_area, sahp$sale_price) abline(h = c(100, 200, 300), col = c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;)) ##Add multiple horizontal lines In addition to adding vertical lines and horizontal lines, you can also add any line with the abline() function. We know a line can be represented as a function \\(y = a + b\\times x\\), where \\(a\\) is the intercept and \\(b\\) is the slope. In the abline(), you can generate such a line by specifying the parameter a for the intercept and b for the slope. Note that you can run abline() multiple times to add multiple lines. plot(sahp$liv_area, sahp$sale_price) abline(h = 300, col = &quot;blue&quot;) abline(a = 100, b = 0.1, col = &quot;green&quot;) 6.3.2 Using geom_hline(), geom_vline() and geom_abline() Let’s first review the following scatterplot between liv_area and sale_price. library(r02pro) library(tidyverse) ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) Looking at the scatterplot, it maybe helpful to add a horizontal line. To do this, you can use the geom_hline() function with argument yintercept specifying the value on the y-axis. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) + geom_hline(yintercept = 300, color = &quot;red&quot;) Here, a horizontal line at 300 is added to the scatterplot. You can also add both vertical lines and horizontal lines to the same plot. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) + geom_vline(xintercept = 2000, color = &quot;green&quot;) + geom_hline(yintercept = 300, color = &quot;red&quot;) In addition to adding vertical lines and horizontal lines, you can also add any line with the geom_abline() function. We know a line can be represented as a function \\(y = a + b\\times x\\), where \\(a\\) is the intercept and \\(b\\) is the slope. In the geom_abline(), you can generate such a line by specifying the slope and intercept arguments. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) + geom_abline(slope = 0.1, intercept = 100, color = &quot;blue&quot;) Similar to smoothline fit and line plots, you can change line type here. Different numbers correspond to different line types. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) + geom_abline(slope = 0.1, intercept = 100, linetype = 3) 6.3.3 Exercises Using the sahp data, using plot() to generate a scatterplot between lot_area (x-axis) and sale_price (y-axis), and add horizontal lines at 150 with color “blue” and 200 with color “red”. Using the sahp data, using ggplot() to generate a scatterplot between sale_price (x-axis) and liv_area (y-axis), and add the following lines to the plot: \\(y = 5\\times x + 1000\\) (in green color, dashed line) \\(y = 3\\times x + 1500\\) (in purple color, solid line) "],["heat-map.html", "6.4 Heat Map", " 6.4 Heat Map A heat map is a data visualization technique that shows magnitude of a phenomenon in the two dimensional space. First of all, we prepare a smaller data set from the gm2004 data in the r02pro package, to better illustrate the mechanism of a heat map. library(r02pro) library(tidyverse) country_list &lt;- c(&quot;Australia&quot;, &quot;China&quot;, &quot;United States&quot;, &quot;United Kingdom&quot;, &quot;South Africa&quot;) sgm2004 &lt;- gm2004 %&gt;% dplyr::filter(gender == &quot;female&quot;, country %in% country_list) %&gt;% select(country, population, BMI, cholesterol, GDP_per_capita) Note that during the data preparation process, we have used the filter() and select() functions, which filters observations and select variables from a tibble, respectively. They will be covered in detailed in the next Chapter. 6.4.1 Using the heatmap() function We will first introduce the function heatmap(), which is available in base R. To use the function, you need to convert the object into a matrix using as.matrix() and specify the rownames of the object. sgm2004_mat &lt;- as.matrix(sgm2004[, -1]) rownames(sgm2004_mat) &lt;- country_list sgm2004_mat #&gt; population BMI cholesterol GDP_per_capita #&gt; Australia 20200 26.6 5.26 50.30 #&gt; China 1330000 22.8 4.53 3.39 #&gt; United States 60300 26.7 5.40 42.80 #&gt; United Kingdom 295000 28.1 5.22 52.80 #&gt; South Africa 47900 29.0 4.63 5.11 heatmap(sgm2004_mat) The working of mechanism of a heatmap is that it creates a grid of colored gray-scale rectangles with colors corresponding to the values in the corresponding matrix. By default, the rows of the input matrix are scaled to have mean zero and standard deviation one. In our example, perhaps it is more meaningful to scale the columns as the represent different variables. We can achieve this by setting scale = \"column\". heatmap(sgm2004_mat, scale = &quot;column&quot;) In addition to generating the heat map, the heatmap() function, by default, also run a clustering algorithm on both the rows and columns, and visualize the results with dendrograms. To turn off the dendrograms, you can set arguments Rowv = NA and Colv = NA for the row and column dendrograms, respectively. In addition, it is easy to customize the colors of the heatmap. rc &lt;- rainbow(nrow(sgm2004_mat), start = 0, end = .3) cc &lt;- rainbow(ncol(sgm2004_mat), start = 0, end = .3) heatmap(sgm2004_mat, col = cm.colors(256), scale = &quot;column&quot;, RowSideColors = rc, ColSideColors = cc) 6.4.2 Using geom_tile() in ggplot2 In the ggplot2 packages, there is no geom that directly generates a heatmap, however, we can use the geom_tile() on a transformed data format using pivot_longer(), which will be introduced in Chapter ??. sgm2004_long &lt;- sgm2004 %&gt;% pivot_longer(cols = 2:5, names_to = &quot;Var&quot;) ggplot(sgm2004_long) + geom_tile(mapping = aes(x = country, y = Var, fill = value)) Here, since the variables are not in the same scale, the colors of the tiles are dominated by the population value. As before, we need to scale the variables to make them comparable. sgm2004_long &lt;- sgm2004_long %&gt;% group_by(Var) %&gt;% mutate(std_value = scale(value)) %&gt;% ungroup() ggplot(sgm2004_long) + geom_tile(mapping = aes(x = country, y = Var, fill = std_value)) Now, the heatmap looks more informative that shows the relative magnitude across different countries for each variable considered. Like in Section 5.3, you can customize the range of the tile colors by specifying the low and high parameters in the scale_fill_gradient() function. ggplot(sgm2004_long) + geom_tile(mapping = aes(x = country, y = Var, fill = std_value)) + scale_fill_gradient(low = &quot;green&quot;, high = &quot;red&quot;) "],["errorbar.html", "6.5 Error Bars", " 6.5 Error Bars So far, we have learned several ways to compare continuous distributions for different groups, including the density plot, boxplot, and the violin plot. In this lesson, we introduce another visualization method, called error bar, which is a graphical representations of the uncertainty in a certain measurement. Let’s prepare a ggplot object to get started. library(r02pro) library(ggplot2) g &lt;- ggplot(data = sahp, aes(x = house_style, y = sale_price)) + scale_x_discrete(limits=c(&quot;1Story&quot;, &quot;2Story&quot;)) Here, we visualize the error bar as the mean \\(\\pm\\) standard error. To show the mean of sale_price for different house_style groups, you can use the geom_point() function with arguments stat = \"summary\" and fun = \"mean\". g + geom_point(stat = &quot;summary&quot;, fun = &quot;mean&quot;) To add error bars to the mean points, we use geom_errorbar() coupled with the fun.data = \"mean_se\" argument. g + geom_point(stat = &quot;summary&quot;, fun = &quot;mean&quot;) + geom_errorbar(stat = &quot;summary&quot;, fun.data = &quot;mean_se&quot;) You can control the width of the errorbar by setting the width argument. g + geom_point(stat = &quot;summary&quot;, fun = &quot;mean&quot;) + geom_errorbar(stat = &quot;summary&quot;, fun.data = &quot;mean_se&quot;, width = 0.2) This plot is called a mean-error-bar plot. Let’s take a detailed look at this plot. The distance from the mean point to the lower bound of the error bar is the so called standard error, which is defined as the standard deviation of the sample divided by the square root of the sample size. Let’s try to calculate the upper and lower bounds of the error bar. sale_price_1_story &lt;- sahp$sale_price[sahp$house_style == &quot;1Story&quot;] sale_price_1_story_se &lt;- sd(sale_price_1_story)/sqrt(length(sale_price_1_story)) mean(sale_price_1_story) + sale_price_1_story_se #&gt; [1] 192.251 mean(sale_price_1_story) - sale_price_1_story_se #&gt; [1] 173.8044 You may notice that we are referring the data as sample since the sahp dataset contains only a subset of the population with all houses in the world. An important application of error bar is to construct the 95% confidence interval of the population mean. You know that the 95% confidence interval for a normal distribution is mean \\(\\pm\\) 1.96*se. If the data follows a normal distribution, you can construct such a confidence interval by setting the multiplier of the standard error in the error bar to be 1.96. g + geom_point(stat = &quot;summary&quot;, fun = &quot;mean&quot;) + geom_errorbar(stat = &quot;summary&quot;, fun.data = &quot;mean_se&quot;, width = 0.2, fun.args = list(mult = 1.96)) Of course, you can also add the error bar on top of the other plots like the boxplot or violin plot. g + geom_point(stat = &quot;summary&quot;, fun = &quot;mean&quot;) + geom_boxplot() + geom_errorbar(stat = &quot;summary&quot;, fun.data = &quot;mean_se&quot;, width = 0.2) g + geom_point(stat = &quot;summary&quot;, fun = &quot;mean&quot;) + geom_violin() + geom_errorbar(stat = &quot;summary&quot;, fun.data = &quot;mean_se&quot;, width = 0.2) "],["plotly.html", "6.6 Interative Plot with plotly()", " 6.6 Interative Plot with plotly() Until now, all the plots we created are all static. In this section, we will introduce a powerful tool named plotly() that can make interactive plots. If you haven’t done so, you need to first install the R package plotly. install.pacakges(&quot;plotly&quot;) Let’s start with a static scatterplot and make it interactive. library(r02pro) library(ggplot2) library(plotly) #&gt; #&gt; Attaching package: &#39;plotly&#39; #&gt; The following object is masked from &#39;package:ggplot2&#39;: #&gt; #&gt; last_plot #&gt; The following object is masked from &#39;package:stats&#39;: #&gt; #&gt; filter #&gt; The following object is masked from &#39;package:graphics&#39;: #&gt; #&gt; layout my_plot &lt;- ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol)) ggplotly(my_plot) Upon a first look, this may look identical to a regular scatterplot. However, you can try to move your cursor to the points which will show the corresponding coordinates. Some other features offered are available via a bar of buttons on the top right of the plot. Some useful features include Download plot as png. Zoom: Zoom a region of the plot. Pan: Move the plot around. In addition to the vanilla scatterplots, you can use plotly with more complicated plots that involves aesthetics. my_plot_continent &lt;- ggplot(data = gm2004) + geom_point(mapping = aes(x = sugar, y = cholesterol, color = continent)) ggplotly(my_plot_continent) Now, you can easily see the continent in addition to the sugarand cholesterol values for each data point. Let’s try to use plotly with some other types of plots. my_box_plot &lt;- ggplot(data = na.omit(sahp), aes(x = house_style, y = sale_price)) + scale_x_discrete(limits=c(&quot;1Story&quot;, &quot;2Story&quot;)) + geom_boxplot(mapping = aes(color = oa_qual &gt; 5)) ggplotly(my_box_plot) For boxplots, we can easily see the values of summary statistics. You are welcome to try out plotly on other types of plots. "],["data-manipulation.html", "Chapter 7 Data Manipulation", " Chapter 7 Data Manipulation For conducting data analysis, we often need to conduct various kinds of data manipulation. We will use the gm data set in the r02pro package throughout this chapter. Let’s first look at the data set. library(r02pro) gm #&gt; # A tibble: 65,531 × 33 #&gt; country year smoki…¹ smoki…² lungc…³ lungc…⁴ owid_…⁵ food_…⁶ avera…⁷ sanit…⁸ #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Albania 1999 4 NA 11.1 46.1 58.7 2730 5.96 89.5 #&gt; 2 Albania 2000 NA NA 10.8 43.8 58 2800 6.3 90 #&gt; 3 Albania 2001 4 40.5 11.2 44.1 60 2860 6.81 90.6 #&gt; 4 Albania 2002 NA NA 11.5 45.2 60 2770 7.22 91.2 #&gt; 5 Albania 2003 NA NA 11.2 44.8 60.7 2790 7.39 91.7 #&gt; 6 Albania 2004 4 40.5 11 42.8 60.7 2870 7.7 92.3 #&gt; 7 Andorra 1999 29.2 NA 14.3 70.4 44.7 NA 39.2 100 #&gt; 8 Andorra 2000 NA NA 14.3 70 47.3 NA 39.4 100 #&gt; 9 Andorra 2001 29.2 36.5 14.4 69.7 50.7 NA 39.5 100 #&gt; 10 Andorra 2002 NA NA 14.4 69.6 67.3 NA 42.7 100 #&gt; # … with 65,521 more rows, 23 more variables: child_mortality &lt;dbl&gt;, #&gt; # income_per_person &lt;dbl&gt;, HDI &lt;dbl&gt;, alcohol_male &lt;dbl&gt;, #&gt; # alcohol_female &lt;dbl&gt;, livercancer_newcases_male &lt;dbl&gt;, #&gt; # livercancer_newcases_female &lt;dbl&gt;, mortality_male &lt;dbl&gt;, #&gt; # mortality_female &lt;dbl&gt;, cholesterol_fat_in_blood_male &lt;dbl&gt;, #&gt; # cholesterol_fat_in_blood_female &lt;dbl&gt;, continent &lt;chr&gt;, region &lt;chr&gt;, #&gt; # population &lt;dbl&gt;, life_expectancy &lt;dbl&gt;, sugar &lt;dbl&gt;, BMI_female &lt;dbl&gt;, … gm is a dataset of 65,531 country and year pairs, with 33 variables among with are many sociodemographic and public health features. To learn more about each variable, you can look at its documentation. ?gm To view the entire dataset, you can use the View() function, which will open the dataset in the new file window. View(gm) To get the first 6 rows of gm, you can use the head() function, which also has an optional argument if you want a different number of top rows. head(gm) #&gt; # A tibble: 6 × 33 #&gt; country year smokin…¹ smoki…² lungc…³ lungc…⁴ owid_…⁵ food_…⁶ avera…⁷ sanit…⁸ #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Albania 1999 4 NA 11.1 46.1 58.7 2730 5.96 89.5 #&gt; 2 Albania 2000 NA NA 10.8 43.8 58 2800 6.3 90 #&gt; 3 Albania 2001 4 40.5 11.2 44.1 60 2860 6.81 90.6 #&gt; 4 Albania 2002 NA NA 11.5 45.2 60 2770 7.22 91.2 #&gt; 5 Albania 2003 NA NA 11.2 44.8 60.7 2790 7.39 91.7 #&gt; 6 Albania 2004 4 40.5 11 42.8 60.7 2870 7.7 92.3 #&gt; # … with 23 more variables: child_mortality &lt;dbl&gt;, income_per_person &lt;dbl&gt;, #&gt; # HDI &lt;dbl&gt;, alcohol_male &lt;dbl&gt;, alcohol_female &lt;dbl&gt;, #&gt; # livercancer_newcases_male &lt;dbl&gt;, livercancer_newcases_female &lt;dbl&gt;, #&gt; # mortality_male &lt;dbl&gt;, mortality_female &lt;dbl&gt;, #&gt; # cholesterol_fat_in_blood_male &lt;dbl&gt;, cholesterol_fat_in_blood_female &lt;dbl&gt;, #&gt; # continent &lt;chr&gt;, region &lt;chr&gt;, population &lt;dbl&gt;, life_expectancy &lt;dbl&gt;, #&gt; # sugar &lt;dbl&gt;, BMI_female &lt;dbl&gt;, BMI_female_group &lt;chr&gt;, BMI_male &lt;dbl&gt;, … head(gm, n = 10) #the first 10 rows of gm #&gt; # A tibble: 10 × 33 #&gt; country year smoki…¹ smoki…² lungc…³ lungc…⁴ owid_…⁵ food_…⁶ avera…⁷ sanit…⁸ #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Albania 1999 4 NA 11.1 46.1 58.7 2730 5.96 89.5 #&gt; 2 Albania 2000 NA NA 10.8 43.8 58 2800 6.3 90 #&gt; 3 Albania 2001 4 40.5 11.2 44.1 60 2860 6.81 90.6 #&gt; 4 Albania 2002 NA NA 11.5 45.2 60 2770 7.22 91.2 #&gt; 5 Albania 2003 NA NA 11.2 44.8 60.7 2790 7.39 91.7 #&gt; 6 Albania 2004 4 40.5 11 42.8 60.7 2870 7.7 92.3 #&gt; 7 Andorra 1999 29.2 NA 14.3 70.4 44.7 NA 39.2 100 #&gt; 8 Andorra 2000 NA NA 14.3 70 47.3 NA 39.4 100 #&gt; 9 Andorra 2001 29.2 36.5 14.4 69.7 50.7 NA 39.5 100 #&gt; 10 Andorra 2002 NA NA 14.4 69.6 67.3 NA 42.7 100 #&gt; # … with 23 more variables: child_mortality &lt;dbl&gt;, income_per_person &lt;dbl&gt;, #&gt; # HDI &lt;dbl&gt;, alcohol_male &lt;dbl&gt;, alcohol_female &lt;dbl&gt;, #&gt; # livercancer_newcases_male &lt;dbl&gt;, livercancer_newcases_female &lt;dbl&gt;, #&gt; # mortality_male &lt;dbl&gt;, mortality_female &lt;dbl&gt;, #&gt; # cholesterol_fat_in_blood_male &lt;dbl&gt;, cholesterol_fat_in_blood_female &lt;dbl&gt;, #&gt; # continent &lt;chr&gt;, region &lt;chr&gt;, population &lt;dbl&gt;, life_expectancy &lt;dbl&gt;, #&gt; # sugar &lt;dbl&gt;, BMI_female &lt;dbl&gt;, BMI_female_group &lt;chr&gt;, BMI_male &lt;dbl&gt;, … The following are some possible questions we may want to explore. (Filter observations by their values) Find the observations that represent countries in Europe (continent), years between 2006 and 2010 (year), and Low Human Development Index (HDI_category). You will learn how to filter observations in Section 7.1. (Select variable by their names) We see there are 33 columns. For a particular data analysis question, perhaps we want to focus on a subset of the columns. You will learn how to select variables in Section 7.2. (Reorder the observations) In year 2008, find the 10 countries with the highest life expectancy. You will learn how to reorder observations in Section 7.3. (Create new variables as functions of existing ones) From the existing variables, perhaps we want to create new ones, for instance, the total number of new liver cancer cases for each country in the year 2008. You will learn how to create new variables in Section 7.4. (Create various summary statistics) We may want to create certain summary statistics. For example, what is the top 5 countries with the highest average life expectancy in each continent for the year 2006? You will learn how to group observations and create summary statistics for each group in Section 7.5. "],["filter-observations.html", "7.1 Filter Observations, Objects Masking, and the Pipe", " 7.1 Filter Observations, Objects Masking, and the Pipe Let’s start with the first task outlined at the beginning of this chapter. Suppose we want to find the observations that represent countries in Europe (continent), years between 2006 and 2010 (year), and Low Human Development Index (HDI_category). You can use the function filter() in the dplyr package, a member of the tidyverse package. If you haven’t installed the tidyverse package, you need to install it. Let’s first load the dplyr package. library(dplyr) 7.1.1 Objects Masking After loading the package dplyr for the first time, you can see the following message The following objects are masked from ‘package:stats’: filter, lag The message appears because dplyr contains the functions filter() and lag() which are already defined and preloaded in the R package stats. As a result, the original functions are masked by the new definition in dplyr. In this scenario when the same function name is shared by multiple packages, we can add the package name as a prefix to the function name with double colon (::). For example, stats::filter() represents the filter() function in the stats package, while dplyr::filter() represents the filter() function in the dplyr package. You can also look at their documentations. ?stats::filter ?dplyr::filter It is helpful to verify which version of filter() you are using by running the function name filter. filter Usually, R will use the function in the package that is loaded at a later time. To verify the search path, you can use the search() function. R will show a list of attached packages and R objects. This list shows the sequence of environments or loaded packages that R uses to look for an object by name. search() #&gt; [1] &quot;.GlobalEnv&quot; &quot;package:plotly&quot; &quot;package:kableExtra&quot; #&gt; [4] &quot;package:lubridate&quot; &quot;package:forcats&quot; &quot;package:stringr&quot; #&gt; [7] &quot;package:purrr&quot; &quot;package:tidyr&quot; &quot;package:tidyverse&quot; #&gt; [10] &quot;package:ggplot2&quot; &quot;package:haven&quot; &quot;package:readxl&quot; #&gt; [13] &quot;package:readr&quot; &quot;package:tibble&quot; &quot;package:r02pro&quot; #&gt; [16] &quot;package:dplyr&quot; &quot;package:stats&quot; &quot;package:graphics&quot; #&gt; [19] &quot;package:grDevices&quot; &quot;package:utils&quot; &quot;package:datasets&quot; #&gt; [22] &quot;package:methods&quot; &quot;Autoloads&quot; &quot;package:base&quot; 7.1.2 Filter Observations Now, let’s introduce how to use filter() to get the subset of gm which consists of the rows that represent countries in Europe (continent), years between 2004 and 2006 (year), and very high Human Development Index (HDI_category). To use the filter() function, you put the dataset in the first argument, and put the logical statements as individual arguments after that. library(r02pro) filter(gm, continent == &quot;Europe&quot;, year &gt;= 2004, year &lt;= 2006, HDI_category == &quot;very high&quot;) #&gt; # A tibble: 81 × 33 #&gt; country year smoki…¹ smoki…² lungc…³ lungc…⁴ owid_…⁵ food_…⁶ avera…⁷ sanit…⁸ #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Austria 2004 40.1 46.4 19.4 50.5 66 3640 49.9 100 #&gt; 2 Belgium 2004 24.1 30.1 18.4 72.3 71.3 3720 47.2 99.5 #&gt; 3 Switze… 2004 22.2 30.7 19.6 47.6 80 3390 65.3 99.9 #&gt; 4 Czech … 2004 25.4 36.6 18.6 69.3 79.3 3320 24.3 99.1 #&gt; 5 Germany 2004 25.8 37.4 22.4 63.8 88.7 3450 51.4 99.2 #&gt; 6 Denmark 2004 30.6 36.1 43.7 59.6 85.3 3410 48 99.6 #&gt; 7 Spain 2004 30.9 36.4 8.99 65.4 59.3 3220 34.4 99.9 #&gt; 8 Estonia 2004 27.5 49.9 11.1 68.6 80.7 3170 18.7 99.6 #&gt; 9 Finland 2004 24.4 31.8 14.3 45.6 80 3200 45.4 99.4 #&gt; 10 France 2004 26.7 36.6 15.4 65.6 69.3 3540 43.7 98.7 #&gt; # … with 71 more rows, 23 more variables: child_mortality &lt;dbl&gt;, #&gt; # income_per_person &lt;dbl&gt;, HDI &lt;dbl&gt;, alcohol_male &lt;dbl&gt;, #&gt; # alcohol_female &lt;dbl&gt;, livercancer_newcases_male &lt;dbl&gt;, #&gt; # livercancer_newcases_female &lt;dbl&gt;, mortality_male &lt;dbl&gt;, #&gt; # mortality_female &lt;dbl&gt;, cholesterol_fat_in_blood_male &lt;dbl&gt;, #&gt; # cholesterol_fat_in_blood_female &lt;dbl&gt;, continent &lt;chr&gt;, region &lt;chr&gt;, #&gt; # population &lt;dbl&gt;, life_expectancy &lt;dbl&gt;, sugar &lt;dbl&gt;, BMI_female &lt;dbl&gt;, … In the filter() function, each logical statement will be computed, which leads to a logical vector of the same length as the number of observations. Then, only the observations that have TRUE values in all logical vectors are kept. It is helpful to learn the mechanism of filter() by reproducing the results using what we learned on data frame subsetting in Section 3.3.3. gm[which(gm$continent == &quot;Europe&quot; &amp; gm$year &gt;= 2004 &amp; gm$year &lt;= 2006 &amp; gm$HDI_category == &quot;very high&quot;), ] Although we got the same answer, we hope you agree with us that the filter() function provides more intuitive and simpler codes than the raw data frame subsetting. For example, the tibble name gm appeared five times in the data frame subsetting while it only appears once in the filter() function. This is an example of the power of creating new R functions and R packages. They usually enable us to do tasks that couldn’t be done using the existing functions in base R, or making coding easier than just using the existing functions. Recall that the same thing happened in the visualization where we compared the visualization functions in base R with the ggplot() function. No matter how complicated the figure we want to create is, we only need to put the data set name once in the ggplot() function if all the layers are using the same data set. It is worth noting that the filter() function only returns the observations when the conditions are all TRUE, excluding the observations that are missing in the variables associated with the filter conditions. Using the filter() function, the original tibble is unchanged, which is an important feature of many functions we will learn in this Chapter. To save the filtered tibble, you can either assign the value to the original tibble name, which will overwrite it; or assign the value to a new name, which will create a new tibble with the new values. Let’s save the filtering results in a new tibble. gm_europe &lt;- filter(gm, continent == &quot;Europe&quot;, year &gt;= 2004, year &lt;= 2006, HDI_category == &quot;very high&quot;) gm_europe In addition to using separate logical statements, you can also have logical operations between multiple logical vectors inside each statement. This makes the filter() function very flexible in expressing different kinds of filtering operation. Let’s say we want to find records that are in either Europe or Asia with HDI_category being “high” and “very high” in year 2004. filter(gm, continent == &quot;Europe&quot; | continent == &quot;Asia&quot; , year == 2004, HDI_category == &quot;very high&quot; | HDI_category == &quot;high&quot; ) 7.1.3 The pipe operator Now, we want to introduce a very useful operator, named pipe. The pipe operator makes it much easier to apply a sequence of operations on a dataset. For example, let’s say we want to generate a scatterplot of cholesterol and BMI only for the European countries in the gm2004 dataset. Typically, we first use the filter() function to create the subset of the data and call the ggplot() function to create the plot. library(ggplot2) ggplot(filter(gm2004, continent == &quot;Europe&quot;)) + geom_point(aes(x = BMI, y = cholesterol)) While this gets the job done, it doesn’t look very elegant. Let’s take a look what this looks like when we use the pipe operator %&gt;%. gm2004 %&gt;% filter(continent == &quot;Europe&quot;) %&gt;% ggplot() + geom_point(aes(x = BMI, y = cholesterol)) I hope you agree that this looks more intepretable, with each line corresponding to a step in the data processing. The pipe operator %&gt;% is a binary operator that takes the object on its left-hand side and passes it as the first argument to the function on its right-hand side. This makes it easier to read the code from left to right, as if you are reading a book. From now on, we will be extensively using the pipe operator %&gt;% to make the code more readable. 7.1.4 Exercise Using the ahp dataset, create a new tibble named my_ahp that contains all houses that are built before year 2000 (not including 2000), sold on or after year 2009, and with 2 or 3 bedrooms. Using the gm dataset, create a new tibble named my_gm that contains all countries in Asia and Africa with HDI_category being “high” or “medium” in year 2006. "],["select-variables.html", "7.2 Select, Rename, and Reorder Variables", " 7.2 Select, Rename, and Reorder Variables In Section 7.1, we have learned how to filter observations according to a set of conditions. In many applications, there are some variables which may not be the focus of the research problem. As a result, learning how to select variables is very useful in data analysis. 7.2.1 Select Variables via Names Let’s consider the gm data set in the r02pro package, which contains 33 variables. If we want to focus on the country, continent, year, and Human Development Index (HDI) category, we can use the select() function in the dplyr package. We will be using the pipe introduced in Section 7.1.3 throughout the rest of this Chapter. Inside the select() function, you can include the variables to select as different arguments. Note that the quotation marks are not necessary. library(r02pro) library(dplyr) gm %&gt;% select(country, continent, year, HDI_category) #&gt; # A tibble: 65,531 × 4 #&gt; country continent year HDI_category #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 Albania Europe 1999 medium #&gt; 2 Albania Europe 2000 medium #&gt; 3 Albania Europe 2001 medium #&gt; 4 Albania Europe 2002 medium #&gt; 5 Albania Europe 2003 medium #&gt; 6 Albania Europe 2004 high #&gt; 7 Andorra &lt;NA&gt; 1999 very high #&gt; 8 Andorra &lt;NA&gt; 2000 very high #&gt; 9 Andorra &lt;NA&gt; 2001 very high #&gt; 10 Andorra &lt;NA&gt; 2002 very high #&gt; # … with 65,521 more rows As you can see from the output, the select() function returns a tibble with only the selected variables. Now, let’s say we only want the observations for the year 2006. We can use the filter() function to get the subset of the gm data set with only the year 2006, and then use the select() function to keep only the variables of interest. gm %&gt;% filter(year == 2006) %&gt;% select(country, continent, year, HDI_category) #&gt; # A tibble: 236 × 4 #&gt; country continent year HDI_category #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 Afghanistan &lt;NA&gt; 2006 low #&gt; 2 Angola Africa 2006 low #&gt; 3 Albania Europe 2006 high #&gt; 4 Andorra &lt;NA&gt; 2006 very high #&gt; 5 United Arab Emirates Asia 2006 very high #&gt; 6 Argentina Americas 2006 very high #&gt; 7 Armenia Asia 2006 high #&gt; 8 American Samoa &lt;NA&gt; 2006 &lt;NA&gt; #&gt; 9 Antigua and Barbuda Americas 2006 high #&gt; 10 Australia Oceania 2006 very high #&gt; # … with 226 more rows 7.2.2 Rename Variables In the select() function, you can also rename the variables in the form of new_name = old_name as the arguments. Let’s see the following example where we want to rename the country to nation and HDI_category to HDI_cat. gm %&gt;% select(nation = country, continent, year, HDI_cat = HDI_category) #&gt; # A tibble: 65,531 × 4 #&gt; nation continent year HDI_cat #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 Albania Europe 1999 medium #&gt; 2 Albania Europe 2000 medium #&gt; 3 Albania Europe 2001 medium #&gt; 4 Albania Europe 2002 medium #&gt; 5 Albania Europe 2003 medium #&gt; 6 Albania Europe 2004 high #&gt; 7 Andorra &lt;NA&gt; 1999 very high #&gt; 8 Andorra &lt;NA&gt; 2000 very high #&gt; 9 Andorra &lt;NA&gt; 2001 very high #&gt; 10 Andorra &lt;NA&gt; 2002 very high #&gt; # … with 65,521 more rows Note that in this renaming operations, only the variables mentioned in the select() function are kept. If you want to generate a tibble with some variables renamed while keeping all variables, you can use the rename() function. gm %&gt;% rename(nation = country, HDI_cat = HDI_category) #&gt; # A tibble: 65,531 × 33 #&gt; nation year smoki…¹ smoki…² lungc…³ lungc…⁴ owid_…⁵ food_…⁶ avera…⁷ sanit…⁸ #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Albania 1999 4 NA 11.1 46.1 58.7 2730 5.96 89.5 #&gt; 2 Albania 2000 NA NA 10.8 43.8 58 2800 6.3 90 #&gt; 3 Albania 2001 4 40.5 11.2 44.1 60 2860 6.81 90.6 #&gt; 4 Albania 2002 NA NA 11.5 45.2 60 2770 7.22 91.2 #&gt; 5 Albania 2003 NA NA 11.2 44.8 60.7 2790 7.39 91.7 #&gt; 6 Albania 2004 4 40.5 11 42.8 60.7 2870 7.7 92.3 #&gt; 7 Andorra 1999 29.2 NA 14.3 70.4 44.7 NA 39.2 100 #&gt; 8 Andorra 2000 NA NA 14.3 70 47.3 NA 39.4 100 #&gt; 9 Andorra 2001 29.2 36.5 14.4 69.7 50.7 NA 39.5 100 #&gt; 10 Andorra 2002 NA NA 14.4 69.6 67.3 NA 42.7 100 #&gt; # … with 65,521 more rows, 23 more variables: child_mortality &lt;dbl&gt;, #&gt; # income_per_person &lt;dbl&gt;, HDI &lt;dbl&gt;, alcohol_male &lt;dbl&gt;, #&gt; # alcohol_female &lt;dbl&gt;, livercancer_newcases_male &lt;dbl&gt;, #&gt; # livercancer_newcases_female &lt;dbl&gt;, mortality_male &lt;dbl&gt;, #&gt; # mortality_female &lt;dbl&gt;, cholesterol_fat_in_blood_male &lt;dbl&gt;, #&gt; # cholesterol_fat_in_blood_female &lt;dbl&gt;, continent &lt;chr&gt;, region &lt;chr&gt;, #&gt; # population &lt;dbl&gt;, life_expectancy &lt;dbl&gt;, sugar &lt;dbl&gt;, BMI_female &lt;dbl&gt;, … From this example, you can see the different behavior between select() and rename() when renaming variables. 7.2.3 Select Variables with Patterns Sometimes, you may want to select many variables that follows a particular pattern. a. select consecutive variables The first type of variable patterns is consecutive variables in a tibble. To get started, you can use select(1:m) to get the first m variables. To get the last column, you can use select(last_col()). To get the last m variables, you can use select(last_col(m-1):last_col()). gm %&gt;% select(1:3) # the first 3 columns #&gt; # A tibble: 65,531 × 3 #&gt; country year smoking_female #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Albania 1999 4 #&gt; 2 Albania 2000 NA #&gt; 3 Albania 2001 4 #&gt; 4 Albania 2002 NA #&gt; 5 Albania 2003 NA #&gt; 6 Albania 2004 4 #&gt; 7 Andorra 1999 29.2 #&gt; 8 Andorra 2000 NA #&gt; 9 Andorra 2001 29.2 #&gt; 10 Andorra 2002 NA #&gt; # … with 65,521 more rows gm %&gt;% select(last_col()) # the last column #&gt; # A tibble: 65,531 × 1 #&gt; HDI_category #&gt; &lt;chr&gt; #&gt; 1 medium #&gt; 2 medium #&gt; 3 medium #&gt; 4 medium #&gt; 5 medium #&gt; 6 high #&gt; 7 very high #&gt; 8 very high #&gt; 9 very high #&gt; 10 very high #&gt; # … with 65,521 more rows gm %&gt;% select(last_col(1)) # the second to last column #&gt; # A tibble: 65,531 × 1 #&gt; GDP_per_capita #&gt; &lt;dbl&gt; #&gt; 1 1.96 #&gt; 2 2.14 #&gt; 3 2.25 #&gt; 4 2.38 #&gt; 5 2.52 #&gt; 6 2.68 #&gt; 7 34.3 #&gt; 8 36 #&gt; 9 36.2 #&gt; 10 37.6 #&gt; # … with 65,521 more rows gm %&gt;% select(last_col(2):last_col()) # the last 3 columns #&gt; # A tibble: 65,531 × 3 #&gt; health_spending GDP_per_capita HDI_category #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 6.35 1.96 medium #&gt; 2 6.04 2.14 medium #&gt; 3 6.28 2.25 medium #&gt; 4 6.16 2.38 medium #&gt; 5 6.88 2.52 medium #&gt; 6 6.84 2.68 high #&gt; 7 7.58 34.3 very high #&gt; 8 6.79 36 very high #&gt; 9 7.04 36.2 very high #&gt; 10 7.12 37.6 very high #&gt; # … with 65,521 more rows If you want to select the variable country and all variables from HDI to continent in the tibble, you can use HDI:continent as a single argument in the select() function. Note that the result highly depends on the particular ordering of variables in the tibble. gm %&gt;% select(country, HDI:continent) #&gt; # A tibble: 65,531 × 11 #&gt; country HDI alcoh…¹ alcoh…² liver…³ liver…⁴ morta…⁵ morta…⁶ chole…⁷ chole…⁸ #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Albania 0.671 10.6 2.5 17.8 8.28 23.5 12.9 4.9 4.92 #&gt; 2 Albania 0.678 11.5 2.74 17.1 7.66 19.6 11 4.9 4.92 #&gt; 3 Albania 0.684 11.5 2.74 16.4 7.1 20.2 12.3 4.91 4.92 #&gt; 4 Albania 0.691 11.5 2.74 15.7 6.58 21.2 12.6 4.91 4.92 #&gt; 5 Albania 0.696 11.5 2.74 15.1 6.1 20.6 12 4.91 4.91 #&gt; 6 Albania 0.706 12.4 2.96 14.4 5.66 25.2 14.5 4.9 4.9 #&gt; 7 Andorra 0.813 20.4 6.57 5.99 2.35 NA NA 5.67 5.57 #&gt; 8 Andorra 0.815 19.8 6.41 6.05 2.35 NA NA 5.65 5.55 #&gt; 9 Andorra 0.82 19.6 6.33 6.12 2.36 NA NA 5.64 5.53 #&gt; 10 Andorra 0.827 19.5 6.24 6.19 2.37 NA NA 5.62 5.51 #&gt; # … with 65,521 more rows, 1 more variable: continent &lt;chr&gt;, and abbreviated #&gt; # variable names ¹​alcohol_male, ²​alcohol_female, ³​livercancer_newcases_male, #&gt; # ⁴​livercancer_newcases_female, ⁵​mortality_male, ⁶​mortality_female, #&gt; # ⁷​cholesterol_fat_in_blood_male, ⁸​cholesterol_fat_in_blood_female b. select variables with names that start with, end with, or contain a string Another commonly used pattern is to select all variables with names that start with, end with, or contain a string. To select all variables that end with \"female\" (representing the female related measures) in the gm data set, you can use the ends_with() function in the select() function. gm %&gt;% select(ends_with(&quot;female&quot;)) #&gt; # A tibble: 65,531 × 7 #&gt; smoking_female lungcancer_newcases_…¹ alcoh…² liver…³ morta…⁴ chole…⁵ BMI_f…⁶ #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 11.1 2.5 8.28 12.9 4.92 25.1 #&gt; 2 NA 10.8 2.74 7.66 11 4.92 25.2 #&gt; 3 4 11.2 2.74 7.1 12.3 4.92 25.3 #&gt; 4 NA 11.5 2.74 6.58 12.6 4.92 25.3 #&gt; 5 NA 11.2 2.74 6.1 12 4.91 25.4 #&gt; 6 4 11 2.96 5.66 14.5 4.9 25.5 #&gt; 7 29.2 14.3 6.57 2.35 NA 5.57 26.1 #&gt; 8 NA 14.3 6.41 2.35 NA 5.55 26.1 #&gt; 9 29.2 14.4 6.33 2.36 NA 5.53 26.2 #&gt; 10 NA 14.4 6.24 2.37 NA 5.51 26.2 #&gt; # … with 65,521 more rows, and abbreviated variable names #&gt; # ¹​lungcancer_newcases_female, ²​alcohol_female, ³​livercancer_newcases_female, #&gt; # ⁴​mortality_female, ⁵​cholesterol_fat_in_blood_female, ⁶​BMI_female In the output, you can see the tibble with all variables ending with \"female\". You can also use starts_with() to select all variables with names that end with a particular string. gm %&gt;% select(starts_with(&quot;BMI&quot;)) #starts with BMI #&gt; # A tibble: 65,531 × 4 #&gt; BMI_female BMI_female_group BMI_male BMI_male_group #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 25.1 pre_obesity 25.6 pre_obesity #&gt; 2 25.2 pre_obesity 25.7 pre_obesity #&gt; 3 25.3 pre_obesity 25.8 pre_obesity #&gt; 4 25.3 pre_obesity 25.9 pre_obesity #&gt; 5 25.4 pre_obesity 26 pre_obesity #&gt; 6 25.5 pre_obesity 26.1 pre_obesity #&gt; 7 26.1 pre_obesity 26.8 pre_obesity #&gt; 8 26.1 pre_obesity 26.9 pre_obesity #&gt; 9 26.2 pre_obesity 27 pre_obesity #&gt; 10 26.2 pre_obesity 27.1 pre_obesity #&gt; # … with 65,521 more rows This produces a tibble with all variables starting with BMI. If you want to select all variables with names containing a string (not necessarily starts with or ends with), you can use the contains() function with the string as its argument. gm %&gt;% select(contains(&quot;newcases&quot;)) #&gt; # A tibble: 65,531 × 4 #&gt; lungcancer_newcases_female lungcancer_newcases_male livercancer_new…¹ liver…² #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 11.1 46.1 17.8 8.28 #&gt; 2 10.8 43.8 17.1 7.66 #&gt; 3 11.2 44.1 16.4 7.1 #&gt; 4 11.5 45.2 15.7 6.58 #&gt; 5 11.2 44.8 15.1 6.1 #&gt; 6 11 42.8 14.4 5.66 #&gt; 7 14.3 70.4 5.99 2.35 #&gt; 8 14.3 70 6.05 2.35 #&gt; 9 14.4 69.7 6.12 2.36 #&gt; 10 14.4 69.6 6.19 2.37 #&gt; # … with 65,521 more rows, and abbreviated variable names #&gt; # ¹​livercancer_newcases_male, ²​livercancer_newcases_female This produces a tibble with all variables containing the string \"newcases\". You can also combine multiple conditions using logical operators. First of all, the multiple arguments in the select() function are combined with or operations (|). For example, to get all variables that begins with b or ends with m, you can do the following. gm %&gt;% select(starts_with(&quot;smoking&quot;), ends_with(&quot;female&quot;)) #&gt; # A tibble: 65,531 × 8 #&gt; smoking_female smoking_male lungcan…¹ alcoh…² liver…³ morta…⁴ chole…⁵ BMI_f…⁶ #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 4 NA 11.1 2.5 8.28 12.9 4.92 25.1 #&gt; 2 NA NA 10.8 2.74 7.66 11 4.92 25.2 #&gt; 3 4 40.5 11.2 2.74 7.1 12.3 4.92 25.3 #&gt; 4 NA NA 11.5 2.74 6.58 12.6 4.92 25.3 #&gt; 5 NA NA 11.2 2.74 6.1 12 4.91 25.4 #&gt; 6 4 40.5 11 2.96 5.66 14.5 4.9 25.5 #&gt; 7 29.2 NA 14.3 6.57 2.35 NA 5.57 26.1 #&gt; 8 NA NA 14.3 6.41 2.35 NA 5.55 26.1 #&gt; 9 29.2 36.5 14.4 6.33 2.36 NA 5.53 26.2 #&gt; 10 NA NA 14.4 6.24 2.37 NA 5.51 26.2 #&gt; # … with 65,521 more rows, and abbreviated variable names #&gt; # ¹​lungcancer_newcases_female, ²​alcohol_female, ³​livercancer_newcases_female, #&gt; # ⁴​mortality_female, ⁵​cholesterol_fat_in_blood_female, ⁶​BMI_female In the output, you can see the tibble with all variables starting with \"smoking\" or ending with \"female\". 7.2.4 Reorder Variables via Names Knowing how to select and rename variables, let’s learn how to reorder variables in a tibble. The first approach to reordering variables is to use the select() function by listing all the variables in the desired order. However, you may realized that it would be time consuming if there are many variables in the tibble and we only want to move a few to the beginning. It turns out we can utilize the everything() function as an argument in the select() function, which will select all the remaining variables. Let’s say we want to move country and continent to the beginning of the tibble. gm %&gt;% select(country, continent, everything()) #&gt; # A tibble: 65,531 × 33 #&gt; country conti…¹ year smoki…² smoki…³ lungc…⁴ lungc…⁵ owid_…⁶ food_…⁷ avera…⁸ #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Albania Europe 1999 4 NA 11.1 46.1 58.7 2730 5.96 #&gt; 2 Albania Europe 2000 NA NA 10.8 43.8 58 2800 6.3 #&gt; 3 Albania Europe 2001 4 40.5 11.2 44.1 60 2860 6.81 #&gt; 4 Albania Europe 2002 NA NA 11.5 45.2 60 2770 7.22 #&gt; 5 Albania Europe 2003 NA NA 11.2 44.8 60.7 2790 7.39 #&gt; 6 Albania Europe 2004 4 40.5 11 42.8 60.7 2870 7.7 #&gt; 7 Andorra &lt;NA&gt; 1999 29.2 NA 14.3 70.4 44.7 NA 39.2 #&gt; 8 Andorra &lt;NA&gt; 2000 NA NA 14.3 70 47.3 NA 39.4 #&gt; 9 Andorra &lt;NA&gt; 2001 29.2 36.5 14.4 69.7 50.7 NA 39.5 #&gt; 10 Andorra &lt;NA&gt; 2002 NA NA 14.4 69.6 67.3 NA 42.7 #&gt; # … with 65,521 more rows, 23 more variables: sanitation &lt;dbl&gt;, #&gt; # child_mortality &lt;dbl&gt;, income_per_person &lt;dbl&gt;, HDI &lt;dbl&gt;, #&gt; # alcohol_male &lt;dbl&gt;, alcohol_female &lt;dbl&gt;, livercancer_newcases_male &lt;dbl&gt;, #&gt; # livercancer_newcases_female &lt;dbl&gt;, mortality_male &lt;dbl&gt;, #&gt; # mortality_female &lt;dbl&gt;, cholesterol_fat_in_blood_male &lt;dbl&gt;, #&gt; # cholesterol_fat_in_blood_female &lt;dbl&gt;, region &lt;chr&gt;, population &lt;dbl&gt;, #&gt; # life_expectancy &lt;dbl&gt;, sugar &lt;dbl&gt;, BMI_female &lt;dbl&gt;, … This produces a tibble with country and continent as the first two columns, followed by the remaining variables in the same order as in the original tibble. 7.2.5 Exercise Using the ahp dataset and the pipe operator for the following exercises. Select the variables dt_sold, house_style, liv_area, and sale_price, while renaming dt_sold to date_sold and house_style to house_type. Select the variables that starts with yr or ends with qual. "],["reorder-observations.html", "7.3 Reorder Observations", " 7.3 Reorder Observations Now, let’s look at the third task: find the 10 countries with the highest life expectancy in the year 2008. To order observations, you can use the function arrange() in the dplyr package. First, let’s create a new dataset called gm_2008 that only contains the observations in 2008 and the variables country, life_expectancy, and GDP_per_capita. library(r02pro) library(dplyr) library(tibble) gm_2008 &lt;- gm %&gt;% filter(year == 2008) %&gt;% select(country, life_expectancy, GDP_per_capita) To arrange the observations in the ascending order of the life expectancy (life_expectancy), you just need to add life_expectancy as an argument of the arrange() function. To arrange the descending order, you can add desc() around the variable. gm_2008 %&gt;% arrange(life_expectancy) #arrange in the ascending order of life_expectancy #&gt; # A tibble: 236 × 3 #&gt; country life_expectancy GDP_per_capita #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Eswatini 46.4 3.21 #&gt; 2 Central African Republic 47.4 0.514 #&gt; 3 Lesotho 47.4 0.948 #&gt; 4 Zimbabwe 50.2 0.941 #&gt; 5 Mozambique 53.5 0.463 #&gt; 6 Somalia 54.6 NA #&gt; 7 Malawi 55 0.346 #&gt; 8 Sierra Leone 55.3 0.52 #&gt; 9 Guinea-Bissau 55.5 0.574 #&gt; 10 South Africa 55.7 5.48 #&gt; # … with 226 more rows gm_2008 %&gt;% arrange(desc(life_expectancy)) #arrange in the descending order of life_expectancy #&gt; # A tibble: 236 × 3 #&gt; country life_expectancy GDP_per_capita #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Japan 83.3 31.7 #&gt; 2 Hong Kong, China 82.7 35.9 #&gt; 3 Switzerland 82.5 80.3 #&gt; 4 Singapore 82.5 43.3 #&gt; 5 Iceland 82.4 49.5 #&gt; 6 Australia 81.9 53.3 #&gt; 7 Andorra 81.8 35.4 #&gt; 8 Spain 81.8 25.8 #&gt; 9 Italy 81.8 31.6 #&gt; 10 San Marino 81.8 56.7 #&gt; # … with 226 more rows You may observe from the results that there are several countries with the same life_expectancy value, leading to a tie. To break the tie, you can supply additional variables in the arrange() function, which will arrange the observations within the tie according to the additional variables in the order they are supplied. gm_2008 %&gt;% arrange(life_expectancy, GDP_per_capita) #&gt; # A tibble: 236 × 3 #&gt; country life_expectancy GDP_per_capita #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Eswatini 46.4 3.21 #&gt; 2 Central African Republic 47.4 0.514 #&gt; 3 Lesotho 47.4 0.948 #&gt; 4 Zimbabwe 50.2 0.941 #&gt; 5 Mozambique 53.5 0.463 #&gt; 6 Somalia 54.6 NA #&gt; 7 Malawi 55 0.346 #&gt; 8 Sierra Leone 55.3 0.52 #&gt; 9 Guinea-Bissau 55.5 0.574 #&gt; 10 Zambia 55.7 1.13 #&gt; # … with 226 more rows Here, the observations are arranged in the ascending order of life_expectancy, and the ties are broken in the ascending order of GDP_per_capita. Note that the observations that has an NA value in the specified variable will always be arranged at the end of the output. If you want to break the tie in the descending order of GDP_per_capita, you can use desc() around the variable. gm_2008 %&gt;% arrange(life_expectancy, desc(GDP_per_capita)) #&gt; # A tibble: 236 × 3 #&gt; country life_expectancy GDP_per_capita #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Eswatini 46.4 3.21 #&gt; 2 Lesotho 47.4 0.948 #&gt; 3 Central African Republic 47.4 0.514 #&gt; 4 Zimbabwe 50.2 0.941 #&gt; 5 Mozambique 53.5 0.463 #&gt; 6 Somalia 54.6 NA #&gt; 7 Malawi 55 0.346 #&gt; 8 Sierra Leone 55.3 0.52 #&gt; 9 Guinea-Bissau 55.5 0.574 #&gt; 10 South Africa 55.7 5.48 #&gt; # … with 226 more rows Now, we are ready to present the 10 countries with the highest life expectancy in 2008. gm_2008 %&gt;% arrange(desc(life_expectancy)) %&gt;% head(10) #&gt; # A tibble: 10 × 3 #&gt; country life_expectancy GDP_per_capita #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Japan 83.3 31.7 #&gt; 2 Hong Kong, China 82.7 35.9 #&gt; 3 Switzerland 82.5 80.3 #&gt; 4 Singapore 82.5 43.3 #&gt; 5 Iceland 82.4 49.5 #&gt; 6 Australia 81.9 53.3 #&gt; 7 Andorra 81.8 35.4 #&gt; 8 Spain 81.8 25.8 #&gt; 9 Italy 81.8 31.6 #&gt; 10 San Marino 81.8 56.7 Here, the head(10) function is used to get the first 10 observations in the dataset. 7.3.1 Exercises Using the ahp dataset, Find all houses built in 2008 with house_style as \"2Story\", then arrange the the observations in the ascending order of remodel year, and break the ties in the descending order of sale_price. Find all houses sold in 2009 with house_style as \"1Story\", and arrange the observations in the descending order of sale_price. "],["create-variables.html", "7.4 Create New Variables via mutate() and transmute()", " 7.4 Create New Variables via mutate() and transmute() You are now an expert in filtering observations (Section 7.1), selecting, renaming &amp; reordering variables (Section 7.2), and reordering observations (Section 7.3). In many applications, you may want to create new variables as functions of the existing ones. In this section, we will learn how to do this using the dplyr package. Let’s say you want to compute the total GDP for each country in the gm data set. To highlight the useful columns, we first use select() to select the country, year, population, and GDP_per_capita. Then, use the mutate() function to add a new variable named total_GDP with the value GDP_per_capita * population to the end. library(r02pro) library(tidyverse) gm %&gt;% select(country, year, population, GDP_per_capita) %&gt;% mutate(total_GDP = GDP_per_capita * population) #&gt; # A tibble: 65,531 × 5 #&gt; country year population GDP_per_capita total_GDP #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Albania 1999 3130 1.96 6135. #&gt; 2 Albania 2000 3130 2.14 6698. #&gt; 3 Albania 2001 3130 2.25 7042. #&gt; 4 Albania 2002 3120 2.38 7426. #&gt; 5 Albania 2003 3100 2.52 7812 #&gt; 6 Albania 2004 3090 2.68 8281. #&gt; 7 Andorra 1999 65.4 34.3 2243. #&gt; 8 Andorra 2000 67.3 36 2423. #&gt; 9 Andorra 2001 70 36.2 2534 #&gt; 10 Andorra 2002 73.2 37.6 2752. #&gt; # … with 65,521 more rows From the result, you can check that the resulting tibble has 5 columns, with the last column being the newly created variable total_GDP. You can use mutate() to create multiple variables at the same time following the same format. gm %&gt;% select(country, year, population, GDP_per_capita, livercancer_newcases_male, livercancer_newcases_female) %&gt;% mutate(total_GDP = GDP_per_capita * population, livercancer_newcases = livercancer_newcases_male + livercancer_newcases_female) #&gt; # A tibble: 65,531 × 8 #&gt; country year population GDP_per_capita livercancer…¹ liver…² total…³ liver…⁴ #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Albania 1999 3130 1.96 17.8 8.28 6135. 26.1 #&gt; 2 Albania 2000 3130 2.14 17.1 7.66 6698. 24.8 #&gt; 3 Albania 2001 3130 2.25 16.4 7.1 7042. 23.5 #&gt; 4 Albania 2002 3120 2.38 15.7 6.58 7426. 22.3 #&gt; 5 Albania 2003 3100 2.52 15.1 6.1 7812 21.2 #&gt; 6 Albania 2004 3090 2.68 14.4 5.66 8281. 20.1 #&gt; 7 Andorra 1999 65.4 34.3 5.99 2.35 2243. 8.34 #&gt; 8 Andorra 2000 67.3 36 6.05 2.35 2423. 8.4 #&gt; 9 Andorra 2001 70 36.2 6.12 2.36 2534 8.48 #&gt; 10 Andorra 2002 73.2 37.6 6.19 2.37 2752. 8.56 #&gt; # … with 65,521 more rows, and abbreviated variable names #&gt; # ¹​livercancer_newcases_male, ²​livercancer_newcases_female, ³​total_GDP, #&gt; # ⁴​livercancer_newcases This operation adds two new columns total_GDP and livercancer_newcases to the existing tibble. Note that the mutate() function can only use the variables inside the select() function. The following code will show an error since livercancer_newcases_male is not included in the select() function. gm %&gt;% select(country, year, population, GDP_per_capita) %&gt;% mutate(total_GDP = GDP_per_capita * population, livercancer_newcases = livercancer_newcases_male + livercancer_newcases_female) #&gt; Error in `mutate()`: #&gt; ℹ In argument: #&gt; `livercancer_newcases = #&gt; livercancer_newcases_male + #&gt; livercancer_newcases_female`. #&gt; Caused by error: #&gt; ! object &#39;livercancer_newcases_male&#39; not found Note that you are free to use any functions on a vector, including all the arithmetic operations and various functions. For example, to include the order of each country in terms of GDP per capita in the year 2008, you can use mutate(GDP_order = order(GDP_per_capita)). To create a variable as the mean of the GDP_per_capita of all countries, you can add GDP_per_capita_ave = mean(GDP_per_capita, na.rm = TRUE) as an argument in the mutate() function. gm %&gt;% filter(year == 2008) %&gt;% select(country, year, population, GDP_per_capita) %&gt;% mutate(GDP_order = order(GDP_per_capita), GDP_per_capita_ave = mean(GDP_per_capita, na.rm = TRUE)) #&gt; # A tibble: 236 × 6 #&gt; country year population GDP_per_capita GDP_order GDP_per_capi…¹ #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 Afghanistan 2008 28400 0.492 13 14.8 #&gt; 2 Angola 2008 22500 3.96 129 14.8 #&gt; 3 Albania 2008 2970 3.43 38 14.8 #&gt; 4 Andorra 2008 84.5 35.4 59 14.8 #&gt; 5 United Arab Emirates 2008 7920 34.6 132 14.8 #&gt; 6 Argentina 2008 40500 12.4 126 14.8 #&gt; 7 Armenia 2008 2890 2.88 180 14.8 #&gt; 8 American Samoa 2008 NA 12.1 115 14.8 #&gt; 9 Antigua and Barbuda 2008 86.7 15.4 1 14.8 #&gt; 10 Australia 2008 21800 53.3 31 14.8 #&gt; # … with 226 more rows, and abbreviated variable name ¹​GDP_per_capita_ave The mutate() function is very powerful in creating new variables. However, if you only want to keep the newly created variables, you can use the transmute() function. gm %&gt;% filter(year == 2008) %&gt;% select(country, year, population, GDP_per_capita) %&gt;% transmute(GDP_order = order(GDP_per_capita), GDP_per_capita_ave = mean(GDP_per_capita, na.rm = TRUE)) #&gt; # A tibble: 236 × 2 #&gt; GDP_order GDP_per_capita_ave #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 13 14.8 #&gt; 2 129 14.8 #&gt; 3 38 14.8 #&gt; 4 59 14.8 #&gt; 5 132 14.8 #&gt; 6 126 14.8 #&gt; 7 180 14.8 #&gt; 8 115 14.8 #&gt; 9 1 14.8 #&gt; 10 31 14.8 #&gt; # … with 226 more rows 7.4.1 Exercises Using the ahp dataset and the pipe operator for the following exercises. Create a new variables named age being the age of the house when it was sold in terms of years (the number of years from when the house was built to when the house was sold). Then, select the variables age, sale_price, and kit_qual. Finally, generate a scatterplot between age (x-axis) and sale_price (y-axis), with different colors representing different kit_qual. Explain the findings from the figure. "],["create-grouped-summaries.html", "7.5 Create Grouped Summaries via group_by() and summarize()", " 7.5 Create Grouped Summaries via group_by() and summarize() In Section 7.4, you learned how to create new variables as functions of the existing ones. For example, we created a variable representing the order of GDP per capita for each country in the year 2008. In this section, we will learn how to create summaries for each group of observations. The dplyr package provides two useful functions to achieve this: namely group_by() which can group the observations according to the specified variables, and summarize() which create summaries for each group. 7.5.1 Create Summaries To create summaries for a variable, you can use the summarize() function. Let’s compute the number of countries, the average population, and the median of the GDP per capita for all observations in the gm dataset for the year 2008. library(r02pro) library(tidyverse) gm %&gt;% filter(year == 2008) %&gt;% summarize(n_countries = n(), ave_population = mean(population, na.rm = TRUE), q_GDP = median(GDP_per_capita, na.rm = TRUE)) #&gt; # A tibble: 1 × 3 #&gt; n_countries ave_population q_GDP #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 236 34848. 5.12 Note that here we use the n() function to count the number of countries. The mean() function computes the average of the population, and the median() function computes the median of the GDP per capita. The na.rm = TRUE argument is used to remove the missing values when computing the average and median. 7.5.2 Create Grouped Summaries So far, we have learned to use summarize() to create summaries for all observations. In practical applications, it is often more useful to compute the summaries when the observations are grouped according to certain criteria. Let’s say we want to create the same summaries for each continent in the gm dataset. gm %&gt;% group_by(continent) %&gt;% summarize(n_countries = n(), ave_population = mean(population, na.rm = TRUE), q_GDP = median(GDP_per_capita, na.rm = TRUE)) #&gt; # A tibble: 6 × 4 #&gt; continent n_countries ave_population q_GDP #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Africa 15051 19103. 0.984 #&gt; 2 Americas 10578 16009. 5.26 #&gt; 3 Asia 13764 53912. 3.41 #&gt; 4 Europe 11439 13590. 19.1 #&gt; 5 Oceania 3446 2419. 2.87 #&gt; 6 &lt;NA&gt; 11253 5008. 11.8 From the output, you can see that the summaries are created for each continent. The group_by() function is used to group the observations according to the continent variable. Then, the summarize() function is used to create the summaries for each group. Let’s now do another example. We want to find the top 5 countries with the highest life expectancy in the year 2006 for each continent. gm %&gt;% filter(year == 2006, !is.na(continent)) %&gt;% group_by(continent) %&gt;% top_n(5, life_expectancy) %&gt;% select(country, life_expectancy) %&gt;% arrange(continent, desc(life_expectancy)) #&gt; Adding missing grouping variables: #&gt; `continent` #&gt; # A tibble: 25 × 3 #&gt; # Groups: continent [5] #&gt; continent country life_expectancy #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Africa Libya 76 #&gt; 2 Africa Tunisia 75.7 #&gt; 3 Africa Mauritius 73.8 #&gt; 4 Africa Algeria 73.6 #&gt; 5 Africa Cape Verde 73.2 #&gt; 6 Americas Canada 80.9 #&gt; 7 Americas Costa Rica 80.3 #&gt; 8 Americas Cuba 78.5 #&gt; 9 Americas Panama 78.5 #&gt; 10 Americas Chile 78.4 #&gt; # … with 15 more rows In this example, we first filter the observations for the year 2006 and remove the missing values in the continent variable. Then, we group the observations according to the continent variable. The top_n() function is used to select the top 5 countries with the highest life expectancy for each continent. Finally, we select the country and life_expectancy variables and arrange the observations according to the continent and the life expectancy in descending order. Finally, let’s say we want to visualize the trend of the average GDP per capita for each continent from 1998 to 2018. gm %&gt;% filter(year &gt;= 1998 &amp; year &lt;= 2018 &amp; !is.na(continent)) %&gt;% group_by(continent, year) %&gt;% summarize(ave_GDP = median(GDP_per_capita, na.rm = TRUE)) %&gt;% ggplot(aes(x = year, y = ave_GDP, color = continent)) + geom_smooth(se = FALSE) + labs(title = &quot;Trend of Average GDP per Capita by Continent&quot;, x = &quot;Year&quot;, y = &quot;Average GDP per Capita&quot;) #&gt; `summarise()` has grouped output by #&gt; &#39;continent&#39;. You can override using #&gt; the `.groups` argument. #&gt; `geom_smooth()` using method = #&gt; &#39;loess&#39; and formula = &#39;y ~ x&#39; Here, we first filter the observations for the years from 1998 to 2018 and remove the missing values in the continent variable. Then, we group the observations according to the continent and year variables. The summarize() function is used to compute the median of the GDP per capita for each group. Finally, we create a smoothline fit to visualize the trend of the average GDP per capita for each continent from 1998 to 2018. 7.5.3 Exercises Using the ahp dataset and the pipe operator for the following exercises. For each month when the house was sold, summarize the 1st and 3rd quartile of the sale price. Then, create a scatterplot between the month (x-axis) and the quartile of the sale price with different colors for 1st and 3rd quantile. Explain the findings from the figure. Someone has a conjecture that when sold, the houses that are less than or equal to 30 years old have a higher sale price than the houses that are more than 30 years old. Show whether this is true in terms of maximum price, median price, and the minimum price for the houses in each group. "],["grouped-mutate-filter.html", "7.6 Grouped Mutate and Filter via group_by()", " 7.6 Grouped Mutate and Filter via group_by() In Section 7.5, you have seen the power of group_by() and summarize() which can help to create grouped summaries. In turns out the group_by() can be combined with filter() and mutate() to filter observations by group and create new variables by group. 7.6.1 Grouped Filter For the gm dataset, let’s say we want to find the countries that have a higher average GDP per capita than the average in the corresponding continent in the year 2008. We can use the following code. library(r02pro) library(dplyr) gm %&gt;% filter(year == 2008) %&gt;% group_by(continent) %&gt;% mutate(ave_GDP = mean(GDP_per_capita, na.rm = TRUE)) %&gt;% filter(GDP_per_capita &gt; ave_GDP) %&gt;% select(country, continent, GDP_per_capita, ave_GDP) #&gt; # A tibble: 63 × 4 #&gt; # Groups: continent [6] #&gt; country continent GDP_per_capita ave_GDP #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 Angola Africa 3.96 2.41 #&gt; 2 Andorra &lt;NA&gt; 35.4 27.6 #&gt; 3 United Arab Emirates Asia 34.6 13.0 #&gt; 4 Antigua and Barbuda Americas 15.4 12.6 #&gt; 5 Australia Oceania 53.3 11.2 #&gt; 6 Austria Europe 42.6 26.7 #&gt; 7 Belgium Europe 39 26.7 #&gt; 8 Bahrain Asia 21.1 13.0 #&gt; 9 Bahamas Americas 32.3 12.6 #&gt; 10 Bermuda &lt;NA&gt; 118 27.6 #&gt; # … with 53 more rows The code works in the following steps. 1. Filter the observations for the year 2008. 2. Group the observations by continent. 3. Compute the average GDP per capita for each continent. 4. Filter the observations that have a GDP per capita higher than the average GDP per capita of the corresponding continent. 5. Select the variables country, continent, GDP_per_capita, and ave_GDP. 7.6.2 Grouped Mutate Now, let’s say we want to find the top two countries with the highest GDP per capita for each continent in the year 2008. We can use the following code. gm %&gt;% filter(year == 2008 &amp; !is.na(continent)) %&gt;% group_by(continent) %&gt;% mutate(r = rank(desc(GDP_per_capita), ties.method = &quot;first&quot;)) %&gt;% filter(r &lt;= 2) %&gt;% select(country, continent, GDP_per_capita) %&gt;% arrange(continent, desc(GDP_per_capita)) #&gt; # A tibble: 10 × 3 #&gt; # Groups: continent [5] #&gt; country continent GDP_per_capita #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 Equatorial Guinea Africa 15.9 #&gt; 2 Seychelles Africa 11.7 #&gt; 3 United States Americas 51.9 #&gt; 4 Greenland Americas 42.9 #&gt; 5 Macao, China Asia 60.5 #&gt; 6 Qatar Asia 59.1 #&gt; 7 Luxembourg Europe 96 #&gt; 8 Switzerland Europe 80.3 #&gt; 9 Australia Oceania 53.3 #&gt; 10 New Zealand Oceania 35.3 Here, we first filter the observations for the year 2008 and remove the missing values in the continent variable. Then, we group the observations by continent. We use the mutate() function to create a new variable r which represents the rank of the GDP per capita in descending order. The ties.method = \"first\" argument is used to break the ties by giving the same rank to the same values. We then filter the observations that have a rank less than or equal to 2. Finally, we select the variables country, continent, and GDP_per_capita, and arrange the observations according to the continent and the GDP per capita in descending order. 7.6.3 Exercises Using the ahp dataset and the pipe operator for the following exercises. Create a logical variable high_sale_price, which equals TRUE if the house’s sale price exceeds the average sale price for the corresponding month, and FALSE otherwise. Next, create a scatterplot to visualize the relationship between the month and the sale price, using different colors based on whether high_sale_price is TRUE or FALSE. Explain the insights from the plot. Focus on the overall conditions where the number of corresponding houses are at least 30. Then, summarize the number of observations and the average sale price for each overall condition. Find the top two expensive houses that was remodeled each year, show only the remodel year and sale price, and arrange the result in the ascending order of remodel year. Note: if there are ties in the sale price ranking, please include all the tied observations. Group the houses by the combination of kitchen quality (kit_qual) and central AC (central_air), find the two houses with the minimum and maximum sale prices for each group. Then, arrange the groups in the descending order of maximum sale price within each group. "],["joins.html", "7.7 Joins", " 7.7 Joins So far, we have been working on a single data set. In applications, however, we often have the need to combine multiple data sets into a single one before doing data analysis. Let’s prepare two data sets to show the various ways we can join two data sets. library(tidyverse) library(r02pro) top_pop &lt;- gm %&gt;% filter(year == 2008 &amp; !is.na(continent)) %&gt;% mutate(r = rank(desc(population), ties.method = &quot;first&quot;)) %&gt;% filter(r &lt;= 5) %&gt;% select(country, population, HDI_category) %&gt;% arrange(desc(population)) HDI_cate_dict &lt;- tibble(HDI_category = c(&quot;low&quot;, &quot;medium&quot;, &quot;high&quot;), HDI_description = c(&quot;below 0.549&quot;, &quot;between 0.550–0.699&quot;, &quot;between 0.700–0.799&quot;)) Here, top_pop is a tibble of the top 3 countries with the highest population in 2008. HDI_cate_dict is a tibble that provides the description of the Human Development Index (HDI) categories. It is clear that the two tibbles share a variable named HDI_category. It could be interesting to join the two tibbles into a single one by including all variables while matching the values of HDI_category. The bridging variable HDI_category is usually called the key to the joining operation. Next, we will discuss several different join operations between top_pop and HDI_cate_dict, with the key being HDI_category. 7.7.1 Inner Join The first type of join operation on two tables with a set of keys is called inner join. You can use the inner_join(tb1, tb2) function, which returns all rows in tb1 such that there are matching values of the corresponding keys in tb2. inner &lt;- inner_join(top_pop, HDI_cate_dict, by = &quot;HDI_category&quot;) inner #&gt; # A tibble: 4 × 4 #&gt; country population HDI_category HDI_description #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 China 1360000 medium between 0.550–0.699 #&gt; 2 India 1220000 medium between 0.550–0.699 #&gt; 3 Indonesia 239000 medium between 0.550–0.699 #&gt; 4 Brazil 194000 high between 0.700–0.799 From the result, you can see that there are 4 observations. Each observation corresponds to one row in top_pop that has a matching value in HDI_cate_dict for HDI_category. The observation corresponding to United States in top_pop is dropped in the result since its HDI_category value is \"very high\", which doesn’t have a matched row in HDI_cate_dict. 7.7.2 Left Join The second type of join operation on two tables with a set of keys is called left join. You can use the left_join(tb1, tb2) function, which returns all rows in tb1, no matter whether there are matching values of the corresponding keys in tb2. left &lt;- left_join(top_pop, HDI_cate_dict, by = &quot;HDI_category&quot;) left #&gt; # A tibble: 5 × 4 #&gt; country population HDI_category HDI_description #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 China 1360000 medium between 0.550–0.699 #&gt; 2 India 1220000 medium between 0.550–0.699 #&gt; 3 United States 306000 very high &lt;NA&gt; #&gt; 4 Indonesia 239000 medium between 0.550–0.699 #&gt; 5 Brazil 194000 high between 0.700–0.799 As you can see from the result, all rows in top_pop is kept, even though United States doesn’t have a matching observation in HDI_cate_dict for the variable HDI_category. In this case, the corresponding value for HDI_description is NA. 7.7.3 Right Join The third type of join operation on two tables with a set of keys is called right join, which works in a similar fashion as left join. You can use the right_join(tb1, tb2) function, which returns all rows in tb2, no matter whether there are matching values of the corresponding keys in tb1 or not. right &lt;- right_join(top_pop, HDI_cate_dict, by = &quot;HDI_category&quot;) right #&gt; # A tibble: 5 × 4 #&gt; country population HDI_category HDI_description #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 China 1360000 medium between 0.550–0.699 #&gt; 2 India 1220000 medium between 0.550–0.699 #&gt; 3 Indonesia 239000 medium between 0.550–0.699 #&gt; 4 Brazil 194000 high between 0.700–0.799 #&gt; 5 &lt;NA&gt; NA low below 0.549 As you can see from the result, all rows in HDI_cate_dict is kept, even though there aren’t any matching observations in top_pop for HDI_category == \"low\". In this case, the corresponding values for country and population are NA. 7.7.4 Full Join The fourth type of join operation on two tables with a set of keys is called full join. You can use the full_join(tb1, tb2) function, which returns all rows in both tb1 and tb2, no matter whether there are matching values of the keys in either tb1 or tb2. full &lt;- full_join(top_pop, HDI_cate_dict, by = &quot;HDI_category&quot;) full #&gt; # A tibble: 6 × 4 #&gt; country population HDI_category HDI_description #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 China 1360000 medium between 0.550–0.699 #&gt; 2 India 1220000 medium between 0.550–0.699 #&gt; 3 United States 306000 very high &lt;NA&gt; #&gt; 4 Indonesia 239000 medium between 0.550–0.699 #&gt; 5 Brazil 194000 high between 0.700–0.799 #&gt; 6 &lt;NA&gt; NA low below 0.549 As you can see from the result, all rows in both top_pop and HDI_cate_dict are kept. The rows in top_pop that don’t have matching values in HDI_cate_dict are filled with NA for the variables in HDI_cate_dict, and vice versa. 7.7.5 Filtering Joins For the previous four types of joins, the resulting table contains columns from both input tables. Sometimes, you may want to only keep the columns from one of the input tables. This is called filtering joins, meaning that it is actually doing the filtering operations like the filter() function we learned in Section 7.1. a. Semi Join The first type of filtering joins is called semi join, in which semi_join(tb1, tb2) returns all rows from tb1 where there are matching values in tb2 for the keys. semi_join(top_pop, HDI_cate_dict, by = &quot;HDI_category&quot;) #&gt; # A tibble: 4 × 3 #&gt; country population HDI_category #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 China 1360000 medium #&gt; 2 India 1220000 medium #&gt; 3 Indonesia 239000 medium #&gt; 4 Brazil 194000 high From the result, you can see that only the rows in top_pop that have matching values in HDI_cate_dict for HDI_category are kept. Again, the columns from HDI_cate_dict are not included in the output, making it a filtering operation. b. Anti Join Another type of filtering joins is called anti join, in which anti_join(tb1, tb2) returns all rows from tb1 where there don’t exist matching values in tb2 on the keys. anti_join(top_pop, HDI_cate_dict, by = &quot;HDI_category&quot;) #&gt; # A tibble: 1 × 3 #&gt; country population HDI_category #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 United States 306000 very high From the result, you can see that only the rows in top_pop that don’t have matching values in HDI_cate_dict for HDI_category are kept. The columns from HDI_cate_dict are not included in the output, making it a filtering operation. 7.7.6 A Summary of All Joins Finally, we summarize all the six joins in the following table, in terms of which rows and columns are selected in the final output. Code Rows Columns inner_join(tb1, tb2, by) Rows in both tb1 and tb2 Columns in either tb1 or tb2 left_join(tb1, tb2, by) Rows in tb1 Columns in either tb1 or tb2 right_join(tb1, tb2, by) Rows in tb2 Columns in either tb1 or tb2 full_join(tb1, tb2, by) All rows in tb1 or tb2 Columns in either tb1 or tb2 semi_join(tb1, tb2, by) Rows in tb1 with matching keys in tb2 Only columns in tb1 anti_join(tb1, tb2, by) Rows in tb1 without matching keys in tb2 Only columns in tb1 7.7.7 Exercises First, let’s prepare two data sets for the exercises. library(tidyverse) library(r02pro) d1 &lt;- ahp %&gt;% select(dt_sold, bsmt_area, bsmt_ht) %&gt;% head(n = 5) d2 &lt;- tibble(bsmt_ht = c(&quot;Excellent&quot;, &quot;Good&quot;, &quot;Average&quot;, &quot;Poor&quot;), height = c(&quot;100+ inches&quot;, &quot;90-99 inches&quot;, &quot;80-89 inches&quot;, &quot;&lt;70 inches&quot;)) d1 #&gt; # A tibble: 5 × 3 #&gt; dt_sold bsmt_area bsmt_ht #&gt; &lt;date&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 2010-03-25 725 Average #&gt; 2 2009-04-10 913 Good #&gt; 3 2010-01-15 1057 Average #&gt; 4 2010-04-19 384 Good #&gt; 5 2010-03-22 676 Fair d2 #&gt; # A tibble: 4 × 2 #&gt; bsmt_ht height #&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 Excellent 100+ inches #&gt; 2 Good 90-99 inches #&gt; 3 Average 80-89 inches #&gt; 4 Poor &lt;70 inches Perform an inner join between d1 and d2 by the key bsmt_ht. What are the rows and columns in the final output? Perform a left join between d1 and d2 by the key bsmt_ht. What are the rows and columns in the final output? Perform a right join between d1 and d2 by the key bsmt_ht. What are the rows and columns in the final output? Perform a full join between d1 and d2 by the key bsmt_ht. What are the rows and columns in the final output? Perform a semi join between d1 and d2 by the key bsmt_ht. What are the rows and columns in the final output? Perform an anti join between d1 and d2 by the key bsmt_ht. What are the rows and columns in the final output? "],["tidy-data.html", "Chapter 8 Tidy Data", " Chapter 8 Tidy Data In the part several chapters, you have learned a lot in data visualization, data import and export, and data manipulation. All the data you have seen so far share a very attractive property, namely, they are all tidy. So, what is the so called tidy data? Following the definition in Wickham and Grolemund (2016), tidy data has the following three interrelated properties. Each variable must have its own column. Each observation must have its own row. Each value must have its own cell. These properties of tidy data enable us to conduct efficient data manipulation and visualization. Note that in practical applications, many collected data is untidy. Although untidy data could also be very useful in terms of reporting and visually more intuitive, you are recommended to tidy it before applying the tools we learned in this book. References "],["tidy-name-value.html", "8.1 Convert Between Names and Values", " 8.1 Convert Between Names and Values First, let’s prepare a subset of the gm data in the r02pro package. library(r02pro) library(tidyverse) gm_tidy &lt;- gm %&gt;% filter(country %in% c(&quot;United States&quot;, &quot;China&quot;, &quot;Russia&quot;)) %&gt;% select(country, year, life_expectancy) %&gt;% filter(year &gt;= 2004 &amp; year &lt;= 2006) gm_tidy #&gt; # A tibble: 9 × 3 #&gt; country year life_expectancy #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 China 2004 73 #&gt; 2 Russia 2004 65 #&gt; 3 United States 2004 77.7 #&gt; 4 China 2005 73.7 #&gt; 5 China 2006 74.2 #&gt; 6 Russia 2005 66.5 #&gt; 7 Russia 2006 67.5 #&gt; 8 United States 2005 78 #&gt; 9 United States 2006 78.2 From the code, you can see that gm_tidy is a tibble that contains the life expectancy of the United States, China, and Russia from 2004 to 2006. This is a tidy format. 8.1.1 Convert Values into Column Names In gm_tidy, each row contains the year when the life expectancy measurement was taken. Suppose we want to convert the year value into column names. You can use the pivot_wider() function. In pivot_wider(), you need to specify two arguments: names_from denotes which column in the original tibble contains the values of the new column names, values_from denotes which column in the original tibble contains the values for each cell in the new tibble. gm_wide &lt;- gm_tidy %&gt;% pivot_wider(names_from = year, values_from = life_expectancy) gm_wide #&gt; # A tibble: 3 × 4 #&gt; country `2004` `2005` `2006` #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 China 73 73.7 74.2 #&gt; 2 Russia 65 66.5 67.5 #&gt; 3 United States 77.7 78 78.2 From the resulting tibble gm_wide, you can see that the year variable is converted into column names. The life_expectancy variable contains the corresponding values. The gm_wide is now in a wide format. During the process, the year information is lost, which is not desirable. Fortunately, you can add a prefix “year” to the column names via an argument names_prefix in the pivot_wider() function. gm_wide_year &lt;- gm_tidy %&gt;% pivot_wider(names_from = year, names_prefix = &quot;year&quot;, values_from = life_expectancy) gm_wide_year #&gt; # A tibble: 3 × 4 #&gt; country year2004 year2005 year2006 #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 China 73 73.7 74.2 #&gt; 2 Russia 65 66.5 67.5 #&gt; 3 United States 77.7 78 78.2 In the resulting tibble gm_wide_year, you can see that the column names are prefixed with “year”. The year information is now reflected in the names of the tibble. The reason why we call the function pivot_wider() is that it will create a wider dataset than the original one, containing more columns. 8.1.2 Convert Column Names into Values Apparently, both gm_wide and gm_wide_year are not tidy. Now, let’s make them tidy using the pivot_longer() function. gm_wide %&gt;% pivot_longer(cols = -1, names_to = &quot;year&quot;, values_to = &quot;life_expectancy&quot;) #&gt; # A tibble: 9 × 3 #&gt; country year life_expectancy #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 China 2004 73 #&gt; 2 China 2005 73.7 #&gt; 3 China 2006 74.2 #&gt; 4 Russia 2004 65 #&gt; 5 Russia 2005 66.5 #&gt; 6 Russia 2006 67.5 #&gt; 7 United States 2004 77.7 #&gt; 8 United States 2005 78 #&gt; 9 United States 2006 78.2 In the pivot_longer() function, cols specifies the column names that you want to convert from, which accept the same format as that in dplyr::select() introduced in Section 7.2. names_to specifies the variable name you want to use for the column names. values_to specifies the variable name for holding the values in the selected columns. In the resulting tibble, col = -1 means that all columns except the first column are selected. The column names 2004, 2005, and 2006 are converted into values of the variable year. The life_expectancy variable contains the corresponding values. We have recovered the tidy gm_tidy through the tidy process. The reason why we call the function pivot_longer() is that it will create a longer dataset than the original one, containing more rows. Now, let’s tidy gm_wide_year using the pivot_longer() function. gm_wide_year %&gt;% pivot_longer(cols = -1, names_to = &quot;year&quot;, names_prefix = &quot;year&quot;, values_to = &quot;life_expectancy&quot;) #&gt; # A tibble: 9 × 3 #&gt; country year life_expectancy #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 China 2004 73 #&gt; 2 China 2005 73.7 #&gt; 3 China 2006 74.2 #&gt; 4 Russia 2004 65 #&gt; 5 Russia 2005 66.5 #&gt; 6 Russia 2006 67.5 #&gt; 7 United States 2004 77.7 #&gt; 8 United States 2005 78 #&gt; 9 United States 2006 78.2 Note that we have an extra argument names_prefix in the pivot_longer() function. This argument is used to remove the prefix “year” from the column names. Comparing the pivot_wider() and pivot_longer() functions, you can see that they are complementary. The pivot_wider() function converts values into column names, while the pivot_longer() function converts column names into values. 8.1.3 Multiple Variables In the gm dataset, there are multiple variables that you may want to convert into column names. You can specify multiple variables in the names_from argument in the pivot_wider() function. gm_tidy &lt;- gm %&gt;% filter(country %in% c(&quot;United States&quot;, &quot;China&quot;, &quot;Russia&quot;)) %&gt;% select(country, year, life_expectancy, GDP_per_capita) %&gt;% filter(year &gt;= 2004 &amp; year &lt;= 2006) gm_tidy #&gt; # A tibble: 9 × 4 #&gt; country year life_expectancy GDP_per_capita #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 China 2004 73 3.39 #&gt; 2 Russia 2004 65 8.93 #&gt; 3 United States 2004 77.7 52.8 #&gt; 4 China 2005 73.7 3.8 #&gt; 5 China 2006 74.2 4.32 #&gt; 6 Russia 2005 66.5 9.69 #&gt; 7 Russia 2006 67.5 10.5 #&gt; 8 United States 2005 78 53.8 #&gt; 9 United States 2006 78.2 54.3 gm_wide &lt;- gm_tidy %&gt;% pivot_wider(names_from = c(country, year), values_from = c(life_expectancy, GDP_per_capita), names_sep = &quot;-&quot;) gm_wide #&gt; # A tibble: 1 × 18 #&gt; life_expecta…¹ life_…² life_…³ life_…⁴ life_…⁵ life_…⁶ life_…⁷ life_…⁸ life_…⁹ #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 73 65 77.7 73.7 74.2 66.5 67.5 78 78.2 #&gt; # … with 9 more variables: `GDP_per_capita-China-2004` &lt;dbl&gt;, #&gt; # `GDP_per_capita-Russia-2004` &lt;dbl&gt;, #&gt; # `GDP_per_capita-United States-2004` &lt;dbl&gt;, #&gt; # `GDP_per_capita-China-2005` &lt;dbl&gt;, `GDP_per_capita-China-2006` &lt;dbl&gt;, #&gt; # `GDP_per_capita-Russia-2005` &lt;dbl&gt;, `GDP_per_capita-Russia-2006` &lt;dbl&gt;, #&gt; # `GDP_per_capita-United States-2005` &lt;dbl&gt;, #&gt; # `GDP_per_capita-United States-2006` &lt;dbl&gt;, and abbreviated variable names … In the pivot_wider() function, you can specify multiple variables in the names_from and values_from arguments. The resulting tibble gm_wide contains the life expectancy and GDP per capita of the United States, China, and Russia from 2004 to 2006. The column names are in the format of country_year_variable. Note that we have an extra argument names_sep in the pivot_wider() function. This argument is used to separate the column names with a hyphen \"-\". We didn’t use the separator \"_\" because it is already used in the column names of the original tibble. To make the tibble tidy, you can use the pivot_longer() function. gm_wide %&gt;% pivot_longer(cols = everything(), names_to = c(&quot;.value&quot;, &quot;country&quot;, &quot;year&quot;), names_sep = &quot;-&quot;) #&gt; # A tibble: 9 × 4 #&gt; country year life_expectancy GDP_per_capita #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 China 2004 73 3.39 #&gt; 2 Russia 2004 65 8.93 #&gt; 3 United States 2004 77.7 52.8 #&gt; 4 China 2005 73.7 3.8 #&gt; 5 China 2006 74.2 4.32 #&gt; 6 Russia 2005 66.5 9.69 #&gt; 7 Russia 2006 67.5 10.5 #&gt; 8 United States 2005 78 53.8 #&gt; 9 United States 2006 78.2 54.3 Here, we use the everything() function to select all columns. The names_to argument specifies the variable names for the column names. The \".value\" is a special value that tells the function to keep the values in the selected columns. The country and year variables are used to store the country and year values in the column names. The names_sep argument specifies the separator used in the column names. Now, let’s see another example. gm_gender &lt;- gm %&gt;% filter(country %in% c(&quot;United States&quot;, &quot;China&quot;, &quot;Russia&quot;)) %&gt;% filter(year == 2004) %&gt;% select(country, ends_with(&quot;male&quot;)) gm_gender #&gt; # A tibble: 3 × 15 #&gt; country smokin…¹ smoki…² lungc…³ lungc…⁴ alcoh…⁵ alcoh…⁶ liver…⁷ liver…⁸ #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 China 3.7 59.5 23 57.5 6.32 1.63 48.3 17.2 #&gt; 2 Russia 26.5 70.1 7.69 69.1 28.5 7.97 7.34 3.45 #&gt; 3 United States 21.5 26.3 44.1 67.5 14.7 4.46 8.59 3.07 #&gt; # … with 6 more variables: mortality_male &lt;dbl&gt;, mortality_female &lt;dbl&gt;, #&gt; # cholesterol_fat_in_blood_male &lt;dbl&gt;, cholesterol_fat_in_blood_female &lt;dbl&gt;, #&gt; # BMI_female &lt;dbl&gt;, BMI_male &lt;dbl&gt;, and abbreviated variable names #&gt; # ¹​smoking_female, ²​smoking_male, ³​lungcancer_newcases_female, #&gt; # ⁴​lungcancer_newcases_male, ⁵​alcohol_male, ⁶​alcohol_female, #&gt; # ⁷​livercancer_newcases_male, ⁸​livercancer_newcases_female Here, we have selected the columns that end with male. One tricky part is that some columns contain more than one underscores, making the pattern a bit more complicated. We want to convert the column names into values. gm_gender %&gt;% pivot_longer(cols = -1, names_to = c(&quot;.value&quot;, &quot;gender&quot;), names_pattern = &quot;(.+)_(?!.*_)(.+)&quot;) #&gt; # A tibble: 6 × 9 #&gt; country gender smoking lungcance…¹ alcohol liver…² morta…³ chole…⁴ BMI #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 China female 3.7 23 1.63 17.2 16.9 4.53 22.8 #&gt; 2 China male 59.5 57.5 6.32 48.3 26.1 4.44 22.8 #&gt; 3 Russia female 26.5 7.69 7.97 3.45 24.2 5.11 26.9 #&gt; 4 Russia male 70.1 69.1 28.5 7.34 51.9 4.93 25.6 #&gt; 5 United States female 21.5 44.1 4.46 3.07 13.1 5.22 28.1 #&gt; 6 United States male 26.3 67.5 14.7 8.59 19.3 5.16 28.2 #&gt; # … with abbreviated variable names ¹​lungcancer_newcases, #&gt; # ²​livercancer_newcases, ³​mortality, ⁴​cholesterol_fat_in_blood In the pivot_longer() function, the names_to argument specifies the variable names for the column names. Here, the \".value\" is a special value that tells the function to keep the values in the selected columns. The gender variable is used to store the values of the column names. The names_pattern argument specifies the pattern of the column names. The (.+)_(?!.*_)(.+) regular expression uses a negative lookahead assertion to identify the last underscore. In particular, (.+): Captures everything before the last underscore. _(?!.*_): Matches an underscore only if it’s not followed by another underscore. (.+): Captures everything after the last underscore. 8.1.4 Exercises You are given the following dataset. df &lt;- tibble( country = c(&quot;A&quot;, &quot;A&quot;, &quot;B&quot;, &quot;B&quot;), year = c(2000, 2001, 2000, 2001), life_expectancy = c(70, 71, 75, 76), infant_mortality = c(5, 4.5, 3, 2.8) ) Create a wide-format dataset where: Each row represents a country. Columns represent combinations of year and a demographic variable (e.g., ‘2000_life_expectancy’, ‘2000_infant_mortality’, ‘2001_life_expectancy’, etc.). Use the wide-format dataset created in Exercise 1, transform the data back into a tidy format. You are given the following dataset. df &lt;- tibble( country = c(&quot;A&quot;, &quot;B&quot;, &quot;C&quot;), life_expectancy_male = c(72, 78, 75), life_expectancy_female = c(78, 83, 80) ) Tidy the dataset so that it contains the following columns: country, gender, and life_expectancy. You are given the following dataset. df &lt;- tibble( group = c(&quot;A&quot;, &quot;B&quot;), q1_pre = c(10, 12), q1_post = c(15, 18), q2_pre = c(7, 9), q2_post = c(11, 13) ) Tidy the dataset so that it contains the following columns: group, question, time, and score, where question is either q1 or q2, time is either pre or post, and score is the corresponding value. "],["separate-unite-columns.html", "8.2 Separate and Combine Columns via separate() and unite()", " 8.2 Separate and Combine Columns via separate() and unite() Real-world data is often messy. Sometimes, valuable information is crammed into a single column, making it difficult to analyze. Other times, separate columns might need to be combined for specific tasks. The separate() and unite() functions in tidyr provide powerful tools to reshape your data and make it tidy for analysis. Imagine a dataset with a column like ‘City, State’. separate() allows you to split this into separate 'City' and 'State' columns. Conversely, unite() can combine 'First Name' and 'Last Name' columns into a single 'Full Name' column. To introduce the separate and and unite operation, let’s again consider the following tidy data set. library(r02pro) library(tidyverse) gm_tidy &lt;- gm %&gt;% filter(country %in% c(&quot;United States&quot;, &quot;China&quot;, &quot;Russia&quot;)) %&gt;% select(country, year, life_expectancy) %&gt;% filter(year &gt;= 2004 &amp; year &lt;= 2006) gm_tidy #&gt; # A tibble: 9 × 3 #&gt; country year life_expectancy #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 China 2004 73 #&gt; 2 Russia 2004 65 #&gt; 3 United States 2004 77.7 #&gt; 4 China 2005 73.7 #&gt; 5 China 2006 74.2 #&gt; 6 Russia 2005 66.5 #&gt; 7 Russia 2006 67.5 #&gt; 8 United States 2005 78 #&gt; 9 United States 2006 78.2 8.2.1 Combine Columns via unite() Sometimes, we may want to combine multiple columns into a single one. To do this, you can use the unite() function in the tidyr package. In the unite() function, you need to specify the name of the to-be created column (col), the columns to be combined, and the separator between the columns (sep). gm_year &lt;- gm_tidy %&gt;% unite(col = &quot;country_year&quot;, country, year, sep = &quot;_&quot;) gm_year #&gt; # A tibble: 9 × 2 #&gt; country_year life_expectancy #&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 China_2004 73 #&gt; 2 Russia_2004 65 #&gt; 3 United States_2004 77.7 #&gt; 4 China_2005 73.7 #&gt; 5 China_2006 74.2 #&gt; 6 Russia_2005 66.5 #&gt; 7 Russia_2006 67.5 #&gt; 8 United States_2005 78 #&gt; 9 United States_2006 78.2 Now, the gm_year tibble contains a new column country_year, which is the combination of the country and year columns. The separator between the two columns is an underscore _. 8.2.2 Separate One Column into Multiple Columns Using separate() We know the unite() function combine multiple columns into a single column. Sometimes, we need to do the opposite operation, namely separate one column into multiple ones. For example, gm_year is not a tidy dataset since the country_year column contains two variables. To make it tidy, you can use the separate() function. In the separate() function, you need to specify col: the name of the column to be separated into: the desired names of the to-be created columns after separation sep: the separator during the separation process For the country_year column in the gm_year tibble, we can separate it into two columns: country and year. gm_year %&gt;% separate(col = &quot;country_year&quot;, into = c(&quot;country&quot;, &quot;year&quot;), sep = &quot;_&quot;) #&gt; # A tibble: 9 × 3 #&gt; country year life_expectancy #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 China 2004 73 #&gt; 2 Russia 2004 65 #&gt; 3 United States 2004 77.7 #&gt; 4 China 2005 73.7 #&gt; 5 China 2006 74.2 #&gt; 6 Russia 2005 66.5 #&gt; 7 Russia 2006 67.5 #&gt; 8 United States 2005 78 #&gt; 9 United States 2006 78.2 From the result, you can see that the original tidy tibble is recovered via the separate() function. After a careful look, you may notice that the column types of country and year are both character, which may not be what we want. To convert the types automatically, you can add the convert = TRUE argument in the separate() function. gm_year %&gt;% separate(col = &quot;country_year&quot;, into = c(&quot;country&quot;, &quot;year&quot;), sep = &quot;_&quot;, convert = TRUE) #&gt; # A tibble: 9 × 3 #&gt; country year life_expectancy #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 China 2004 73 #&gt; 2 Russia 2004 65 #&gt; 3 United States 2004 77.7 #&gt; 4 China 2005 73.7 #&gt; 5 China 2006 74.2 #&gt; 6 Russia 2005 66.5 #&gt; 7 Russia 2006 67.5 #&gt; 8 United States 2005 78 #&gt; 9 United States 2006 78.2 Now, the country and year columns are converted to the appropriate types. In addition to separating via the separator, you can also separate by the position. For example, to separate the year into century (first two digits) and 2-digit year (last 2 digits), you can separate the year after position 2. gm_tidy %&gt;% separate(col = &quot;year&quot;, into = c(&quot;y12&quot;, &quot;y34&quot;), sep = 2, convert = TRUE) #&gt; # A tibble: 9 × 4 #&gt; country y12 y34 life_expectancy #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 China 20 4 73 #&gt; 2 Russia 20 4 65 #&gt; 3 United States 20 4 77.7 #&gt; 4 China 20 5 73.7 #&gt; 5 China 20 6 74.2 #&gt; 6 Russia 20 5 66.5 #&gt; 7 Russia 20 6 67.5 #&gt; 8 United States 20 5 78 #&gt; 9 United States 20 6 78.2 From the result, you can see that the year column is separated into two columns: y12 and y34. The y12 column contains the first two digits of the year, while the y34 column contains the last two digits of the year. You can also separate at multiple locations. For example, to separate the year into four columns, representing four digits, you can use multiple positions to separate. gm_digits &lt;- gm_tidy %&gt;% separate(col = &quot;year&quot;, into = c(&quot;y1&quot;, &quot;y2&quot;, &quot;y3&quot;, &quot;y4&quot;), sep = c(1, 2, 3), convert = TRUE) gm_digits #&gt; # A tibble: 9 × 6 #&gt; country y1 y2 y3 y4 life_expectancy #&gt; &lt;chr&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 China 2 0 0 4 73 #&gt; 2 Russia 2 0 0 4 65 #&gt; 3 United States 2 0 0 4 77.7 #&gt; 4 China 2 0 0 5 73.7 #&gt; 5 China 2 0 0 6 74.2 #&gt; 6 Russia 2 0 0 5 66.5 #&gt; 7 Russia 2 0 0 6 67.5 #&gt; 8 United States 2 0 0 5 78 #&gt; 9 United States 2 0 0 6 78.2 Using the gm_digits, you can also combine the four columns into a single column named year. gm_digits %&gt;% unite(col = &quot;year&quot;, y1:y4, sep = &quot;&quot;) #&gt; # A tibble: 9 × 3 #&gt; country year life_expectancy #&gt; &lt;chr&gt; &lt;chr&gt; &lt;dbl&gt; #&gt; 1 China 2004 73 #&gt; 2 Russia 2004 65 #&gt; 3 United States 2004 77.7 #&gt; 4 China 2005 73.7 #&gt; 5 China 2006 74.2 #&gt; 6 Russia 2005 66.5 #&gt; 7 Russia 2006 67.5 #&gt; 8 United States 2005 78 #&gt; 9 United States 2006 78.2 Note that the sep argument in the unite() function is an empty string \"\". This means that there is no separator between the columns. 8.2.3 Exercises You have a tibble containing data on disease outbreaks, but the location column combines the country and city. outbreaks &lt;- tibble( outbreak_id = c(1, 2, 3), disease = c(&quot;Measles&quot;, &quot;Influenza&quot;, &quot;Cholera&quot;), location = c(&quot;USA_New York City&quot;, &quot;Brazil_Sao Paulo&quot;, &quot;India_Mumbai&quot;) ) outbreaks #&gt; # A tibble: 3 × 3 #&gt; outbreak_id disease location #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 Measles USA_New York City #&gt; 2 2 Influenza Brazil_Sao Paulo #&gt; 3 3 Cholera India_Mumbai Separate the location column into country and city columns. You have a tibble with separate columns for patient medical record numbers and visit dates. patients &lt;- tibble( patient_id = c(1, 2, 3), record_number = c(&quot;A123&quot;, &quot;B456&quot;, &quot;C789&quot;), visit_date = c(&quot;2024-10-15&quot;, &quot;2024-09-22&quot;, &quot;2024-10-16&quot;) ) patients #&gt; # A tibble: 3 × 3 #&gt; patient_id record_number visit_date #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 A123 2024-10-15 #&gt; 2 2 B456 2024-09-22 #&gt; 3 3 C789 2024-10-16 Combine the record_number and visit_date columns into a single column named record_date with the format “record_number - visit_date”. You have a tibble with a vaccine_date column in the format “YYYY-MM-DD”. vaccinations &lt;- tibble( patient_id = c(1, 2, 3), vaccine_name = c(&quot;MMR&quot;, &quot;Flu&quot;, &quot;Tdap&quot;), vaccine_date = c(&quot;2023-08-10&quot;, &quot;2024-10-05&quot;, &quot;2022-06-15&quot;) ) vaccinations #&gt; # A tibble: 3 × 3 #&gt; patient_id vaccine_name vaccine_date #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 1 MMR 2023-08-10 #&gt; 2 2 Flu 2024-10-05 #&gt; 3 3 Tdap 2022-06-15 Split the vaccine_date column into three columns: year, month, and day. Create a new column called month_year in the format “MM/YYYY”. You have a tibble with responses to a health survey, but some responses in the symptoms column are separated by commas, while others are separated by semicolons. survey_data &lt;- tibble( respondent_id = c(1, 2, 3), symptoms = c(&quot;Headache, Fatigue&quot;, &quot;Nausea; Vomiting&quot;, &quot;Cough&quot;) ) survey_data #&gt; # A tibble: 3 × 2 #&gt; respondent_id symptoms #&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 1 Headache, Fatigue #&gt; 2 2 Nausea; Vomiting #&gt; 3 3 Cough Split the symptoms column into symptom1 and symptom2 columns, handling the different separators correctly. "],["strings.html", "Chapter 9 Strings", " Chapter 9 Strings In Section 2.2, we have introduced the character vector that is consisted of strings. In this Chapter, we will introduce various kinds of operations we can do on strings using the stringr package, which is a subpackage of tidyverse. "],["combine-subset-strings.html", "9.1 Concatenate and Subset Strings", " 9.1 Concatenate and Subset Strings 9.1.1 Concatenate Strings First, let’s introduce how to concatenate multiple strings into a single string. To do this, we will use the str_c() function in the stringr package. library(stringr) str_c(&quot;I&quot;, &quot;am&quot;, &quot;learning&quot;, &quot;R!&quot;) #equivalent to `paste0()` #&gt; [1] &quot;IamlearningR!&quot; Similar to the paste() function, you can specify a separator between the input strings. str_c(&quot;I&quot;, &quot;am&quot;, &quot;learning&quot;, &quot;R!&quot;, sep = &quot; &quot;) #&gt; [1] &quot;I am learning R!&quot; str_c(&quot;apple&quot;, &quot;banana&quot;, &quot;cherry&quot;, sep = &quot;&amp;&quot;) #&gt; [1] &quot;apple&amp;banana&amp;cherry&quot; The str_c() can also accept vectors of length greater than one as its arguments, where it will conduct the concatenating operation elementwisely. str_c(&quot;There are&quot;, 3:5, c(&quot;apples&quot;, &quot;bananas&quot;, &quot;cherries&quot;), &quot;in the kitchen.&quot;, sep = &quot; &quot;) #&gt; [1] &quot;There are 3 apples in the kitchen.&quot; #&gt; [2] &quot;There are 4 bananas in the kitchen.&quot; #&gt; [3] &quot;There are 5 cherries in the kitchen.&quot; As you can see from the result, the first and third string are recycled to match the length of the second string. Next, let’s introduce how to concatenate the strings inside a chracter vector. First, let’s try to apply the str_c() function on a character vector. fruits &lt;- c(&quot;apples&quot;, &quot;bananas&quot;, &quot;cherries&quot;) str_c(fruits) #&gt; [1] &quot;apples&quot; &quot;bananas&quot; &quot;cherries&quot; Apparently, we didn’t get the expected concatenated string. To do so, we need to add an argument collapse as the separator. str_c(fruits, collapse = &quot;|&quot;) #&gt; [1] &quot;apples|bananas|cherries&quot; str_c(fruits, collapse = &quot;-&quot;) #&gt; [1] &quot;apples-bananas-cherries&quot; When we have multiple character vectors as the arguments in the str_c() function with the collapse argument, the character vectors will first be concatenated respectively, and then the concatenated strings will be further concatenated with the separator as in the collapse argument. str_c(fruits, fruits, collapse = &quot;|&quot;) #&gt; [1] &quot;applesapples|bananasbananas|cherriescherries&quot; Here, the str_c() function will first concatenate the fruits vector with itself, and then concatenate the two concatenated strings with the separator |. 9.1.2 Create and Modify Substrings It is often of interest to create substrings from an existing string. A substring is a string formed by a consecutive sequence of characters within the existing string. To get a substring, you can use the substr() function. The start and end arguments represent the starting and ending position of the desired substrings. str_sub(fruits, start = 1, end = 3) #&gt; [1] &quot;app&quot; &quot;ban&quot; &quot;che&quot; Here, you will get a substring from position 1 to position 3 for each element of the original character vector. In addition to using the positive integer to represent the position, you can also use negative integer to represent the relative position from the last symbol. str_sub(fruits, start = 1, end = -2) #&gt; [1] &quot;apple&quot; &quot;banana&quot; &quot;cherrie&quot; Here, for each string, we extract the substring from position 1 to the second to last position. In addition to using one integer for start and end, you can also supply a vector of the same length as the input vector to extract multiple substrings at once. str_sub(fruits, start = 1:3, end = (-1):(-3)) #&gt; [1] &quot;apples&quot; &quot;anana&quot; &quot;erri&quot; Let’s look at the result together. From the results, we can see that the substrings are extracted as follows: The first element is the first to the last position of \"apples\". The second element is the second to the second to last position of \"bananas\". The third element is the third to the third to last position of \"cherries\". Once we know how to create the substring, it is straightforward to modify the substing in place of the original string. Let’s try to update the substrings. fruits_new &lt;- fruits str_sub(fruits_new, start = 1:3, end = (-1):(-3)) &lt;- c(&quot;ns_1&quot;, &quot;ns_2&quot;, &quot;ns_3&quot;) fruits_new #&gt; [1] &quot;ns_1&quot; &quot;bns_2s&quot; &quot;chns_3es&quot; fruits #&gt; [1] &quot;apples&quot; &quot;bananas&quot; &quot;cherries&quot; From the results, we can see the corresponding substrings are replaced by \"ns_1\", \"ns_2\", \"ns_3\", respectively. 9.1.3 Exercises (String Concatenation) Create a character vector fruits with the elements \"apple\", \"banana\", and \"cherry\". Use the str_c() function to concatenate the elements in the fruits vector with the separator \" &amp; \". (Create Substrings) Create a character vector colors with the elements \"red\", \"green\", \"blue\", \"yellow\", and \"purple\". Use the str_sub() function to extract the substrings from the second to the fourth position of each element in the colors vector. (Update Substring) Create a character vector animals with the elements \"cat\", \"dog\", \"elephant\", and \"giraffe\". Use the str_sub() function to update the substrings from the second to the fourth position of each element in the animals vector to \"at\", \"og\", \"leph\", and \"iraf\", respectively. Verify the contents. "],["match-pattern.html", "9.2 Matching Pattern with Regular Expressions", " 9.2 Matching Pattern with Regular Expressions Regular expressions provide a powerful and flexible way to find and manipulate text based on patterns of characters. They are essential tools for various tasks in data analysis and programming, including: Data cleaning: Standardizing formats of names, addresses, or phone numbers. Validation: Ensuring user input adheres to expected patterns (e.g., email addresses). Text extraction: Isolating keywords, dates, or other crucial information from documents. This section introduces you to the fundamentals of regular expressions in R, using the stringr package. library(stringr) The stringr package provides a very useful function called str_view() to highlight the elements that match the given pattern. To create a logical vector that reflect this match, you can use the str_detect() function. 9.2.1 Basic Pattern Matching We’ll utilize a sample character vector to illustrate these concepts. sample_names &lt;- c(&quot;apple_pie&quot;, &quot;banana_bread&quot;, &quot;cherry_pie&quot;, &quot;chocolate_cake&quot;, &quot;apple_crumble&quot;) Let’s describe a few commonly used patterns. a. matching literal strings The simplest form of pattern matching involves searching for a specific sequence of characters. To find all variable names containing the exact string \"pie\", you can run the following. str_view(sample_names, &quot;pie&quot;) #&gt; [1] │ apple_&lt;pie&gt; #&gt; [3] │ cherry_&lt;pie&gt; Here, the str_view() function highlights the variable names that contain the string \"pie\". str_detect(sample_names, &quot;pie&quot;) #&gt; [1] TRUE FALSE TRUE FALSE FALSE The str_detect() function returns a logical vector that reflects whether this is a match. In the rest of this section, we will be focusing on demonstration with str_view(). b. using wildcards The period (.) acts as a wildcard, matching any single character. This allows for more flexible pattern definitions. For example, to find all variable names that contain the letter \"c\" followed by any character, you can use the pattern \".c\". str_view(sample_names, &quot;.c&quot;) #&gt; [4] │ ch&lt;oc&gt;olate&lt;_c&gt;ake #&gt; [5] │ apple&lt;_c&gt;rumble str_view(sample_names, &quot;._pi.&quot;) #&gt; [1] │ appl&lt;e_pie&gt; #&gt; [3] │ cherr&lt;y_pie&gt; The first pattern \".p\" represents any character plus the letter c. Note that \"cherry_pie\" is not a match since it doesn’t have any character before the letter \"c\". The second pattern \"._pi.\" represents any character plus the string \"_pi\" plus any character. c. including anchors Anchors allow you to specify the position of a match within a string: - ^ matches the start of a string. - $ matches the end of a string. For example, to find all variable names that start with the letter \"c\", you can use the pattern \"^c\". str_view(sample_names, &quot;^c&quot;) #&gt; [3] │ &lt;c&gt;herry_pie #&gt; [4] │ &lt;c&gt;hocolate_cake Now, let’s find the strings the end with \"pie\". str_view(sample_names, &quot;pie$&quot;) #&gt; [1] │ apple_&lt;pie&gt; #&gt; [3] │ cherry_&lt;pie&gt; 9.2.2 Character Classes a. matching single characters Sometimes, we may want to match the characters with a specific class or a group of values instead of exact values. Here is a table of the commonly used classes. Class Description \\d Matches any digit (0-9) \\s Matches any whitespace character (space, tab, newline) [xyz] Matches any one of the characters within the brackets (x, y, or z) [^xyz] Matches any character except those within the brackets [a-z] or [:lower:] Matches any lowercase letter [A-Z] or [:upper:] Matches any uppercase letter Let’s see some examples. my_char &lt;- c(&quot;abc&quot;,&quot;a1&quot;,&quot;2b&quot;,&quot;33c&quot;,&quot;d 2&quot;, &quot;d f 3&quot;) str_view(my_char, &quot;\\\\d&quot;) # Matches strings containing a digit #&gt; [2] │ a&lt;1&gt; #&gt; [3] │ &lt;2&gt;b #&gt; [4] │ &lt;3&gt;&lt;3&gt;c #&gt; [5] │ d &lt;2&gt; #&gt; [6] │ d f &lt;3&gt; str_view(my_char, &quot;\\\\s\\\\d&quot;) # Matches a whitespace followed by a digit #&gt; [5] │ d&lt; 2&gt; #&gt; [6] │ d f &lt; 3&gt; str_view(my_char, &quot;[ac3]&quot;) # Matches strings containing &#39;a&#39;, &#39;c&#39;, or &#39;3&#39; #&gt; [1] │ &lt;a&gt;b&lt;c&gt; #&gt; [2] │ &lt;a&gt;1 #&gt; [4] │ &lt;3&gt;&lt;3&gt;&lt;c&gt; #&gt; [6] │ d f &lt;3&gt; str_view(my_char, &quot;[^abc3]&quot;) # Matches strings containing characters other than &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, or &#39;3&#39; #&gt; [2] │ a&lt;1&gt; #&gt; [3] │ &lt;2&gt;b #&gt; [5] │ &lt;d&gt;&lt; &gt;&lt;2&gt; #&gt; [6] │ &lt;d&gt;&lt; &gt;&lt;f&gt;&lt; &gt;&lt; &gt;3 Here, \\\\d indicates that as long as the string contains a digit, it will be matched. As a result, \"a1\", \"2b\", and \"33c\" are matched. Note that you need to escape the backslash \\ by using two backslashes \\\\ within R strings. b. matching repeated characters To match a character or group of characters multiple times in a row, you can use quantifiers: Symbol Description {n} Matches exactly n occurrences of the preceding element. {n,} Matches n or more occurrences. {n,m} Matches at least n and at most m occurrences. ? Matches zero or one occurrence (equivalent to {0,1}). + Matches one or more occurrences (equivalent to {1,}). * Matches zero or more occurrences (equivalent to {0,}). Let’s see some examples. my_str_rep &lt;- c(&quot;bbbb&quot;, &quot;1234a&quot;, &quot;bbb&quot;, &quot;abcdef&quot;, &quot;bb ee&quot;, &quot;123456789&quot;) str_view(my_str_rep, &quot;b{3}&quot;) # Matches consecutive three &#39;b&#39;s #&gt; [1] │ &lt;bbb&gt;b #&gt; [3] │ &lt;bbb&gt; Here, \"b{3}\" indicates that the string should contain exactly three \"b\"s. As a result, \"bbbb\" and \"bbb\" are matched. str_view(my_str_rep, &quot;[1-9]{9}&quot;) # Matches a 9-digit number #&gt; [6] │ &lt;123456789&gt; Here, \"[1-9]{9}\" indicates that the string should contain exactly nine digits. As a result, \"123456789\" is matched. str_view(my_str_rep, &quot;[a-z]{4}&quot;) # Matches four consecutive lowercase letters #&gt; [1] │ &lt;bbbb&gt; #&gt; [4] │ &lt;abcd&gt;ef Here, \"[a-z]{4}\" indicates that the string should match exactly four consecutive lowercase letters. As a result, \"bbbb\" and \"abcdef\" are matched. Note that \"bb ee\" is not matched due to the space. str_view(my_str_rep, &quot;[a-z1-9]{4,}&quot;) # Matches at least four consecutive lowercase letters or digits #&gt; [1] │ &lt;bbbb&gt; #&gt; [2] │ &lt;1234a&gt; #&gt; [4] │ &lt;abcdef&gt; #&gt; [6] │ &lt;123456789&gt; Finally, \"[a-z1-9]{4,}\" indicates that the string should contain at least four consecutive lowercase letters or digits. As a result, \"bbbb\", 1234a”,“abcdef”, and“123456789”` are matched. 9.2.3 Combining Patterns with Logical Operators You can combine multiple patterns using logical operators: Symbol Description | Matches either the pattern on the left or the right (OR). &amp; Requires both patterns to match (AND). () Groups patterns to control the scope of operators. Let’s see some examples. my_str_comb &lt;- c(&quot;abc&quot;, &quot;123&quot;, &quot;abc123&quot;, &quot;123abc&quot;, &quot;abc123def&quot;) str_view(my_str_comb, &quot;abc|123&quot;) # Matches either &#39;abc&#39; or &#39;123&#39; #&gt; [1] │ &lt;abc&gt; #&gt; [2] │ &lt;123&gt; #&gt; [3] │ &lt;abc&gt;&lt;123&gt; #&gt; [4] │ &lt;123&gt;&lt;abc&gt; #&gt; [5] │ &lt;abc&gt;&lt;123&gt;def Here, \"abc|123\" indicates that the string should contain either \"abc\" or \"123\". As a result, \"abc\", \"123\", \"abc123\", \"123abc\", and \"abc123def\" are matched. str_view(my_str_comb, &quot;abc&amp;123&quot;) # Matches &#39;abc&#39; followed by &#39;123&#39; Here, \"abc&amp;123\" indicates that the string should contain a substring that matches both \"abc\" and \"123\", which is impossible. As a result, no matches are found. str_view(my_str_comb, &quot;(abc|123)abc&quot;) #&gt; [4] │ &lt;123abc&gt; Here, \"(abc|123)abc\" indicates that the string should contain either \"abc\" or \"123\" followed by \"abc\". As a result, \"abc123\" is matched. str_view(my_str_comb, &quot;abc|123abc&quot;) #&gt; [1] │ &lt;abc&gt; #&gt; [3] │ &lt;abc&gt;123 #&gt; [4] │ &lt;123abc&gt; #&gt; [5] │ &lt;abc&gt;123def Here, \"abc|123abc\" indicates that the string should contain either \"abc\" or \"123abc\". As a result, \"abc\", \"abc123\", and \"abc123def\" are matched. Comparing the last two examples, the parentheses () are used to group the patterns to control the scope of the operators. 9.2.4 Conclusion Regular expressions provide a powerful and flexible way to find and manipulate text based on patterns of characters. In this section, we introduced you to the fundamentals of regular expressions in R, using the stringr package. We demonstrated how to match literal strings, use wildcards, include anchors, character classes, and combine patterns with logical operators. 9.2.5 Exercises Matching Literal Strings: Create a character vector called fruits containing the following elements: \"apple\", \"banana\", \"strawberry\", \"blueberry\", \"blackberry\". Use str_view() to highlight the fruits containing the substring \"an\". Using Wildcards Using the fruits vector from Exercise 1, use a wildcard to find and highlight fruits that have any character followed by \"e\". Including Anchors Using the fruits vector, find and highlight fruits that ends with the string \"berry\". Character Classes Create a new character vector called codes with the elements: \"A123\", \"B456\", \"Bb56\", \"C789\", \"D012\", \"e345\". Use a regular expression to highlight the elements that contains an uppercase letter followed by a number. Matching Repeated Characters Create a vector named phone_numbers with these elements: \"555-123-4567\", \"(555) 123 4567\", \"5551234567\", \"1-555-123-4567\", \"555.123.4567\". Find and highlight all phone numbers that contain exactly three digits followed by a hyphen, another three digits, a hyphen, and finally four digits (e.g., 555-123-4567). Use str_view() to find all phone numbers that have parentheses around the first three digits (e.g., (555) 123 4567). Email address checker Now, you are asked to check whether a string is a valid email address according to the following rules Format: username@domain.com Username: The part before the \"@\" symbol. It is a string of length at least one that contains any combinations of letters (upper or lower cases), numbers, periods, and underscores. Domain: It is a string of length at least one that contains any combination of letters and numbers. .com: The domain should end with .com. Use the str_detect() function with your pattern on the following strings: emails &lt;- c( &quot;user.name@domain.com&quot;, &quot;user123@domain.com&quot;, &quot;user_name@domain.com&quot;, &quot;username@domaincom&quot;, &quot;username@domain.net&quot;, &quot;user@name@domain.com&quot;, &quot;@icloud.com&quot;, &quot;user@.com&quot;, &quot;user@do_main.com&quot; ) str_detect(emails, &quot;^[a-zA-Z0-9._]+@[a-zA-Z0-9]+\\\\.com$&quot;) #&gt; [1] TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE Extracting Dates Create a character vector called dates with the following elements: \"2021-01-01\", \"12-31-2021\", \"2022-28-02\", \"2022-02-29\", \"2022-03-01\". Use a regular expression to highlight the dates that are in the format YYYY-MM-DD. "],["statistics.html", "Chapter 10 Statistics", " Chapter 10 Statistics In this chapter, you will dive into the world of statistics. As a language initially designed for statistical computing, R undoubtedly provides a wide range of functions related to all aspects of probability and statistics. You will start with functions related to normal distribution in Section 10.1. "],["normal-distribution.html", "10.1 Normal Distribution", " 10.1 Normal Distribution First, let’s review the definition of normal distribution, which is also called Gaussian distribution. If \\(X\\sim N(\\mu, \\sigma^2)\\), we say \\(X\\) is a random variable following a normal distribution with mean \\(\\mu\\) and variance \\(\\sigma^2\\). In the following table, we list the four useful functions for normal distribution, and they will be introduced in the subsequent four parts, respectively. Code Name Section dnorm(x, mean, sd) probability density function 10.1.1 pnorm(q, mean, sd) cumulative distribution function 10.1.2 qnorm(p, mean, sd) quantile function 10.1.3 rnorm(n, mean, sd) random number generator 10.1.4 10.1.1 Probability Density Function (pdf) To characterize the distribution of a continuous random variable, you can use the probability density function (pdf) . When \\(X\\sim N(\\mu,\\sigma^2)\\), its pdf is \\[f(x) = \\frac{1}{\\sqrt{2\\pi \\sigma}}\\exp\\left[-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right].\\] In R, you can use dnorm(x, mean, sd) to calculate the pdf of normal distribution. The argument x represent the location(s) at which to compute the pdf. The arguments mean and sd represent the mean and standard deviation of the normal distribution, respectively. For example, dnorm(0, mean = 1, sd = 2) computes the pdf at location 0 of \\(N(1, 4)\\), normal distribution with mean 1 and variance 4. Note that the argument sd is the standard deviation, which is the square root of the variance. In particular, dnorm() without specifying the mean and sd arguments will compute the pdf of \\(N(0,1)\\), which is the standard normal distribution. Let’s see examples of computing the pdf at one location for three different normal distributions. dnorm(0, mean = 1, sd = 2) #&gt; [1] 0.1760327 dnorm(1, mean = -1, sd = 0.5) #&gt; [1] 0.0002676605 dnorm(0) #standard normal #&gt; [1] 0.3989423 In addition to computing the pdf at one location for a single normal distribution, dnorm also accepts vectors with more than one elements in all three arguments. For example, you can use the following code to compute the three pdf values in the previous code block. dnorm(c(0,1,0), mean = c(1, -1, 0), sd= c(2, 0.5, 1)) #&gt; [1] 0.1760326634 0.0002676605 0.3989422804 If you want to compute the pdf at the same location 0 for distributions \\(N(1,4)\\), \\(N(-1, 0.25)\\), and \\(N(0, 1)\\), you can use the following code. dnorm(0, mean = c(1, -1, 0), sd= c(2, 0.5, 1)) #&gt; [1] 0.1760327 0.1079819 0.3989423 If you want to compute the pdf at three different locations (-3, 2, and 5) for distribution \\(N(3, 4)\\), you can use the following code. dnorm(c(-3, 2, 5), mean = 3, sd = 2) #&gt; [1] 0.002215924 0.176032663 0.120985362 To get a better understanding on the shape of the normal pdf, let’s visualize the pdf of \\(N(0,1)\\). You first need to create a equal-spaced vector x from -5 to 5 with increment 0.1. Then, you can compute the pdf value for each element of x using dnorm(). Finally, you can visualize the pdf using geom_line(). library(ggplot2) x &lt;- seq(from = -5, to = 5, by = 0.05) norm_dat &lt;- data.frame(x = x, pdf = dnorm(x)) ggplot(norm_dat) + geom_line(aes(x = x, y = pdf)) Next, you can take a step further to visualize three different normal distributions in the same plot, \\(N(0,1)\\), \\(N(1,4)\\), and \\(N(-1, 0.25)\\). You can use the same vector x and compute the three pdfs on each element of x. geom_line() is still used with the variable dist mapped to the color aesthetic. x &lt;- seq(from = -5, to = 5, by = 0.05) norm_dat_1 &lt;- data.frame(dist = &quot;N(0,1)&quot;, x = x, pdf = dnorm(x)) norm_dat_2 &lt;- data.frame(dist = &quot;N(1,4)&quot;, x = x, pdf = dnorm(x, mean = 1, sd = 2)) norm_dat_3 &lt;- data.frame(dist = &quot;N(-1, 0.25)&quot;, x = x, pdf = dnorm(x, mean = -1, sd = 0.5)) norm_dat &lt;- rbind(norm_dat_1, norm_dat_2, norm_dat_3) ggplot(norm_dat) + geom_line(aes(x = x, y = pdf, color = dist)) 10.1.2 Cumulative Distribution Function (cdf) In addition to pdf, you can compute the cumulative distribution function (cdf) of the normal distribution using the function pnorm(q, mean, sd). Generally speaking, the cdf of a random variable \\(X\\) is defined as \\[F(x) = P(X\\leq x).\\] Similar to dnorm(), pnorm() also has two optional arguments, mean and sd, which represent the mean and standard deviation of the normal distribution, respectively. If you don’t specify these two arguments, pnorm() will compute the cdf of \\(N(0,1)\\). pnorm(0, mean = 1, sd = 2) #&gt; [1] 0.3085375 pnorm(0) # cdf at 0 of standard normal #&gt; [1] 0.5 You can also use pnorm() to visualize the cdf of the standard normal distribution. q &lt;- seq(from = -5, to = 5, by = 0.1) norm_dat &lt;- data.frame(q = q, cdf = pnorm(q)) ggplot(norm_dat) + geom_line(aes(x = q, y = cdf)) 10.1.3 Quantile Function The third useful function related to distributions is the quantile function. You can compute the quantile of the normal distribution using qnorm(p, mean, sd). The quantile function is the inverse function of the cdf. In particular, the \\(p\\) quantile returns the value \\(x\\) such that \\[F(x) = P(X\\leq x) = p\\] Let’s verify qnorm() is indeed the inverse function of pnorm() using the following example. pnorm(qnorm(c(0.5,0.7))) #&gt; [1] 0.5 0.7 When \\(p=0.5\\), qnorm() gives us the median of the normal distribution. Let’s see a few examples for computing the quantiles. qnorm(0.5, mean = 1, sd = 2) #&gt; [1] 1 qnorm(0.5) #&gt; [1] 0 You can also visualize the shape of the quantile function. p &lt;- seq(from = 0.01, to = 0.99, by = 0.01) norm_dat &lt;- data.frame(p = p, quantile = qnorm(p)) ggplot(norm_dat) + geom_line(aes(x = p, y = quantile)) 10.1.4 Random Number Generator Lastly, to generate (pick up) random numbers from normal distributions, you can use the function rnorm(n, mean, sd) , with the argument n represents the number of random numbers to generate, the arguments mean and sd are the mean and standard deviation of the normal distribution you would like to generate from, respectively. Again, if you only supply the argument n, you will be generating random numbers from \\(N(0,1)\\). rnorm(3, mean = 0, sd = 1) #generate 3 random numbers from N(0, 1) #&gt; [1] 0.2492699 0.1987472 -0.9778133 rnorm(3) #generate another 3 random numbers from N(0,1) #&gt; [1] 1.1789737 -1.1790168 0.1668201 Since you are generating random numbers, the results may be different each time. In many applications, however, you may want to make the results reproducible. To do this, you can set random seed using the function set.seed() before generating the random numbers. Let’s see the following example. set.seed(0) rnorm(3) #&gt; [1] 1.2629543 -0.3262334 1.3297993 Now, let’s run it one more time. set.seed(0) rnorm(3) #&gt; [1] 1.2629543 -0.3262334 1.3297993 You can see that the exact 3 numbers are reproduced since you are using the same random seed 0. You can run these two lines of code on any machine and will get the exact same three random numbers. Note that the code that involves randomness needs to be identical to reproduce the results. If you change the arguments in rnorm(), you will get totally different results. See the following example. set.seed(0) rnorm(1) #&gt; [1] 1.262954 rnorm(3) #&gt; [1] -0.3262334 1.3297993 1.2724293 By setting a different random seed, you will see different results as the following example. set.seed(1) rnorm(3) #&gt; [1] -0.6264538 0.1836433 -0.8356286 Lastly, let’s do a simple statistical exercise by checking the closeness of the sample mean and sample standard deviation to their population counterparts. x &lt;- rnorm(1e6, mean = 1, sd = 2) mean(x) #sample mean #&gt; [1] 1.000093 var(x) #sample covariance #&gt; [1] 4.001485 sd(x) #sample standard deviation #&gt; [1] 2.000371 10.1.5 Exercise "],["other-distributions.html", "10.2 Other Distributions", " 10.2 Other Distributions In Section 10.1, we gave a detailed introduction to the four functions for a normal distribution, which is a popular continuous distribution. In particular, we now know that dnorm() produces the pdf of a normal distribution. In the case of discrete distributions, however, we would have probability mass function (pmf) instead of the pdf. Let’s use the binomial distribution as a representative example of discrete distributions with the four functions as below. Code Name dbinom(3, size, prob) probability mass function pbinom(3, size, prob) cumulative distribution function qbinom(3, size, prob) quantile function rbinom(3, size, prob) random number generator Now, let’s look at a few other commonly used distributions. For simplicity, let’s just use the random number generator for each distribution in the following table. Name Code para_1 para_2 exponential rexp(3, rate = 0.5) rate uniform runif(3, min = 1, max = 2) min max t rt(3, df = 4) df F rf(3, df1 = 3, df2 = 6) df1 df2 beta rbeta(3, shape1 = 2, shape2 = 3) shape1 shape2 gamma rgamma(3, shape = 2, rate = 3) shape rate poisson rpois(3, lambda = 5) lambda binomial rbinom(3, size = 3, prob = 0.3) size prob bernoulli rbinom(3, size = 1, prob = 0.5) size prob As we can see from this table, all random number generator functions are formed by the letter r followed by the name of the distribution we would like to generate from. For the other three functions, we just need to change the initial letter r: to d for pdf (continuous distribution) or pmf (discrete distribution), to p for cdf, to q for quantile function. Let’s do some statistical exercises with those distributions. 10.2.1 Exercise "],["sampling.html", "10.3 Random Permutation and Random Sampling", " 10.3 Random Permutation and Random Sampling Now, you have covered how to work with distributions in R with the four useful functions for each distribution. In many applications, you may want to randomly permute or sample elements from a vector. Let’s see how to do that. The vector x &lt;- 6:10 will be used throughout this section. 10.3.1 Random Permutation In statistics and machine learning, you usually need to do a random permutation of the data. For example, you can evaluate a model’s performance by dividing the data randomly into two parts for training and validation, respectively. For the vector x &lt;- 6:10, you can use the function sample() to get a permutation for x. x &lt;- 6:10 set.seed(0) sample(x) #a random permutation of x #&gt; [1] 6 9 8 10 7 To reproduce the random permutation, we can use the same seed. set.seed(0) sample(x) #reproduce the random permutation #&gt; [1] 6 9 8 10 7 10.3.2 Random Sampling without Replacement Note that the vector x has 5 elements in total. To sample a few elements from x, you can again use the sample() function. For example, if you want to randomly sample two elements from x, you can use the following code sample(x, size = 2) #&gt; [1] 10 8 Here, the size argument specify the targeted number of elements. By default, the sample function take a sample without replacement, i.e. the results sample has no duplicated elements. Because of this, if the size is larger than the length of the vector x, you will see an error message as follows. sample(x, size = 6) #&gt; Error in sample.int(length(x), size, replace, prob): cannot take a sample larger than the population when &#39;replace = FALSE&#39; In addition to using a vector in the first argument of sample, you can also use a positive integer (e.g., 10), which will be equivalent to x = 1:10. See the following code for an example. sample(10, size = 4) #sample 4 integers from 1 to 10. #&gt; [1] 2 3 1 5 sample(1:10, size = 4) #sample 4 integers from 1 to 10. #&gt; [1] 5 6 9 2 10.3.3 Random Sampling with Replacement Sometimes, you may want to get a sample with replacements. You will still be using the sample function, but setting the argument replace = TRUE. The following code samples 10 elements with replacement from x. sample(x, size = 10, replace = TRUE) #&gt; [1] 6 10 10 6 6 10 10 7 7 6 As expected, you will see some duplicated elements in the output vector. A very important application of random sample with replacement is bootstrap. A bootstrap sample is a sample of the same size as the original data with replacement. So, if you want to get a bootstrap sample from x, you will sample 5 elements with replacement from x. sample(x, replace = TRUE) #a bootstrap sample #&gt; [1] 9 6 9 8 7 Note that, when the argument size is not provided, it will take the default value: the length of x. 10.3.4 Random Sampling with Unequal Probabilities By default, the sample() function will draw each element with the same probability. In some cases, you may want to assign different probabilities for different elements. To draw elements with different probabilities, the first method is to use the random number generator for Binomial distribution or Bernoulli distribution. Let’s say we want to randomly sample 100 elements from a Bernoulli distribution with success probability \\(p=0.2\\). rbinom(100, size = 1, prob = 0.2) #&gt; [1] 1 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 1 0 1 0 0 0 1 1 #&gt; [38] 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 1 0 0 0 #&gt; [75] 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 0 1 0 In addition to using the rbinom function introduced in Section 10.2, you can use the sample function with the prob argument inside to achieve the same goal. sample(c(0, 1), size = 100, replace = TRUE, prob = c(0.8, 0.2)) #&gt; [1] 0 0 0 0 0 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 0 0 0 0 0 0 1 1 0 0 1 0 #&gt; [38] 0 0 1 0 0 1 0 1 0 0 0 1 0 0 0 0 1 0 0 0 1 0 0 0 0 0 0 0 0 0 0 0 0 1 0 0 1 #&gt; [75] 1 0 0 1 1 0 0 0 0 0 1 0 0 0 0 1 0 0 0 0 0 0 0 0 0 0 You will samples 100 elements with replacement from c(0,1) here, and the probability of drawing 0 is 0.8, the probability of drawing 1 is 0.2. 10.3.5 Exercise "],["multivariate-normal.html", "10.4 Multivariate Normal Distribution", " 10.4 Multivariate Normal Distribution In this section, we introduce how to work with multivariate normal distribution in R. First, let’s review the definition of a multivariate normal distribution. Suppose a \\(p\\)-dimensional random vector \\({\\bf x} \\sim N({\\bf \\mu}, {\\bf \\Sigma})\\), where \\({\\bf \\mu}\\) is the mean vector and \\({\\bf \\Sigma}\\) is the covariance matrix. We have \\[ f({\\bf x}) = \\frac{1}{(2\\pi)^{p/2}\\sqrt{|{\\bf \\Sigma}|}}\\exp\\left[-\\frac{1}{2}({\\bf x}-{\\bf\\mu})^T{\\bf \\Sigma}^{-1}({\\bf x}-{\\bf\\mu})\\right]. \\] 10.4.1 Generate Multivate Normal Distribution To randomly generate \\({\\bf x} \\sim N({\\bf \\mu}, {\\bf \\Sigma})\\), you can use the mvrnorm(n = 1, mu, Sigma) function in the MASS package, which is preloaded in the base R. The function mvnorm() takes three arguments. n: targeted sample size mu: mean vector Sigma: covariance matrix Let’s take a look at an example where the distribution is \\(\\bf\\mu = (1, 2)^T\\) and \\[{\\bf \\Sigma} = \\left[\\begin{matrix} 1&amp;0.5\\\\ 0.5&amp;1 \\end{matrix}\\right]\\] library(MASS) #&gt; #&gt; Attaching package: &#39;MASS&#39; #&gt; The following object is masked from &#39;package:plotly&#39;: #&gt; #&gt; select #&gt; The following object is masked from &#39;package:dplyr&#39;: #&gt; #&gt; select n &lt;- 10 mu &lt;- c(1, 2) Sigma &lt;- matrix(c(1, 0.5, 0.5, 1), 2, 2) x &lt;- mvrnorm(n, mu, Sigma) x #&gt; [,1] [,2] #&gt; [1,] 0.5317478 1.591908 #&gt; [2,] 2.4575530 2.868658 #&gt; [3,] 0.5484207 2.079917 #&gt; [4,] 1.6036965 1.085302 #&gt; [5,] 0.7599533 2.066511 #&gt; [6,] 2.3854120 1.848962 #&gt; [7,] 1.0867794 1.785803 #&gt; [8,] 1.2315478 1.703268 #&gt; [9,] 0.7357121 1.083617 #&gt; [10,] 0.7476221 1.690725 x contains \\(n=10\\) two-dimensional normal distributed variable, where each row represents one observation. 10.4.2 Sample Mean and Sample Covariance Matrix In practical applications, we usually have a set of observations and would like to get a sample estimate of the parameters \\({\\bf \\mu}\\) and \\({\\bf \\Sigma}\\). For the \\({\\bf \\mu}\\), you can directly use the sample mean as the estimate which is unbiased. \\[\\hat {\\bf\\mu} = [\\hat\\mu_j],\\] where \\[\\hat\\mu_j = \\frac{1}{n}\\sum_{i=1}^nx_{ij}.\\] mu_hat &lt;- apply(x, 2, mean) mu_hat #&gt; [1] 1.208844 1.780467 To estimate \\({\\bf\\Sigma}\\), we will use the sample covariance matrix estimate: \\[\\hat{\\bf \\Sigma} = [\\hat\\Sigma_{jk}],\\] where \\[\\hat\\Sigma_{jk} = \\frac{1}{n-1}\\sum_{i=1}^n(x_{ij}-\\hat\\mu_j)(x_{ik}-\\hat\\mu_k).\\] To compute this matrix, we can use the function cov() on the matrix x. sigma_hat &lt;- cov(x) sigma_hat #&gt; [,1] [,2] #&gt; [1,] 0.5164012 0.1483479 #&gt; [2,] 0.1483479 0.2643104 1/(n-1)*sum((x[,1]-mu_hat[1])*(x[,2]-mu_hat[2])) #compute \\hat\\Sigma_{12} by formula #&gt; [1] 0.1483479 For cov() function, in addition to computing the sample covariance matrix, you can also use it to compute the covariance among two vectors \\(y\\) and \\(z\\). \\[cov(y, z) = \\frac{1}{n-1}\\sum_{i=1}^n(y_{i}-\\bar y)(z_i-\\bar z).\\] Let’s try to compute the covariance between the first and second column of \\(x\\). cov(x[,1], x[,2]) #&gt; [1] 0.1483479 cov(x)[1, 2] #&gt; [1] 0.1483479 You can see that this is exactly the same as \\(\\hat\\Sigma_{12}\\). 10.4.3 Sample Correlation Matrix Another useful measure is the sample correlation matrix. It is defined as \\[\\widehat{corr}(x) = [\\widehat{corr}(x)_{jk}],\\] where \\[\\widehat{corr}(x)_{jk} = \\frac{\\hat\\Sigma_{jk}} {\\sqrt{\\hat\\Sigma_{jj}\\hat\\Sigma_{kk}}}. \\] You can use cor() on the matrix x to get its sample correlation matrix. cor(x) #&gt; [,1] [,2] #&gt; [1,] 1.0000000 0.4015417 #&gt; [2,] 0.4015417 1.0000000 sigma_hat[1,2] / sqrt(sigma_hat[1, 1] * sigma_hat[2, 2]) #verify the [1,2] element #&gt; [1] 0.4015417 Similar to the cov() function, you can also us the cor() function to compute the sample correlation between two vectors. cor(x[,1], x[,2]) #&gt; [1] 0.4015417 cor(x)[1, 2] #&gt; [1] 0.4015417 You can see that the sample correlation matrix include all the pairwise sample correlations between any of the two columns. 10.4.4 Exercise "],["control-statements.html", "Chapter 11 Control Statements", " Chapter 11 Control Statements In the past few chapters, we have been relying on a few R packages including ggplot2 for visualization, dplyr for manipulation, readr for export and import data, tidyr for tidying data, and stringr for handling strings. While these packages are super powerful and make writing codes much easier, they still can’t do everything we want. In this chapter, we will introduce a set of control statements, which are essential in programming complex tasks. "],["ifelse.html", "11.1 Conditional Statements via if, else, and switch()", " 11.1 Conditional Statements via if, else, and switch() The first type of control statement is conditional statements, which execute a portion of codes depending on the value of a condition. 11.1.1 Conditional Statements The general structure of a simple conditional statement is as below. if(condition) { true_code_1 true_code_2 } else { false_code_1 false_code_2 false_code_3 } Here, the condition is usually a logical statement, the true_code_1 and true_code_2 represent the codes to run when condition == TRUE, and the false_code_1, false_code_2, false_code_3 represent the codes to run when condition == FALSE. Note that the else keyword is optional. Let’s first see an example where we check whether x is an even number of an odd number, and print out the corresponding messages. x &lt;- 3 if(x %% 2 == 0) { cat(&quot;x is an even number&quot;) } else { cat(&quot;x is an odd number&quot;) } #&gt; x is an odd number We can also use the ifelse() function to choose a value depending on whether the condition is TRUE or FALSE. x_type &lt;- ifelse(x%%2, &quot;even&quot;, &quot;odd&quot;) x_type #&gt; [1] &quot;even&quot; In addition to a single if and else pair, we can have more than two options. Let’s see the following example. x &lt;- 9 if(x %% 3 == 1) { cat(&quot;the remainder of x divided by 3 is 1.&quot;) } else if(x %% 3 == 2) { cat(&quot;the remainder of x divided by 3 is 2.&quot;) } else { cat(&quot;x is divisible by 3.&quot;) } #&gt; x is divisible by 3. Next, let’s introduce the switch() function which can switch to a particular value depending on the value of the expression, which is the first argument. If the first argument is an integer, the function will return the value corresponding to the location of the options. switch(2, &quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;) #&gt; [1] &quot;pig&quot; switch(4, &quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;) The first statement returns the second option with value \"pig\", and the second statement returns nothing as there is no 4th option. If the first argument is a character, it will be matched to the names of the elements in the options, and return the corresponding value. switch(&quot;pig&quot;, sheep = 2, pig = 3, monkey = 4) #&gt; [1] 3 switch(&quot;pi&quot;, sheep = 2, pig = 3, monkey = 4) switch(&quot;monkey&quot;, sheep = 2, pig = 3, monkey = &quot;mona&quot;) #&gt; [1] &quot;mona&quot; 11.1.2 Logical Operators in if Statement Recall we have learned logical operators on logical vectors in Section @ref(logical_operators). The most commonly used logical operators are the AND operation with &amp; and OR operation with |. Both operators conducts element-wise operations. In the if statement, we usually use another set of AND and OR operations, namely &amp;&amp; and ||. Let’s use some examples to understand how they work. logi_1 &lt;- c(T, F, T, F) logi_2 &lt;- c(F, T, T, F) logi_1 &amp; logi_2 #&gt; [1] FALSE FALSE TRUE FALSE logi_1 &amp;&amp; logi_2 #&gt; [1] FALSE logi_1 | logi_2 #&gt; [1] TRUE TRUE TRUE FALSE logi_1 || logi_2 #&gt; [1] TRUE Compare to the &amp; and |, the &amp;&amp; and || examine only the first element of the input logical vectors and the results are also a single logical value. Another important difference is that &amp;&amp; and || are short-circuit, skipping the evaluation of arguments if the result is determined. Let’s see an example. Let’s use an undefined object named undefined_object. undefined_object #&gt; Error in eval(expr, envir, enclos): object &#39;undefined_object&#39; not found TRUE || undefined_object #&gt; [1] TRUE TRUE | undefined_object #&gt; Error in eval(expr, envir, enclos): object &#39;undefined_object&#39; not found Here, we can see that even though undefined_object is not found, TRUE || undefined_object still returns TRUE, due to that the result of || operator between TRUE and any other value is always TRUE, hence determined. In particular, both TRUE | FALSE and TRUE | TRUE have the value TRUE. Note that the | operator will throw an error as it will always faithfully perform the logical operations. Let’s see another example of the AND operator between FALSE and another argument. FALSE &amp;&amp; undefined_object #&gt; [1] FALSE FALSE &amp; undefined_object #&gt; Error in eval(expr, envir, enclos): object &#39;undefined_object&#39; not found Similarly, the &amp;&amp; operator between FALSE and an undefined object is FALSE since the evaluation stops once the result is determined since we know both FALSE &amp; FALSE and FALSE &amp; TRUE have the value FALSE. The &amp; operator will again throw an error since undefined_object is not found. "],["loop.html", "11.2 Loops", " 11.2 Loops In addition to the conditional statements in Section 11.1, another important type of statements that controls the flow of programs is loops. 11.2.1 for loops with known sequence The first type of loops is to repeat a segment of codes with a known sequence. Let’s look at its syntax first. for (val in val_seq){ statement1 statement2 } The for loop will sequentially assign each value of the val_seq to val and run the body of the loop. For example, if you want to find the first ten values of the Fibonacci sequence. It is known that the first two values in a Fibonacci sequence is \\(F_1 = 0\\) and \\(F_2 = 1\\). Then, we have \\(F_3 = F_1 + F_2 = 0 + 1 = 1\\) and in general \\(F_i = F_{i-2} + F_{i-1}\\). fib_seq &lt;- rep(0,10) #initialize the sequence fib_seq[1] &lt;- 0 #initialize the first element fib_seq[2] &lt;- 1 #initialize the second element for(i in 3:10){ #loop i from 3 to 10 fib_seq[i] &lt;- fib_seq[i-2] + fib_seq[i-1] #compute the i-th element of fib_seq as the sum of the previous two elements } fib_seq #print the sequence #&gt; [1] 0 1 1 2 3 5 8 13 21 34 Here, we first initialize the desired sequence to be a zero vector of length 10. Then, initialize the first element to be 0 and second element of 1. After that, the for loop is will initially set i to the value of 3, and go over all the values in the sequence 3:10. At the end, we get the length-10 Fibonacci sequence. 11.2.2 Combine the conditional statements with loops In the body of the loop, you usually want to do different tasks depending on the conditions. In this case, you can add conditional statements in the body of the loop. Let’s print out all the numbers in fib_seq and add the information whether it is even or odd, and count the number of even values and odd values. count_even &lt;- count_odd &lt;- 0 #initialize the counts of even and odd values to be 0 for(fib_val in fib_seq){ #go over all the values in fib_seq if(fib_val %% 2 == 0){ #check if the current value is even cat(fib_val, &quot;: even\\n&quot;) #if so, print the value count_even &lt;- count_even + 1 #then, add 1 to the even count } else{ cat(fib_val, &quot;: odd\\n&quot;) #if not, print the value count_odd &lt;- count_odd + 1 #then, add 1 to the odd count } } #&gt; 0 : even #&gt; 1 : odd #&gt; 1 : odd #&gt; 2 : even #&gt; 3 : odd #&gt; 5 : odd #&gt; 8 : even #&gt; 13 : odd #&gt; 21 : odd #&gt; 34 : even cat(&quot;There are &quot;, count_even, &quot; even values.\\n&quot;) #print the count of even values #&gt; There are 4 even values. cat(&quot;There are &quot;, count_odd, &quot; odd values.\\n&quot;) #print the count of odd values #&gt; There are 6 odd values. It is worth noting that for this task, we can actually avoid the loop using vectorize operations on the vector. even_ind &lt;- fib_seq %% 2 == 0 #check whether each value is even even_odd &lt;- ifelse(even_ind, &quot;even&quot;, &quot;odd&quot;) #convert the logical vector to a character vector cat(paste0(fib_seq, &quot;: &quot;, even_odd, &quot;\\n&quot;)) #create the string and print #&gt; 0: even #&gt; 1: odd #&gt; 1: odd #&gt; 2: even #&gt; 3: odd #&gt; 5: odd #&gt; 8: even #&gt; 13: odd #&gt; 21: odd #&gt; 34: even cat(&quot;There are &quot;, sum(even_ind), &quot; even values.\\n&quot;) #print the count of even values #&gt; There are 4 even values. cat(&quot;There are &quot;, sum(!even_ind), &quot; odd values.\\n&quot;) #print the count of odd values #&gt; There are 6 odd values. 11.2.3 Control Loop Flow With next and break Inside the if and else clause, you can use next and break to further control the flow. The next function goes directly to the next loop cycle, while break jumped out of the current loop. Let’s see an example of next. For each value of the fib_seq, if it is even, we will skip to the next value. for(fib_val in fib_seq){ #go over all the values in fib_seq if(fib_val %% 2 == 0){ #check if the current value is even next } cat(fib_val, &quot;: odd\\n&quot;) #if not, print the value } #&gt; 1 : odd #&gt; 1 : odd #&gt; 3 : odd #&gt; 5 : odd #&gt; 13 : odd #&gt; 21 : odd Now, suppose you want to find the first value in fib_seq that is larger than 4. The break can be used in this case. for(fib_val in fib_seq){ #go over all the values in fib_seq if(fib_val &gt; 4){ #check if the current value is larger than 4 cat(fib_val, &quot; is the first value larger than 4\\n&quot;) break } } #&gt; 5 is the first value larger than 4 cat(fib_val) #check the current fib_val #&gt; 5 You can see that the fib_val is 5, indicating that we have breaked from the loop since it is larger than 4. 11.2.4 Nested Loops In addition to a single loop, it is also common to put one loop inside another one, named the nested loop. Let’s say we want to create a matrix A of dimension \\(5\\times 5\\) where each element \\(A_{ij} = i+j\\). To create such a matrix, we can write a nested loop over \\(i\\) and \\(j\\). A &lt;- matrix(0, 5, 5) #initialize the matrix A for (i in 1:5) #loop over index i for (j in 1:5){ #loop over index j A[i, j] &lt;- i + j #set the (i, j)-th element of A } A #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 2 3 4 5 6 #&gt; [2,] 3 4 5 6 7 #&gt; [3,] 4 5 6 7 8 #&gt; [4,] 5 6 7 8 9 #&gt; [5,] 6 7 8 9 10 Let’s try another example where we want to create the correlation matrix in the so-called AR(1) model. In particular, the corresponding matrix \\(A\\) is of dimension \\(p\\times p\\) where \\(A_{ij} = \\rho^{|i-j|}\\). Let’s say an example of \\(p = 4\\) and \\(\\rho = 0.5\\) p &lt;- 4 A &lt;- matrix(0, p, p) #initialize the matrix A rho &lt;- 0.5 for (i in 1:p) #loop over index i for (j in 1:p){ #loop over index j A[i, j] &lt;- rho^{abs(i - j)} #set the (i, j)-th element of A } A #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1.000 0.50 0.25 0.125 #&gt; [2,] 0.500 1.00 0.50 0.250 #&gt; [3,] 0.250 0.50 1.00 0.500 #&gt; [4,] 0.125 0.25 0.50 1.000 11.2.5 Nested Loop via the outer() Function It turns out for the two examples we showed in the last part, you can use avoid the loop by the outer() function. outer(1:5, 1:5, &quot;+&quot;) #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 2 3 4 5 6 #&gt; [2,] 3 4 5 6 7 #&gt; [3,] 4 5 6 7 8 #&gt; [4,] 5 6 7 8 9 #&gt; [5,] 6 7 8 9 10 outer(1:4, 1:4, function(i, j){0.5^{abs(i-j)}}) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1.000 0.50 0.25 0.125 #&gt; [2,] 0.500 1.00 0.50 0.250 #&gt; [3,] 0.250 0.50 1.00 0.500 #&gt; [4,] 0.125 0.25 0.50 1.000 Let’s see another example of using outer(). outer(1:5, 1:5, function(x,y){ paste(x,&quot;+&quot;,y,&quot;=&quot;,x+y)}) #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] &quot;1 + 1 = 2&quot; &quot;1 + 2 = 3&quot; &quot;1 + 3 = 4&quot; &quot;1 + 4 = 5&quot; &quot;1 + 5 = 6&quot; #&gt; [2,] &quot;2 + 1 = 3&quot; &quot;2 + 2 = 4&quot; &quot;2 + 3 = 5&quot; &quot;2 + 4 = 6&quot; &quot;2 + 5 = 7&quot; #&gt; [3,] &quot;3 + 1 = 4&quot; &quot;3 + 2 = 5&quot; &quot;3 + 3 = 6&quot; &quot;3 + 4 = 7&quot; &quot;3 + 5 = 8&quot; #&gt; [4,] &quot;4 + 1 = 5&quot; &quot;4 + 2 = 6&quot; &quot;4 + 3 = 7&quot; &quot;4 + 4 = 8&quot; &quot;4 + 5 = 9&quot; #&gt; [5,] &quot;5 + 1 = 6&quot; &quot;5 + 2 = 7&quot; &quot;5 + 3 = 8&quot; &quot;5 + 4 = 9&quot; &quot;5 + 5 = 10&quot; Finally, the outer() function can also be applied on matrices, which will lead to a higher dimensional array. A &lt;- matrix(1:4, 2, 2) outer(A, A, &quot;-&quot;) #a 4-dimensional array. #&gt; , , 1, 1 #&gt; #&gt; [,1] [,2] #&gt; [1,] 0 2 #&gt; [2,] 1 3 #&gt; #&gt; , , 2, 1 #&gt; #&gt; [,1] [,2] #&gt; [1,] -1 1 #&gt; [2,] 0 2 #&gt; #&gt; , , 1, 2 #&gt; #&gt; [,1] [,2] #&gt; [1,] -2 0 #&gt; [2,] -1 1 #&gt; #&gt; , , 2, 2 #&gt; #&gt; [,1] [,2] #&gt; [1,] -3 -1 #&gt; [2,] -2 0 "],["while-loop.html", "11.3 While Loops and Repeat", " 11.3 While Loops and Repeat In addition to for loop where you have to specify the range of values to iterate, it is sometimes more convenient to use another type of loop: the while loop. 11.3.1 while loop Let’s first review the syntax of for loops. for (val in val_seq){ statement1 statement2 } Here, we have to specify the val_seq along which we will assign each element to val and execute the statements, unless break is called. Sometimes, it is not clear what the val_seq would be. For example, if we want to find the Fibonacci sequence up to 100, it is not clear how many elements we will have in the val_seq. In this case, the while loop comes to rescue. Let’s take a look of the syntax of while loop. while(cond_expr){ statement1 statement2 } In the while loop, we put a logical statement in the cond_expr. The loop will continue as long as cond_expr take the value of TRUE. Let’s see the actual code in action. fib_seq &lt;- c(0, 1) fib_last_value &lt;- fib_seq[1] fib_cur_value &lt;- fib_seq[2] fib_next_value &lt;- fib_last_value + fib_cur_value while(fib_next_value &lt; 100){ fib_seq &lt;- c(fib_seq, fib_next_value) fib_cur_value &lt;- fib_next_value fib_last_value &lt;- fib_cur_value fib_next_value &lt;- fib_last_value + fib_cur_value } fib_seq #print the sequence #&gt; [1] 0 1 1 2 4 8 16 32 64 11.3.2 repeat Loop The last type of loops is the repeat loop, which doesn’t have neither the range of values, nor the logical expression. The syntax is as below. repeat{ expr1 expr2 if(cond_expr){ break } expr3 } As you can see in the syntax of the repeat loop, you always need to put a conditional break statement to avoid infinite loops. Let’s rewrite the previous example using repeat loop. fib_seq &lt;- c(0, 1) fib_last_value &lt;- fib_seq[1] fib_cur_value &lt;- fib_seq[2] fib_next_value &lt;- fib_last_value + fib_cur_value repeat{ fib_seq &lt;- c(fib_seq, fib_next_value) fib_cur_value &lt;- fib_next_value fib_last_value &lt;- fib_cur_value fib_next_value &lt;- fib_last_value + fib_cur_value if(fib_next_value &gt;= 100){ break } } fib_seq #print the sequence #&gt; [1] 0 1 1 2 4 8 16 32 64 You can see that the same sequence was generated using the repeat loop. "],["functions.html", "Chapter 12 Functions", " Chapter 12 Functions In theory, you can already write very complicated codes, accomplishing a lot of data analysis tasks. In this chapter, you will learn a very powerful tool, functions. Functions have the following advantages. Functions can avoid code duplication. Functions can make the code more readable. Functions are invaluable for collaboration in projects. "],["intro-functions.html", "12.1 Introduction to Functions", " 12.1 Introduction to Functions Let’s look at the example for generating Fibonacci sequence to motivate functions. To get a Fibonacci sequence up to the value 100, you can use the following code. fib_seq &lt;- c(0, 1) fib_last_value &lt;- fib_seq[1] fib_cur_value &lt;- fib_seq[2] fib_next_value &lt;- fib_last_value + fib_cur_value while(fib_next_value &lt; 100){ fib_seq &lt;- c(fib_seq, fib_next_value) fib_cur_value &lt;- fib_next_value fib_last_value &lt;- fib_cur_value fib_next_value &lt;- fib_last_value + fib_cur_value } fib_seq #print the sequence #&gt; [1] 0 1 1 2 4 8 16 32 64 Now, to get a Fibonacci sequence up to the value 200, you just need to change the 100 in the previous code to 200. fib_seq &lt;- c(0, 1) fib_last_value &lt;- fib_seq[1] fib_cur_value &lt;- fib_seq[2] fib_next_value &lt;- fib_last_value + fib_cur_value while(fib_next_value &lt; 200){ fib_seq &lt;- c(fib_seq, fib_next_value) fib_cur_value &lt;- fib_next_value fib_last_value &lt;- fib_cur_value fib_next_value &lt;- fib_last_value + fib_cur_value } fib_seq #print the sequence #&gt; [1] 0 1 1 2 4 8 16 32 64 128 If this is some task we want to do repeatedly , it would be better to wrap the whole process into a function. Let’s first review the general syntax of a function. fun_name &lt;- function(arg1, arg2){ expr_1 expr_2 return(return_val) } First, we need to observe what objects are needs inside the function, which will be the arguments (arg1, arg2) of the function. Here, the upper bound of the Fibonacci sequence (value 100 and 200) is the only argument. Second, we need to identify what to output from the function, i.e., return a value. In this example, the Fibonacci sequence would be a reasonable output for return_val. Third, we need to name the function, following the naming rule of an object introduced back in Section 1.3.3. Here, we will name it as get_fibo. Let’s look at our function. get_fibo &lt;- function(upper_bound){ fib_seq &lt;- c(0, 1) fib_last_value &lt;- fib_seq[1] fib_cur_value &lt;- fib_seq[2] fib_next_value &lt;- fib_last_value + fib_cur_value while(fib_next_value &lt; upper_bound){ fib_seq &lt;- c(fib_seq, fib_next_value) fib_cur_value &lt;- fib_next_value fib_last_value &lt;- fib_cur_value fib_next_value &lt;- fib_last_value + fib_cur_value } return(fib_seq) #print the sequence } Now, let’s try to evaluate this function with some examples. get_fibo(upper_bound = 50) #&gt; [1] 0 1 1 2 4 8 16 32 get_fibo(upper_bound = 80) #&gt; [1] 0 1 1 2 4 8 16 32 64 get_fibo(upper_bound = 300) #&gt; [1] 0 1 1 2 4 8 16 32 64 128 256 "],["arguments-return.html", "12.2 Arguments and Return", " 12.2 Arguments and Return Let’s continue talking about functions. We will discuss To get a Fibonacci sequence up to the value 100, you can use the following code. fib_seq &lt;- c(0, 1) fib_last_value &lt;- fib_seq[1] fib_cur_value &lt;- fib_seq[2] fib_next_value &lt;- fib_last_value + fib_cur_value while(fib_next_value &lt; 100){ fib_seq &lt;- c(fib_seq, fib_next_value) fib_cur_value &lt;- fib_next_value fib_last_value &lt;- fib_cur_value fib_next_value &lt;- fib_last_value + fib_cur_value } fib_seq #print the sequence #&gt; [1] 0 1 1 2 4 8 16 32 64 Now, to get a Fibonacci sequence up to the value 200, you just need to change the 100 in the previous code to 200. fib_seq &lt;- c(0, 1) fib_last_value &lt;- fib_seq[1] fib_cur_value &lt;- fib_seq[2] fib_next_value &lt;- fib_last_value + fib_cur_value while(fib_next_value &lt; 200){ fib_seq &lt;- c(fib_seq, fib_next_value) fib_cur_value &lt;- fib_next_value fib_last_value &lt;- fib_cur_value fib_next_value &lt;- fib_last_value + fib_cur_value } fib_seq #print the sequence #&gt; [1] 0 1 1 2 4 8 16 32 64 128 If this is some task we want to do repeatedly , it would be better to wrap the whole process into a function. Let’s first review the general syntax of a function. fun_name &lt;- function(arg1, arg2){ expr_1 expr_2 return(return_val) } First, we need to observe what objects are needs inside the function, which will be the arguments (arg1, arg2) of the function. Here, the upper bound of the Fibonacci sequence (value 100 and 200) is the only argument. Second, we need to identify what to output from the function, i.e., return a value. In this example, the Fibonacci sequence would be a reasonable output for return_val. Third, we need to name the function, following the naming rule of an object introduced back in Section 1.3.3. Here, we will name it as get_fibo. Let’s look at our function. get_fibo &lt;- function(upper_bound){ fib_seq &lt;- c(0, 1) fib_last_value &lt;- fib_seq[1] fib_cur_value &lt;- fib_seq[2] fib_next_value &lt;- fib_last_value + fib_cur_value while(fib_next_value &lt; upper_bound){ fib_seq &lt;- c(fib_seq, fib_next_value) fib_cur_value &lt;- fib_next_value fib_last_value &lt;- fib_cur_value fib_next_value &lt;- fib_last_value + fib_cur_value } return(fib_seq) #print the sequence } Now, let’s try to evaluate this function with some examples. get_fibo(upper_bound = 50) #&gt; [1] 0 1 1 2 4 8 16 32 get_fibo(upper_bound = 80) #&gt; [1] 0 1 1 2 4 8 16 32 64 get_fibo(upper_bound = 300) #&gt; [1] 0 1 1 2 4 8 16 32 64 128 256 "],["r-markdown.html", "Chapter 13 R Markdown", " Chapter 13 R Markdown In Section 1.1.2, we learned how to create a new R script. R script is useful for organizing R code and add brief comments. However, to write document with more complicated structure, you need to use something more sophisticated. In this chapter, we introduce a new file format, namely the R Markdown file (.rmd). Using R Markdown, you can turn the data analyses into high quality documents, reports, presentations, books, and many other possible forms. "],["intro-r-markdown.html", "13.1 Introduction to R Markdown", " 13.1 Introduction to R Markdown R Markdown is an interactive and dynamic file format in R. An R Markdown file can be transformed into a document of many different types, including HTML, PDF, and Word. 13.1.1 Create a new R Markdown document To create an R Markdown document, you can click the + button on the R Studio menu, then select R Markdown. Figure 13.1: create a new R Markdown document (I) Then you will see a window pops up like Figure 13.2. Figure 13.2: create a new R Markdown document (II) Here, you can enter the Title and Author of the document, and select one of the output formats: HTML, PDF and Word. In our opinion, HTML is the recommended format for authoring. If you want to generate a PDF, you need to have a Tex installation, which would have already been installed if you write LaTex documents on the computer. If necessary, you can install TinyTeX with the R package tinytex. install.packages(&quot;tinytex&quot;) tinytex::install_tinytex() A word of caution is needed here. We have seen a lot of people having issues with the installation of the Tex system. The exact cause is sometimes tricky to track. It could be the operating system, the physical location, existing software installed on the computer, or something else. If an error message shows up during the installation process, you are not alone. You could try to search the error message using a search engine. If generating PDF file is a must, as a last resort, you can first generate a word document and convert it into a pdf file afterward. After clicking OK, you have created an R Markdown document with file extension .Rmd. You can save the file with a desired name on the disk by clicking the save button or using keyboard shortcut of saving files. Here, we use the name Lesson 10.1. It is clear to see the difference of file extension between R Markdown document and R script. Figure 13.3: R Markdown vs. R Script 13.1.2 Knit the R Markdown document To generate the final output document, you need to knit the .Rmd file. To do that, you can click the Knit button shown in the following figure. Figure 13.4: Knit button Then you will get an HTML, PDF, or Word document, according to the chosen document type. Let’s take a look at the HTML document together, Figure 13.5: HTML document A document consists of components three different types. The first type is the header of document, the second type is text, and the third type is related to codes and the results. Since the output document is rendered from the .Rmd file, the .Rmd file also has three type of components accordingly. If you want to make any changes on the output document, you need to make the necessary changes on the .Rmd file and knit it again. Next, we introduce how to write an R Markdown document. 13.1.3 Write an R Markdown document Unlike R script, you may notice that RStudio provides an example of the .Rmd file after creating an R Markdown document. It is then straightforward for you to get started by replacing the example with your own contents. By now you know that there are three parts in the .Rmd file. Let’s go over them one by one. a. YAML header The first part is a YAML header (Yet Another Markup Language), which is a section of key: value pairs surrounded by --- marks, like below. --- title: &quot;Untitled&quot; author: &quot;r02pro&quot; date: &quot;8/31/2021&quot; output: html_document --- It is used to specify the document information, including the title, author, date, and output format. The output: recognizes the following values: html_document, which will create HTML output (default) pdf_document, which will create PDF output word_document, which will create Word output b. Text After the YAML header, you can see some text. Unlike R script, you don’t need to use the pound sign # to write text in an R Markdown document. Indeed, you can write as if you are writing in a text editor, though R Markdown provides a rich collection of text formats, which will be discussed in Section 13.2. c. Code Chunks The last component type is related to R codes. Different from R script, the R code is usually contained in the code chunks in the .Rmd file. So what is a code chunk? A code chunk is basically a collection of R codes surrounded by the chunk delimiters ```{r} and ```. Let’s take a look at one code chunk as follows. Figure 13.6: An R Code Chunk In this code chunk, there is only one line of code summary(cars) which will output the summary statistics of the cars data set. If necessary, you can include any lines of codes inside each code chunk. Each chunk can be viewed as a unit that usually serves a particular purpose. Inside each code chunk, you can run the codes line by line by the keyboard shortcut Cmd + Enter / Ctrl + Enter. However, it is often more convenient to run the codes all at once using the keyboard shortcut Shift + Cmd + Enter / Shift + Ctrl + Enter, or press the Green arrow on the right of the code chunk. Then you will see both R code and the result from the output document by default. Figure 13.7: R code and the result In addition to the R code, you may be wondering what do the arguments in the big parentheses { } work for. Here, we will introduce a few useful chunk options which control the behavior of each code chunk. “r cars” gives the code chunk the name “pressure”, which is useful to navigate between different chunks, and it is also necessary to give the code chunk a name if you want to cross reference the corresponding figure in the knitted document. eval = FALSE prevents codes from being evaluated. This is useful when you want to show the code but don’t want to run it. Default value is eval = TRUE. include = FALSE prevents code and results from appearing in the knitted file. The code will still be evaluated. Default value is include = TRUE. echo = FALSE prevents code, but not the results from appearing in the knitted file. This is useful if you want to embed figures in the document without showing the code used to generate them. Default value is echo = TRUE. message = FALSE prevents messages that are generated by code from appearing in the knitted file. Default value is message = TRUE. warning = FALSE prevents warnings that are generated by code from appearing in the knitted file. Default value is warning = TRUE. There are many other available options in an R Markdown code chunk. You can refer to the webpage https://yihui.org/knitr/options/ for details. Now let’s see some examples together. If you add the chunk option eval = FALSE. Figure 13.8: Add eval = FALSE Then you will see the code without the result from the output. Figure 13.9: Only see the code If you add the chunk option echo = FALSE, Figure 13.10: Add echo = FALSE you will see the result without the code from the output. Figure 13.11: Only see the result You can try to add other chunk options by yourself! Lastly, if you have many code chunks that share some chunk options, it is very useful to set the global chunk options at the beginning of an R Markdown document. To do that, you can add the following chunk right after the YAML header. Figure 13.12: global chunk options In this example, we set echo = TRUE and warning = FALSE. You can feel free to change their values and add other kinds of customization. In each subsequent chunk, this set of global chunk options will be inherited. Of course, you can add additional options in each chunk to add additional chunk options or overwrite the global chunk options. This may be reminiscent of the relationship between global and local aesthetic mappings introduced in Section 5.7. "],["rmd-text-formating.html", "13.2 Text Formatting in R Markdown", " 13.2 Text Formatting in R Markdown Having learned the YAML Header and R Code Chunks in Section 13.1, we will introduce how to format text in R Markdown document, which is crucial in writing a report. In particular, R Markdown follows the syntax of Pandoc’s Markdown, a set of markup annotations for plain text files. Pandoc (https://pandoc.org/) is a universal document converter that converts documents from one markup format into another. Here, text in the .Rmd file is called the marked up text, and text in the output document is called the formatted text. When you knit the .Rmd file, Pandoc transforms the marked up text into formatted text in the specified file format. In this section, we will introduce how to get several kinds of formatted text in the output document by compiling the .Rmd file. 13.2.1 Special text formats Firstly, let’s discuss how to generate a couple of special formatted text. a. different header levels You may use different numbers of “#” before the marked up text to generate different header levels in the output document. (with more “#”s indicating lower levels and smaller fonts). For example, you can try to the following lines in the .Rmd file and see what happens in the output document, # Header1 ## Header2 ### Header3 #### Header4 ##### Header5 ###### Header6 b. change the text into italic type To make the formatted text into italic type, you can simply use a pair of * around the text with no space. For example *italic* in the .Rmd file generates italic in the output document. c. change the text into bold type To make the formatted text into bold type, you can simply use a pair of ** around the marked up text with no space. For example **bold** in the .Rmd file generates bold in the output document. d. create inline code emphasize texts by marking them as inline codes, not recommend Sometimes you may want to mark text or code as inline code. To do that, you need to use a pair of ` around the text or code. We have seen many inline codes so far. For example, *italic* is an inline code. Another common usage is when you want to include code along with other text outside code chunks. For example `1 + 1` in the markup text generates 1 + 1 in the formatted text. Here, we only display the code without running it. If you want to show the output instead of code, you can use `r `. For example, `r 1 + 1` will generate 2 in the formatted text. Note that if you add a pair of ` around code inside the the code chunk, you will get an error message when you knit the file. Figure 13.13: Error message (I) Figure 13.14: Error message (II) e. insert hyperlinks To insert a hyperlink in the output document, you can use the format [link](address) in the .Rmd file. For example, [r02pro](https://r02pro.github.io/) in the .Rmd file will generate the text r02pro with hyperlink to this book in the output document. f. write latex equations When writing documents that contain math symbols or equations, you can use latex equations directly in an R Markdown file, just like writing a .tex file. For example, you can use $\\sum_{i=1}^{10} i = 55$ in the .Rmd file to get \\(\\sum_{i=1}^{10} i= 55\\) in the output document. You can also use a pair of $$ to write in display math mode. Say $$\\sum_{i=1}^{10} i = 55$$ in the .Rmd file will generate \\[\\sum_{i=1}^{10} i = 55\\] in the output document. Lastly, please see the an example which has all components introduced in this part. You can copy the following lines and paste them on an R Markdown document, then click the knit button to see what will you get in the ouput document. # H1 *This is an example.* ## H2 I **learned** to use `a &lt;- rnorm(1)` to generate normal distributed random variable in [r02pro](https://r02pro.github.io/). The result of `1 + 1` is 2. ### H3 I learned how to sum up numbers when I was young. For example, $$\\sum_{i=1}^{10} i = 55$$ 13.2.2 Lists in R Markdown Secondly, we will introduce how to generate lists in the output document. There are two kinds of lists, unordered lists and ordered lists. Generally, To create an unordered list, you can use the symbol *, +, or - at the beginning of the line with a space between the symbol and the text. To create higher order lists, you just need to add extra indent at the beginning of the line. Different layers have different indents and you need to align the items of the same order. Normally, there are at most three layers in a list. Please feel free to try the following example and edit it to your need. * Item 1 * Item 2 + Item 2a - Item 2a.a - Item 2a.b + Item 2b * Item 3 + Item 3a You will see the following output in the formatted text. Item 1 Item 2 Item 2a Item 2a.a Item 2a.b Item 2b Item 3 Item 3a To create an ordered list, you can use numbers followed by the contents with a space in between. Similar to unordered list, you can add extra layers as needed. Please see the following example with some Spanish numbers. 1. uno 2. dos 2.1. dos.uno 2.2. dos.dos 3. tres 3.1. tres.uno 3.2. tres.dos You will see the following output. uno dos 2.1. dos.uno 2.2. dos.dos tres 3.1. tres.uno 3.2. tres.dos Of course, you can also mix ordered and unordered lists. Feel free to try the following example in your .Rmd file. 1. Item 1 2. Item 2 + Item 2a - Item 2a.a - Item 2a.b + Item 2b 3. Item 3 + Item 3a 13.2.3 Tables in R Markdown In addition to lists, you can easily create tables using R Markdown via the kable() function in the knitr package. You need to install the knitr package if you haven’t done so. You can study the following example and adapt it to your needs. ```{r echo = FALSE, results = TRUE} Code &lt;- c(&quot;`dnorm(x, mean, sd)`&quot;,&quot;`pnorm(q, mean, sd)`&quot;,&quot;`qnorm(p, mean, sd)`&quot;,&quot;`rnorm(n, mean, sd)`&quot;) Name &lt;- c(&quot;probability density function&quot;, &quot;cumulative distribution function&quot;, &quot;quantile function&quot;, &quot;random number generator&quot;) d &lt;- data.frame(Code, Name) knitr::kable(d) ``` Code Name dnorm(x, mean, sd) probability density function pnorm(q, mean, sd) cumulative distribution function qnorm(p, mean, sd) quantile function rnorm(n, mean, sd) random number generator 13.2.4 Insert citations and manage bibliographies in R Markdown R Markdown provides us the capability to add bibliography and manage citations with ease, similar to writing a LaTex document. To add citations, you first need to add the bibliography filed in the YAML head. If your references are in the file “references.bib”, you can set the bibliography file as follows. --- output: html_document bibliography: references.bib --- The .bib file is a plain-text file that consists of bibliography entries like the following: @book{r02pro, title = {R Programming: From Zero to Pro}, author = {Yang Feng and r02proers}, organization = {New York University}, address = {New York, NY}, year = {2023}, url = {https://r02pro.github.io/}, } Then, each bibtex items can be cited directly within the documentation using the syntax @key, where key is the citation key in the first line of the entry, e.g., @r02pro will show as Feng and r02proers (2024) in the document. To put citations in parentheses, use [@key]. To cite more than one items, separate the keys by semicolons, e.g., [@key-a; @key-b; @key-c]. To suppress the author name, you can add a minus sign before @, e.g., [-@r02pro] will generate -Feng and r02proers (2024). To learn more about citations and bibliography in R Markdown, you can read the excellent book by Xie, Dervieux, and Riederer (2020). References "],["case-study.html", "Chapter 14 A Case Study: 24 Game Solver", " Chapter 14 A Case Study: 24 Game Solver In this final chapter, we will build a 24 Game Solver. The 24 Game is an arithmetical card game in which the objective is to find a way to manipulate four integers, so that the end result is 24. In a classic game, the four integers come from a deck of cards (with all the face cards removed). As a result, the 4 integers range from 1 to 10. The allowed operations are addition, subtraction, multiplication, division, and parentheses. All 4 integers have to be used and only be used once. For example, if we have four integers: 6, 1, 2, and 6. One solution is \\[ (1 + 2) \\times 6 + 6 = 24.\\] Another solution is \\[ 1 \\times 2 \\times (6 + 6) = 24.\\] Now, let’s look at a more difficult one: 1, 5, 5, and 5. The solution is \\[5\\times(5 - 1/5) = 24.\\] The goal of our solver is to write a function that take the four integers as the input, and if there exist solutions, outputs them. If there doesn’t exist a solution, print a message that says so. Let’s break down the target function into several sub-functions and work on them in the next few subsections. "],["permutation-operator.html", "14.1 Permutation and Operator Sequence", " 14.1 Permutation and Operator Sequence Given the four integers, it is clear that we need to perform three operations to arrive at the final result. Without any prior knowledge, one reasonable way to solve the problem is via a exhaustive search. Let’s use the example 1, 5, 5, 5 throughout the demonstrations. Let’s have another look at the solution we provided in the chapter introduction, \\[ 5\\times(5 - 1/5) = 24.\\] It is helpful to break down the equation into the following three steps. \\(1 / 5 = 0.2\\) \\(5 - 0.2 = 4.8\\) \\(5 \\times 4.8 = 24\\) Let’s summarize the features of the three steps. Each step is determined by two numbers and an operator. For example, the first step involves numbers 1 and 5, and the / operator. The two numbers in the first step comes from the input (the original four numbers). Out of the two numbers in steps 2 and 3, one is the result from the previous step, and the other one comes from the original four numbers. For example, in step 2, 0.2 is the result from step 1 and 5 comes from the input. 14.1.1 Getting All Permutations The three steps imply a specific order of the original four numbers. In this case, we have 1, 5, 5, 5. In our exhaustive search, we need to enumerate all possible permutations of the original four number, which at most is \\(4! = 24\\). We can find all the possible permutations using the permutations() function in the gtools package. We also apply the unique() function outside to remove the duplicated permutations. library(gtools) nums &lt;- c(1, 5, 5, 5) n_nums &lt;- length(nums) nums_perm &lt;- unique(permutations(n_nums, n_nums, nums, set = FALSE)) nums_perm #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 5 5 5 #&gt; [2,] 5 1 5 5 #&gt; [3,] 5 5 1 5 #&gt; [4,] 5 5 5 1 Now, nums_perm is a matrix, where each row contains a particular permutation of the original numbers. 14.1.2 Getting All Operators With the nums_perm in hand, we have a specific ordering of the original numbers that we will use in the calculation. Let’s take a look at the first row, (1, 5, 5, 5). The first step will then involve the numbers 1 and 5. How many possible operations are there between them? At first, maybe you think there are four \\(1 + 5\\), \\(1 - 5\\), \\(1 \\times 5\\), and \\(1 / 5\\). Actually, the - and / operators are not symmetric. And we will get a different result when we switch the order, unless the two numbers are the same. As a summary, for numbers x and y, we have the following six possible operations. Operator Example Value x + y 1 + 5 6.0 x - y 1 - 5 -4.0 y - x 5 - 1 4.0 x * y 1 * 5 5.0 x / y 1 / 5 0.2 y / x 5 / 1 5.0 Now, we need to make this process automatic. Let’s write the following function cal() which takes arguments x, y, and op (a value from 1 to 6). cal &lt;- function(x, y, op){ switch(op, x + y, x - y, x * y, x / y, y - x, y / x) } To output the intermediate steps, it is useful to write a print function. The following function print_op(x, y, z, op) will generate a string that represent the operation op between x and y generates z. print_op &lt;- function(x, y, z, op){ switch(op, paste(x, &quot;+&quot;, y, &quot;=&quot;, z) , paste(x, &quot;-&quot;, y, &quot;=&quot;, z) , paste(x, &quot;*&quot;, y, &quot;=&quot;, z) , paste(x, &quot;/&quot;, y, &quot;=&quot;, z) , paste(y, &quot;-&quot;, x, &quot;=&quot;, z) , paste(y, &quot;/&quot;, x, &quot;=&quot;, z) ) } Since we have three steps and each step has 6 possible operators, there are in total \\(6^3 = 216\\) possible combinations of the operator sequence. Let’s get all the combinations as below. n_ops &lt;- 6 op_mat &lt;- permutations(n_ops, n_nums-1, repeats.allowed = TRUE) head(op_mat, 10) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 1 1 #&gt; [2,] 1 1 2 #&gt; [3,] 1 1 3 #&gt; [4,] 1 1 4 #&gt; [5,] 1 1 5 #&gt; [6,] 1 1 6 #&gt; [7,] 1 2 1 #&gt; [8,] 1 2 2 #&gt; [9,] 1 2 3 #&gt; [10,] 1 2 4 Let’s look at some possible row for the example (1, 5, 5, 5). Operator_Seq Step1 Step2 Step3 Value 1, 2, 3 1 + 5 (1 + 5) - 5 ((1 + 5) - 5)*2 2 5, 3, 4 1 / 5 5 - 1 / 5 (5 - 1 / 5)*5 24 6, 2, 1 5 / 1 5/1 - 5 5/1 - 5 + 5 5 Out of all possible operator sequence, it turns out some of there are redundant when we also consider all permutations of the numbers. The most obvious ones are the operator sequence that starts with 5 or 6. To see this, note that cal(x, y, 5) and cal(y, x, 2) both equal y - x, and cal(x, y, 6) and cal(y, x, 4) both equal to y/x. Therefore, we can safely remove all operator sequences that start with 5 or 6. op_mat &lt;- op_mat[op_mat[,1]&lt;=4, ] There are in total 144 possible operator sequences for each number sequence. "],["composite-operator.html", "14.2 Composite Operators and Check Solution", " 14.2 Composite Operators and Check Solution 14.2.1 Composite Operators Now, we are ready to automate the three-step composite operators process. Let’s say we consider the number sequence in the second row of nums_perm: 5, 1, 5, 5, with the ninth row of op_mat: 1, 2, 3. We know the composite operation goes as below along with the corresponding steps printed. re_1 &lt;- cal(nums_perm[2, 1], nums_perm[2, 2], op_mat[9, 1]) print_op(nums_perm[2, 1], nums_perm[2, 2], re_1, op_mat[9, 1]) #&gt; [1] &quot;5 + 1 = 6&quot; re_2 &lt;- cal(re_1, nums_perm[2, 3], op_mat[9, 2]) print_op(re_1, nums_perm[2, 3], re_2, op_mat[9, 2]) #&gt; [1] &quot;6 - 5 = 1&quot; re_3 &lt;- cal(re_2, nums_perm[2, 4], op_mat[9, 3]) print_op(re_2, nums_perm[2, 4], re_3, op_mat[9, 3]) #&gt; [1] &quot;1 * 5 = 5&quot; To make our code more compact, we can write a loop over the three operators. sol &lt;- rep(0, n_nums) sol[1] &lt;- nums_perm[2, 1] for(step in 1:(n_nums-1)){ sol[step + 1] &lt;- cal(sol[step], nums_perm[2, step+1], op_mat[9, step]) cat(print_op(sol[step], nums_perm[2, step+1], sol[step + 1], op_mat[9, step]), &quot;\\n&quot;) } #&gt; 5 + 1 = 6 #&gt; 6 - 5 = 1 #&gt; 1 * 5 = 5 To prepare this step as a standalone function for computing all the steps, let’s write a function. num_op &lt;- function(num, op, n_nums = length(num)){ sol &lt;- num for(step in 1:(n_nums-1)) sol[step + 1] &lt;- cal(sol[step], num[step+1], op[step]) return(sol) } sol &lt;- num_op(nums_perm[2, ], op_mat[9, ]) sol #&gt; [1] 5 6 1 5 14.2.2 Check if Solution is Found Once we finish the composite operations, we can check whether our final result is equal to the target value, 24. goal &lt;- 24 if(abs(sol[n_nums] - goal) &lt; 1e-5){ cat(&quot;Found a solution!&quot;) } else { cat(&quot;This is not a solution.&quot;) } #&gt; This is not a solution. If it does, we can print the solution. Let’s write another function to print all the intermediate steps. print_sol &lt;- function(nums, sol, op){ sol &lt;- round(sol, 3) #Only keep 3 digits to make it better looking. n_nums &lt;- length(sol) for(step in 1:(n_nums-1)){ cat(print_op(sol[step], nums[step+1], sol[step + 1], op[step]), &quot;\\n&quot;) } } print_sol(nums_perm[2, ], sol, op_mat[9, ]) #&gt; 5 + 1 = 6 #&gt; 6 - 5 = 1 #&gt; 1 * 5 = 5 14.2.3 Looping Over All Number Sequences and All Operator Sequences Now, we know how to compute the final value given a number sequence and a operator sequence. Let’s write double loop over the number sequences and the operator sequences. Note that we only want to print the steps when we have found a solution. n_sols &lt;- 0 for(i in 1:nrow(nums_perm)) for(j in 1:nrow(op_mat)){ num_cur &lt;- nums_perm[i, ] op_cur &lt;- op_mat[j, ] sol &lt;- num_op(num_cur, op_cur) if(abs(sol[n_nums] - goal) &lt; 1e-5){ n_sols &lt;- n_sols + 1 cat(&quot;Solution #&quot;, n_sols, &quot;\\n&quot;) print_sol(num_cur, sol, op_cur) } } #&gt; Solution # 1 #&gt; 1 / 5 = 0.2 #&gt; 5 - 0.2 = 4.8 #&gt; 4.8 * 5 = 24 if(n_sols == 0){ cat(&quot;Solution not exist!&quot;) } From the result, we can see that there is one solution to this difficult problem. "],["solve24.html", "14.3 Solve 24", " 14.3 Solve 24 Let’s first review the helper functions we created. # single step operation cal &lt;- function(x, y, op){ switch(op, x + y, x - y, x * y, x / y, y - x, y / x) } # multi-step operations num_op &lt;- function(num, op, n_nums = length(num)){ sol &lt;- num for(step in 1:(n_nums-1)) sol[step + 1] &lt;- cal(sol[step], num[step+1], op[step]) return(sol) } # print a single step print_op &lt;- function(x, y, z, op){ switch(op, paste(x, &quot;+&quot;, y, &quot;=&quot;, z) , paste(x, &quot;-&quot;, y, &quot;=&quot;, z) , paste(x, &quot;*&quot;, y, &quot;=&quot;, z) , paste(x, &quot;/&quot;, y, &quot;=&quot;, z) , paste(y, &quot;-&quot;, x, &quot;=&quot;, z) , paste(y, &quot;/&quot;, x, &quot;=&quot;, z) ) } # print multi-steps (the solution) print_sol &lt;- function(nums, sol, op){ sol &lt;- round(sol, 3) #Only keep 3 digits to make it better looking. n_nums &lt;- length(sol) for(step in 1:(n_nums-1)){ cat(print_op(sol[step], nums[step+1], sol[step + 1], op[step]), &quot;\\n&quot;) } } With all the preparations, we are ready to present the final function to solve 24. In the solve_24() function, the first argument nums contains the numbers, goal is the target value with default 24, and n_sols_max represents the maximum number of solutions to search for, with a default value of 3. solve_24 &lt;- function(nums, goal = 24, n_sols_max = 3){ require(gtools) n_nums &lt;- length(nums) nums_perm &lt;- unique(permutations(n_nums, n_nums, nums, set = FALSE)) #generate all number permutations n_ops &lt;- 6 op_mat &lt;- permutations(n_ops, n_nums-1, repeats.allowed = TRUE) #generate all operator sequences op_mat &lt;- op_mat[op_mat[,1]&lt;=4, ] #remove redundant ones n_sols &lt;- 0 #initialize the number of solutions to be 0 for(i in 1:nrow(nums_perm)) #loop over all possible permutations for(j in 1:nrow(op_mat)){ #loop over all possible operator sequences num_cur &lt;- nums_perm[i, ] #get the current permutation op_cur &lt;- op_mat[j, ] #get the current operator sequence sol &lt;- num_op(num_cur, op_cur) #get the steps if(abs(sol[n_nums] - goal) &lt; 1e-5 &amp; all(sol &gt;= 0)){ #check if it is a solution n_sols &lt;- n_sols + 1 #increase the solution counter cat(&quot;Solution #&quot;, n_sols, &quot;\\n&quot;) print_sol(num_cur, sol, op_cur) #print the solution } if(n_sols &gt;= n_sols_max){ return(invisible(NULL)) } } if(n_sols == 0){ #fail to find a solution cat(&quot;Solution not exist!&quot;) } } Now, we are reading to look at some examples. solve_24(1:4) #&gt; Solution # 1 #&gt; 1 + 2 = 3 #&gt; 3 + 3 = 6 #&gt; 6 * 4 = 24 #&gt; Solution # 2 #&gt; 1 * 2 = 2 #&gt; 2 * 3 = 6 #&gt; 6 * 4 = 24 #&gt; Solution # 3 #&gt; 1 / 2 = 0.5 #&gt; 0.5 / 3 = 0.167 #&gt; 4 / 0.167 = 24 solve_24(c(1, 5, 5, 5)) #&gt; Solution # 1 #&gt; 1 / 5 = 0.2 #&gt; 5 - 0.2 = 4.8 #&gt; 4.8 * 5 = 24 solve_24(c(3, 7, 3, 7)) #&gt; Solution # 1 #&gt; 3 / 7 = 0.429 #&gt; 0.429 + 3 = 3.429 #&gt; 3.429 * 7 = 24 solve_24(c(3, 8, 3, 8)) #&gt; Solution # 1 #&gt; 8 / 3 = 2.667 #&gt; 3 - 2.667 = 0.333 #&gt; 8 / 0.333 = 24 solve_24(c(2, 5, 5, 5)) #&gt; Solution not exist! Note that the function is more powerful than merely solving 24. It contains two extensions. The target value can be any number, for example, 25, or 100. The input can contain more or less than 4 numbers. Let’s look at two interesting examples. solve_24(c(12, 13, 23, 25, 25), n_sols_max = 1) #&gt; Solution # 1 #&gt; 12 + 13 = 25 #&gt; 25 * 23 = 575 #&gt; 575 + 25 = 600 #&gt; 600 / 25 = 24 solve_24(11:16, 100, n_sols_max = 1) #&gt; Solution # 1 #&gt; 11 * 12 = 132 #&gt; 132 + 13 = 145 #&gt; 145 - 14 = 131 #&gt; 131 - 15 = 116 #&gt; 116 - 16 = 100 There are other possible extensions of the function we wrote. For example, you can add additional possible operators (e.g. the exponentiation ^, the factorial !) by changing the cal() and print_op as well as some constants in the solve_24() function. "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
