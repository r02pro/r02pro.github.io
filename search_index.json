[["index.html", "R Programming: Zero to Pro Preface", " R Programming: Zero to Pro Yang Feng and Jianan Zhu 2021-10-16 Preface This book is for anyone who is interested in learning R and Data Science. It is designed for people with zero background in programming. We also have a companion R package named r02pro, containing the data sets used as well as interactive exercises for each part. If you have any questions or feedback (including typos or grammar issues) about any materials in the book, we greatly appreciate if you can write to us at r02pro007@gmail.com. We will also add your name in the Acknowledgement section to show our gratitude. "],["acknowledgement.html", "Acknowledgement", " Acknowledgement This book is the product of numerous collaborative efforts. Among all people, we are most grateful to the students in the course GPH-GU 2183: Introduction to Statistical Programming in R in Fall 2021 at New York University. The list of people that made contributions include Xiaofeng Yang (@well9801), Neethu Grace Johnson (@neethujohnson01), Yifan Lai (@Yifan-Lai), Ruiming Yu (@OmakaseMaster), Zhihao Chen (@edwardzchen) "],["introduction.html", "Chapter 1 Introduction", " Chapter 1 Introduction This chapter begins with the installation of R, RStudio, and R Packages in Section 1.1, shows how to use R as a fancy calculator in Section 1.2, and introduce how to do object assignments in Section 1.3. "],["Installation.html", "1.1 Installation of R, RStudio and R Packages", " 1.1 Installation of R, RStudio and R Packages 1.1.1 Download and Install As a first step, you need to download R and RStudio, whose links are as follows. For both software, you need to choose the version that corresponds to your operation system. Download R: https://cloud.r-project.org/ Download RStudio: https://rstudio.com/products/rstudio/download/#download RStudio is an Integrated Development Environment for R, which is powerful yet easy to use. Throughout this book, you will use RStudio instead of R to learn R programming. Next, let’s get started with a quick tour of RStudio. 1.1.2 RStudio Interface After opening RStudio for the first time, you may find that the font and button size is a bit small. Let’s see how to customize the appearance. a. Customize appearance On the RStudio menu bar, you can click Tools, and then click on Global Options as shown in the following figure. Figure 1.1: Global Options Then, you will see a window pops up like Figure 1.2. After clicking on Appearance, you can see several drop-down menus including Zoom and Editor font size, among other choices shown. Zoom controls the overall scale for all elements in RStudio interface, including the sizes of menu, buttons, as well as the fonts. Editor font size controls the size of the font only in the code editor. After adjusting the appearance, you need to click on Apply to save our settings. Figure 1.2: Zoom and Editor font size Here, we change the Zoom to 150% and set the Editor font size to 18. b. Four panels of RStudio Now, the RStudio interface is clearer with bigger font size. Although RStudio has four panels, not all of them are visible to us at the beginning (Figure 1.3). Figure 1.3: Unfold panels In Figure 1.3, we have labeled three useful buttons as 1, 2, and 3. By clicking buttons 1 and 3, you can reveal the two hidden panels.1 By clicking button 2, we can clear the content in the bottom left panel as shown in the following figure. Figure 1.4: Four panels Now, let’s take a close look at all four panels, which are labeled as 1-4 in Figure 1.4. You can change the size of each panel by dragging the two blue slides up or down and the green slide left or right. Panels 1 and 2 are located to the left of the green line, and are collectively called the Code Area. We will introduce them in the following parts of this section. Panels 3 and 4 are located to the right of the green line, and are collectively called R Support Area. We will introduce these two panels in later sections. c. Console Now, let’s introduce the panel 2 in Figure 1.4, which is usually called the Console. By clicking the mouse on the line after the &gt; symbol, you can see a blinking cursor, indicating that R is ready to accept codes. Let’s type 1 + 2 and press Return (on Mac) or Enter (on Windows). It is a good habit to add spaces around an operator to increase readability of the code. Figure 1.5: Writing code in the console Hooray! You have successfully ran our first piece of R code and gotten the correct answer 3. Note that the blinking cursor now appears on the next line, ready to accept a new line of code. Figure 1.6: R code(2) The curious you may found that there is a [1] showing before the result 3. In fact, the [1] is an index indicator, showing the next element has an index of 1 in this particular object. We will revisit this point when we introduce vectors that contain more than one elements. Although the console may work well for some quick calculations, you need to resort to the panel 1 in Figure 1.4 (usually called the Editor) to save our work and run multiple lines of code at the same time. d. Save R codes as scripts The Editor panel is the go-to place to write complicated R codes, which you can save as R scripts for repeated use in the future. Firstly, we will introduce how to run codes in scripts. Let’s go to the editor and type 1 + 2. To run this line of code, you can click the Run button. The keyboard shortcut of running this line of code is Cmd+Return on Mac or Ctrl+Enter on Windows. Figure 1.7: script RStudio will then send the line of code to the console and execute the code. You can also run multiple lines of code by select the lines and click the Run button or use the keyboard shortcut. After finishing writing codes in the editor, you can save them as a script. To do that, you can click the Save button as shown in the Figure 1.8. The keyboard shortcut of saving files is Cmd+S on Mac or Ctrl+S on Windows. Figure 1.8: Save (I) Then you would see a pop-up file dialog box, asking you for a file name and location to save it to. Let’s call it lesson1.1 here. Figure 1.9: Save (II) After saving files successfully, you can confirm the name of the R script on the top. Figure 1.10: Save (III) Lastly, if you want to create a new R script, you can click the + button on the menu, then select R Script. Then you will see a new file created. Add a screenshot here Note that there are quite a few other options including R Markdown, which will be introduced in Section 11. Figure 1.11: create a new script 1.1.3 Install and load R packages Now, you have had a basic understanding of RStudio, it is time to introduce R packages, which greatly extend the capabilities of base R. There are a large number of publicly available R packages. As of July 2021, there are more than 17K R packages on Comprehensive R Archive Network (CRAN), with many others located in Bioconductor, GitHub, and other repositories. To install an R package, you need to use a built-in R function , which is install.packages(). A function takes in arguments (inputs) and performs a specific task. After the function name, we always need to put a pair of parentheses with the arguments inside. While there are many built-in R functions, R packages usually contain many useful functions as well, and we can also write our own functions, which will be introduce in Chapter 10. With install.packages(), the argument is the package name with a pair of quotation marks around it. The task it performs is installing the specific package into R. Here, you will install the companion package for this book, named r02pro, a.k.a. R Zero to Pro. The r02pro package contains several data sets that will be used throughout the book, and interactive exercises for each subsection. install.packages(&quot;r02pro&quot;) If you miss the right parenthesis, R will show a plus on the next line (as shown in Figure 1.12), waiting for more input to complete the command. If this happens, you can either enter the right parenthesis, or press ESC to escape this command. When you see a blinking cursor after the &gt; symbol, you can write new codes again. Figure 1.12: Miss the right parenthesis After a package is installed, you still need to load it into R before using it. To load a package, you can use the library() function with the package name as its argument. Here, the quotation marks are not necessary. library(r02pro) Note that once a package is installed, you don’t need to install it again on the same machine. However, when starting a new R session, you would need to load the package again. Quotation marks are necessary for installing R packages, but are not necessary for loading packages. If we install packages without quotation marks. We will see an error message, showing object not found. install.packages(r02pro) 1.1.4 Exercises Which of the following code using to install packages into R will cause an error? install.packages(\"r02pro\") install.packages(r02pro) Write R code to load the package r02pro Write R code to calculate 2 + 3. Note that you may see different panels hidden when you open RStudio for the first time, depending on the RStudio version. However, you can always reveal the hidden panels by clicking the corresponding buttons like Buttons 1 and 3 in Figure 1.3.↩︎ "],["Calculator.html", "1.2 Use R as a Fancy Calculator", " 1.2 Use R as a Fancy Calculator While R is super powerful, it is, first of all, a very fancy calculator. 1.2.1 Add comments using “#” The first item we will cover is about adding comments. In R, you can add comments using the pound sign #. In each line, anything after # are comments, which will be ignored by R. Let’s see an example, 6 - 1 / 2 #first calculate 1/2=0.5, then 6-0.5=5.5 #&gt; [1] 5.5 Just looking at the resulting value 5.5, you may not know the detail of the calculation process. The comment informs you the operation order: the division is calculated before the subtraction. In general, adding comments to codes is a very good practice, as it greatly increases readability and make collaboration easier. We will also add many comments in our codes to help you learn R. 1.2.2 Basic calculation Now let’s start to use R as a calculator! You can use R to do addition, subtraction, multiplication，division, and combine multiple basic operations. You can also calculate the square root, absolute value and the sign of a number. Operation Explanation 1 + 2 addition 1 - 2 subtraction 2 * 4 multiplication 2 / 4 division 6 - 1 / 2 multiple operations sqrt(100) square root abs(-3) absolute value sign(-3) sign While the first seven operations in the table look intuitive, you may be wondering, what does the sign() function mean here? Is it a stop sign? Sometimes, you may have no idea how a particular function works. Fortunately, R provides a detailed documentation for each function. There are three ways to ask for help in R. Use a question mark followed by the function name, e.g. ?sign Use help function, e.g. help(sign) Use the help window in RStudio, as shown in Figure 1.13. The help window is the panel 4 of Figure 1.4 in Section 1.1. Then type in the function name in the box to the right of the magnifying glass and press return. Figure 1.13: Ask for help 1.2.3 Approximation After learning about doing basic calculations, let’s move on to do approximation in R. When you do division, for example, when computing 7 / 3, the answer is not a whole number since 7 is not divisible by 3. Under these circumstances, approximation operators are very handy to use. Let’s take 7 / 3 as the example. a. Get the integer part and the remainder Code Name 7%/%3 integer division 7%%3 modulus We all know that 7 = 3 * 2 + 1. So the integer division will pick up the integer part, which is 2 here; and the modulus will get the remainder, which is 1. b. Get the nearby integer floor(7 / 3) #&gt; [1] 2 ceiling(7 / 3) #&gt; [1] 3 Since 2 &lt;= 7/3 &lt;= 3, you can use the floor function to find the largest integer &lt;= 7/3, which is 2; and the ceiling function gives the smallest integer &gt;= 7/3, which is 3. c. Round to the nearest number round(7 / 3) #&gt; [1] 2 round(7 / 3, digits = 3) #&gt; [1] 2.333 The round() function follows the rounding principle. By default, you will get the nearest integer to 7 / 3, which is 2. If you want to control the approximation accuracy, you can add a digits argument to specify how many digits you want after the decimal point. Here you will get 2.333 after adding digits = 3. 1.2.4 Power &amp; logarithm You can also use R to do power and logarithmic operations. Generally, you can use ^ to do power operations. For example, 10^5 will give us 10 to the power of 5. Here, 10 is the base value, and 5 is the exponent. The result is 100000, but it is shown as 1e+05 in R. That’s because R uses the so-called scientific notation. scientific notation: a common way to express numbers which are too large or too small to be conveniently written in decimal form. Generally, it expresses numbers in forms of \\(m \\times 10^n\\) and R uses the e notation. Note that the e notation has nothing to do with the natural number \\(e\\). Let’s see some examples, \\[\\begin{align} 1 \\times 10^5 &amp;= \\mbox{1e+05}\\\\ 2 \\times 10^4 &amp;= \\mbox{2e+04}\\\\ 1.2 \\times 10^{-3} &amp;= \\mbox{1.2e-03} \\end{align}\\] In mathematics, the logarithmic operations are inverse to the power operations. If \\(b^y = x\\) and you only know \\(b\\) and \\(x\\), you can do logarithm operations to solve \\(y\\) using the general form \\(y = \\log(x, b)\\), which is called the logarithm of \\(x\\) with base \\(b\\). In R, logarithm functions with base value of 10, 2, or the natural number \\(e\\) have shortcuts log10(), log2(), and log(), respectively. Let’s see an example of log10(), the logarithm function with base 10. 10^6 #&gt; [1] 1e+06 log10(1e6) #log10(x) = log(x, 10) #&gt; [1] 6 Next, let’s see log2(), the logarithm function with base 2. 2^10 #&gt; [1] 1024 log2(1024) #log2(x) = log(x, 2) #&gt; [1] 10 Before moving on to the natural logarithm, note that the natural number \\(e\\) needs to be written as exp(1) in R. When you want to do power operations on \\(e\\), you can simply change the argument in the function exp(), for example, exp(3) is \\(e\\) to the power of 3. Here, log() without specifying the base argument represents the logarithm function with base \\(e\\). exp(1) #&gt; [1] 2.718282 exp(3) #&gt; [1] 20.08554 log(exp(3)) #log(x) = log(x, exp(1)) #&gt; [1] 3 1.2.5 Trigonometric function R also provides the common trigonometric functions. cos(pi) #&gt; [1] -1 acos(-1) #&gt; [1] 3.141593 Here, acos() is the inverse function of cos(). If we set \\(cos(a) = b\\), then we will get \\(acos(b) = a\\). sin(pi/2) #&gt; [1] 1 asin(1) #&gt; [1] 1.570796 Similarly, asin() is the inverse function of sin(). If we set \\(sin(a) = b\\), then we will get \\(asin(b) = a\\). tan(pi/4) #&gt; [1] 1 atan(1) #&gt; [1] 0.7853982 Also, atan() is the inverse function of tan(). If we set \\(tan(a) = b\\), then we will get \\(atan(b) = a\\). 1.2.6 Exercises Write R code to compute \\(\\sqrt{5 \\times 5}\\). Write R code to get help on the function floor. Write R code to compute the square of \\(\\pi\\) and round it to 4 digits after the decimal point. Write R code to compute the logarithm of 1 billion with base 1000. Write R code to verify \\(sin^2(x) + cos^2(x) = 1\\), for \\(x = 724\\). "],["Object-Assignment.html", "1.3 Object Assignment", " 1.3 Object Assignment In the last section, you have seen the power of R as a fancy calculator. However, in order to do more complicated and interesting tasks, you may need to store intermediate results for future use. Let’s take a look at a concrete example. Say if you want to do the following calculations involving exp(3) / log(20,3) * 7. (exp(3) / log(20,3) * 7) + 3 #addition (exp(3) / log(20,3) * 7) - 3 #subtraction (exp(3) / log(20,3) * 7) / 3 #division You need to type the expression exp(3) / log(20,3) * 7 three times, which is a bit cumbersome. In this section, we will introduce how to do object assignment with exp(3) / log(20,3) * 7 which can help you to assign the value of it to a name for future use. Then, for any operation involving exp(3) / log(20,3) * 7, you can just use the corresponding name instead. 1.3.1 What is an R Object? Before we get started, let’s firstly have a basic understanding of the most important thing in R, which is called object. In principle, everything that exists in R is an object. For example, the number 5 is an object, the expression 1 + 2 is an object, the expression floor(7 / 3) is an object, and of course expression exp(3) / log(20,3) * 7 is also an object. If you run 5, you will get one element of value 5 from the output. Similarly, if you run 1 + 2, you will get one element of value 3 from the output. You can try to run floor(7 / 3) and exp(3) / log(20,3) * 7 by yourself. In these four examples, you can see that there is only one element in each object. However, an object can contain more than one elements, and each element has its own value. Notice that different elements can have the same value. Therefore, different objects can have different values. 1.3.2 Assignment Operation with &lt;- Knowing the importance of objects and their corresponding values, let’s introduce how to do object assignments in R. To do object assignments, you need to assign value(s) to a name via the assignment operator, which will create a new object with a name. You can use the new named object once it is created in subsequent calculations without redundancy. Let’s start with a simple example, x_numeric &lt;- 5 The assignment operation has three components. From left to right， the first component x_numeric is the object name of a new object, which has certain naming rules which we will discuss shortly in Section 1.3.4. The second component is the assignment operator &lt;-, which is a combination of the less than sign &lt; immediately followed by the minus sign -. The final component is the value(s) to be assigned to the name, which is 5 here. There is no space between &lt; and - in the assignment operator &lt;-. Note that although = may also appear to be working as the assignment operator, it is not recommended as = is usually reserved for specifying the value(s) of arguments in a function call, which will be introduced in Section 2.3. After running the code above, you will see no output in the console, unlike the case when we ran 1 + 2 which gives us the answer 3 (as shown in the Figure 1.14). You may be wondering, did we successfully make our first assignment operation? Figure 1.14: No output To verify it, you can run the code with just the object name to check its value. (For named objects, you can get their value(s) by running codes with their object names.) x_numeric #&gt; [1] 5 Great! You get the value 5, indicating that you have successfully assigned the value 5 to the name x_numeric, and you have created a new object x_numeric. You can use x_numeric instead of 5 to do the subsequent calculations because x_numeric and 5 have the same value. You can assign value(s) of any R objects to a name. Let’s try to simplify the three expressions we did at the beginning of this section. It is easy to observe that the three lines of codes share a common term exp(3) / log(20,3) * 7. Let’s assign the value of the common term to a name. y_numeric &lt;- exp(3) / log(20,3) * 7 y_numeric #&gt; [1] 51.56119 Now you have successfully created an object y_numeric with value 51.56119. Using the named object y_numeric, you can simplify the three calculations as follows. y_numeric + 3 y_numeric - 3 y_numeric / 3 Note that in the object assignment process, it is not the expression itself but rather the value(s) of the expression, that is assigned to a name. So you will not get the expression exp(3) / log(20,3) * 7 from y_numeric. You can also try the following examples by yourself. a &lt;- floor(7 / 3) a b &lt;- 7%/%3 b Clearly, using the object assignment, you can greatly simplify your code and avoid redundancy. Note that R object names are case-sensitive. For example, you have defined x_numeric, but if you type X_numeric, you will get an error message as follow. X_numeric #&gt; Error in eval(expr, envir, enclos): object &#39;X_numeric&#39; not found 1.3.3 Review objects in environment After creating new objects x_numeric and y_numeric, they will appear in the Environment, located in the top right panel (panel3 in Figure 1.4). You can check all the named objects and their values in this area. It is helpful to monitor the environment from time to time to make sure everything look fine. Notice that objects without names will not be shown in the environment. You can also see the list of all the named objects using function ls(). ls() #&gt; [1] &quot;a&quot; &quot;allx&quot; #&gt; [3] &quot;ally&quot; &quot;alpha1&quot; #&gt; [5] &quot;b&quot; &quot;beta1&quot; #&gt; [7] &quot;Code&quot; &quot;cols&quot; #&gt; [9] &quot;contributors&quot; &quot;d&quot; #&gt; [11] &quot;data&quot; &quot;date_char&quot; #&gt; [13] &quot;ds16_Nobel_Laureates_and_Chocolate&quot; &quot;Explanation&quot; #&gt; [15] &quot;frac&quot; &quot;GaltonFamilies&quot; #&gt; [17] &quot;ind0&quot; &quot;ind1&quot; #&gt; [19] &quot;lmod&quot; &quot;logic1&quot; #&gt; [21] &quot;manilius&quot; &quot;moon3&quot; #&gt; [23] &quot;my_int&quot; &quot;N&quot; #&gt; [25] &quot;Name&quot; &quot;Operation&quot; #&gt; [27] &quot;ori_overall_list&quot; &quot;ori_overall_list_logistic&quot; #&gt; [29] &quot;ori_overall_list_svm&quot; &quot;ori_typeI_list&quot; #&gt; [31] &quot;ori_typeI_list_logistic&quot; &quot;ori_typeI_list_svm&quot; #&gt; [33] &quot;ori_typeII_list&quot; &quot;ori_typeII_list_logistic&quot; #&gt; [35] &quot;ori_typeII_list_svm&quot; &quot;overall_list&quot; #&gt; [37] &quot;overall_list_logistic&quot; &quot;overall_list_svm&quot; #&gt; [39] &quot;p1&quot; &quot;p2&quot; #&gt; [41] &quot;p3&quot; &quot;Pattern&quot; #&gt; [43] &quot;pima&quot; &quot;sheepstudio&quot; #&gt; [45] &quot;today&quot; &quot;today_char&quot; #&gt; [47] &quot;tr_size0&quot; &quot;tr_size1&quot; #&gt; [49] &quot;typeI_list&quot; &quot;typeI_list_logistic&quot; #&gt; [51] &quot;typeI_list_svm&quot; &quot;typeII_list&quot; #&gt; [53] &quot;typeII_list_logistic&quot; &quot;typeII_list_svm&quot; #&gt; [55] &quot;vec_with_name1&quot; &quot;x&quot; #&gt; [57] &quot;x_numeric&quot; &quot;x_w_name&quot; #&gt; [59] &quot;x_wo_name&quot; &quot;x1&quot; #&gt; [61] &quot;xs4&quot; &quot;y&quot; #&gt; [63] &quot;y_numeric&quot; &quot;y1&quot; #&gt; [65] &quot;y2&quot; &quot;y3&quot; #&gt; [67] &quot;yb8&quot; &quot;z1&quot; All the objects shown in the environment or the list have been saved in R, so they are available for future use directly. It is a good habit to do object assignments if you want to save important values for future use. 1.3.4 Object naming rule Now you have created two named objects x_numeric and y_numeric. In general, R is very flexible in the name you give to an object，however, there are three important rules you need to follow. a. Must start with a letter or . (period) If starting with period, the second character can’t be a number. b. Can only contain letters, numbers, _ (underscore), and . (period) One recommended naming style is to use lowercase letters and numbers, and use underscore to separate words within a name. So you can use relatively longer names that is more readable. c. Can not use special keywords as names. For example, TRUE &lt;- 12 is not permitted as TRUE is a special keyword in R. You can see from the following that this assignment operation leads to an error message. TRUE &lt;- 12 #&gt; Error in TRUE &lt;- 12: invalid (do_set) left-hand side to assignment Some commonly used reserved keywords that cannot be used as names are listed as below. break NA else NaN FALSE next for repeat function return if TRUE Inf while To get a complete list of reserved words, you can run the following code. ?Reserved 1.3.5 Object types In this section, you have learned about how to assign a value to a name. The values you assigned are all of numeric type. Actually, an object may contain more than one values. Also, the values it contains can be of other types than numeric, including character and logical. Depending on the composition of values, the object belongs to one particular type. Type Section Vector 2.1 Matrix 3.1 Array 3.2 Data Frame 3.3 List 3.5 We will focus on vectors in Chapter 2 and discuss other object types in Chapter 3. While some of the object types look more intuitive than others, you have nothing to worry about since we have the next two chapters devoted to the details of R objects. Objects are the building blocks of R programming and it will be time well spent mastering every object type. 1.3.6 Exercises Write R code to assign the value 20 to the name num_1. Which of the following is a valid object name in R? 2.True else I_am_not_a_valid_name I_am_a_Pretty#_name Write R code to get the list of all objects in the environment. "],["r-objects.html", "Chapter 2 R Objects (I): Vectors", " Chapter 2 R Objects (I): Vectors In this chapter, we focus on the most fundamental R object type: vectors. We will introduce different vector types, creating vectors with patterns, applying different functions and operations on vectors, comparing and extracting vectors. We will also discuss data and times, factors, and how R represents unexpected results. "],["vector.html", "2.1 Vectors: Numeric, Character, and Logical", " 2.1 Vectors: Numeric, Character, and Logical In the last chapter, you have had a basic understanding of R objects and how to do object assignments. From this section, we will start to introduce the first and perhaps the most fundamental R object type, called vector. Vector is the simplest object type in R, which contains one or more values of the same type. We will introduce numeric vector, character vector, and logical vector in this section. Let’s begin with numeric vector. 2.1.1 Numeric vector a. Create numeric vectors A numeric vector is a type of vector that only contains values of numeric type. For example, 6 is a numeric vector with one element of value 6. For vectors, the number of elements corresponds to the length of vector, so 6 is a numeric vector with length 1. After assigning the value 6 to the name x1, you have created a new vector x1 with the same value as 6, so x1 is also a numeric vector. And you can refer to x1 in the subsequent calculations. 6 #a numeric vector with length 1 x1 &lt;- 6 #x1 is also a numeric vector with length 1 x1 #check the value of x1 But can a numeric vector contain more than one values? The answer is a big YES! In R, you can use the c() function (c is short for combine) to combine elements into a numeric vector. c(1, 3, 3, 5, 5) #use c() to combine elements into a numeric vector of length 5 y1 &lt;- c(1, 3, 3, 5, 5) #y1 is also a numeric vector of length 5 y1 #check the value of y1 length(y1) #length of a vector In this example, you have created a length-5 object using the c() function with arguments containing the five elements separated by comma. Since the value of each element is a number, the object is a numeric vector. If you assign the values to the name y1, you will get a new numeric vector y1 with 5 values. Notice that the second and third elements have the same value 3 in y1. You can verify the contents of y1 and check the length of it through the length() function. When you assign several values to a name, the order of the values will not change after assignment. If you create two numeric vectors with same numbers of different orders, these objects will have different values. For example, y2 &lt;- c(1, 3, 5, 7, 9) y2 y3 &lt;- c(9, 7, 5, 3, 1) y3 Here, y2 and y3 have different values. If you include several numeric vectors in c(), you will also create a numeric vector as a combination of the input numeric vectors. For example, you can create a numeric vector with values from two numeric vectors. Of course you can create a new numeric vector z1 using object assignment. c(c(1,2), c(3,4)) #use c() to combine several numeric vectors into one numeric vector z1 &lt;- c(c(1,2), c(3,4)) z1 length(z1) After creating vectors, you can use the function class() to check its class. class(x1) #&gt; [1] &quot;numeric&quot; class(y1) #&gt; [1] &quot;numeric&quot; class(z1) #&gt; [1] &quot;numeric&quot; From the results, you will know that x1, y1 and z1 are numeric, which is the reason why they are called numeric vectors. b. Extract vector element and update its value To extract an element from a vector, you can use the index of the element with a pair of [ and ] surrounding it following by the vector name. y1[2] #extract the second element of `y1` #&gt; [1] 3 y2[3] #extract the third element of `y2` #&gt; [1] 5 You can also update a particular element of a vector by using the assignment operator with the extraction expression on the left and the new value on the right. y1 #&gt; [1] 1 3 3 5 5 y1[2] &lt;- 100 #update the second element of `y1` to 100 y1 #&gt; [1] 1 100 3 5 5 As you can see here, the second element of y1 is changed to 100, which is reflected via checking the value of y1. c. Operations between two numeric vectors Since numeric vectors are made of numbers, you can do arithmetic operations between them, just like the fancy calculator in Section 1.2. If two vectors are of the same length, the calculation is done elementwisely. In other words, R will perform the operation separately for each element. First, let’s create another vector x2 of length 1 and do addition with x1. x2 &lt;- 3 x1 + x2 #&gt; [1] 9 Then obviously you will get 9! Similarly, you can create another vector y2 of the same length as vector y1. Then, you can do operations between y1 and y2. y2 &lt;- c(2, 4, 1, 3, 2) y1 + y2 #&gt; [1] 3 104 4 8 7 The result is yet another length-5 vector. To check the calculation was indeed done elementwisely, you can verify that the value of the first element is \\(1 + 2 = 3\\), and value of the second element is \\(3 + 4 = 7\\), etc. Since the calculation is done elementwisely, people normally would want the two vectors to have the same length. However, there is a recycling rule in R, which is sometimes quite useful and enables us to write simpler code. Specifically, if one vector is shorter than the other vector, R will recycle (repeat) the shorter vector until it matches in length with the longer one. This recycling is particularly helpful for an operator between a length&gt;1 vector and a length-1 vector. Let’s see an example. y1 + x1 #&gt; [1] 7 106 9 11 11 From the result, you can see that each element in y1 is added by 6. The followings are a few additional examples you can try. y1 * x2 y1 / 5 y2 - x1 2.1.2 Character vector a. Create character vectors Now, let’s move to character vectors. In a character vector, the value of each element is of character type, which means each value is a string. A string is a sequence of characters (including letters, numbers, or symbols) surrounded by a pair of double quotes (\"\") or single quotes (''). To be consistent, we will stick with double quotes in this book. Let’s first create a character vector sheepstudio which only has one element. You can then check the value of this vector by typing its name and verify the vector type by using class(). sheepstudio &lt;- &quot;sheep@007&quot; sheepstudio class(sheepstudio) Double quotes need to be paired in strings. If you miss the right double quote, R will show a plus on the next line, waiting for you to finish the command. If this happens, you can either enter the matching double quote, or press ESC to escape this command. Figure 2.1: Miss the right quotation mark Similar to a numeric vector, you can use the c() function to combine several strings to create a character vector. You can verify the number of strings in the character vector by using length(), and nchar() can help you get the number of characters in each string. animals &lt;- c(&quot;sheep@29&quot;, &quot;pig$29&quot;, &quot;monkey&quot;) animals length(animals) nchar(animals) Note that if you have a vector consisted of numbers with surrounding double quotes, it is also a character vector. (“4” and “29” are strings) num_vec &lt;- c(4, 29) char_vec &lt;- c(&quot;4&quot;, &quot;29&quot;) class(num_vec) #&gt; [1] &quot;numeric&quot; class(char_vec) #&gt; [1] &quot;character&quot; b. Concatenate several strings into a single string Next, we will introduce how to concatenate several strings into a single string. To do this, you can use the paste() function. First, let’s create a character vector with four elements, four_strings &lt;- c(&quot;This&quot;, &quot;is&quot;, &quot;Sheep@29&quot;, &quot;$Studio&quot;) length(four_strings) #verify the number of strings Then use paste() instead of c(), one_long_string &lt;- paste(&quot;This&quot;, &quot;is&quot;, &quot;Sheep@29&quot;, &quot;$Studio&quot;) one_long_string #&gt; [1] &quot;This is Sheep@29 $Studio&quot; class(one_long_string) length(one_long_string) #verify the number of strings From the results, you can see that one_long_string is a character vector with length 1, and the value of one_long_string is a single string with space between the individual strings. You may notice that in paste(), the default separator between the individual strings is space. Actually you can change the separator by setting the sep argument in paste(). For example, you can separate the individual strings with comma, comma &lt;- paste(&quot;This&quot;, &quot;is&quot;, &quot;Sheep@29&quot;, &quot;$Studio&quot;, sep = &quot;,&quot;) comma #&gt; [1] &quot;This,is,Sheep@29,$Studio&quot; If you don’t want to use a separator, you can use the paste0() function. nosep &lt;- paste0(&quot;This&quot;, &quot;is&quot;, &quot;Sheep@29&quot;, &quot;$Studio&quot;) nosep #&gt; [1] &quot;ThisisSheep@29$Studio&quot; If you would like to concatenate the strings of a vector into a longer string, you need to specify the collapse argument as the separator instead of sep in the paste() function. paste(four_strings, collapse = &quot;&quot;) #&gt; [1] &quot;ThisisSheep@29$Studio&quot; paste(four_strings, collapse = &quot;,&quot;) #&gt; [1] &quot;This,is,Sheep@29,$Studio&quot; paste(four_strings) ##doesn&#39;t work without the collapse argument #&gt; [1] &quot;This&quot; &quot;is&quot; &quot;Sheep@29&quot; &quot;$Studio&quot; In addition to paste several strings into one long string, you can also use the paste() function paste two character vectors, where the pair of strings will be pasted elementwisely. paste(c(&quot;July&quot;, &quot;August&quot;), c(&quot;2007&quot;, &quot;2008&quot;)) #&gt; [1] &quot;July 2007&quot; &quot;August 2008&quot; c. Change case In character vectors, each string can contain both uppercase and lowercase letters. You can unify the cases of all letters inside a vector. Let’s review the character vector four_strings at first, four_strings &lt;- c(&quot;This&quot;, &quot;is&quot;, &quot;Sheep@29&quot;, &quot;$Studio&quot;) four_strings #&gt; [1] &quot;This&quot; &quot;is&quot; &quot;Sheep@29&quot; &quot;$Studio&quot; Then use the tolower() function to convert all letters to lower case, tolower(four_strings) #&gt; [1] &quot;this&quot; &quot;is&quot; &quot;sheep@29&quot; &quot;$studio&quot; The opposite function of tolower() is toupper(), which converts all letters to upper case, toupper(four_strings) #&gt; [1] &quot;THIS&quot; &quot;IS&quot; &quot;SHEEP@29&quot; &quot;$STUDIO&quot; 2.1.3 Logical vector So far we have created several numeric vectors and character vectors. Some vectors have names, and some do not. You can see all the named objects by using the ls() function. ls() #&gt; [1] &quot;animals&quot; &quot;char_vec&quot; &quot;comma&quot; &quot;four_strings&quot; #&gt; [5] &quot;nosep&quot; &quot;num_vec&quot; &quot;one_long_string&quot; &quot;sheepstudio&quot; #&gt; [9] &quot;x1&quot; &quot;x2&quot; &quot;y1&quot; &quot;y2&quot; #&gt; [13] &quot;y3&quot; &quot;z1&quot; As introduced in Section 1.3, another way to check the named objects is via the environment panel as shown in Figure 2.2. Figure 2.2: Environment We can see that the environment panel has two columns, with the first column showing the list of object names, and the second column showing the corresponding information for each object. The information includes the vector type (chr is short for character and num is short for numeric), the vector length, and the first few values of the vector. Note that if the vector is of length 1 (for example x1), the environment will not show the type or the length. By now you have created several objects, and you will find that the objects will not be saved in R if you don’t assign their values to names, for example, the results of x1 + x2 and y1 + y2 are not shown in the environment. Before introducing the logical vector, let’s first learn a function called is.numeric(), which checks whether a vector is of numeric type, is.numeric(y1) #Is y1 of numeric type? #&gt; [1] TRUE Similar to is.numeric(), you can also use is.character() function to check if the given vector is of character type. is.character(y1) #Is y1 of character type? #&gt; [1] FALSE You may notice that results are TRUE or FALSE from the above codes. Actually, logical vectors are vectors that only use TRUE or FALSE as values. Note that TRUE and FALSE are logical constants in R. Similarly, you can use is.logical() to check if the vector is of logical type, or you can use class() to find out the exact type. logic1 &lt;- c(TRUE, FALSE, TRUE) #you can also use the c() function to create a logical vector is.logical(logic1) class(logic1) You can also use T to represent TRUE and F to represent FALSE in logical vectors. logic2 &lt;- c(T, F, F) is.logical(logic2) class(logic2) It is worth to point out that you don’t want to put a pair of double quotes around TRUE or FALSE when you use them as logical values. If you do that, a character vector will be generated instead. char &lt;- c(&quot;TRUE&quot;, &quot;FALSE&quot;, &quot;TRUE&quot;) is.logical(char) Note that the keywords TRUE and FALSE are case sensitive, and all letters inside them need to be in upper case. If you change any letter to the lower case, you will get an error, because True is neither a logical constant nor a defined object. tlogic &lt;- True #&gt; Error in eval(expr, envir, enclos): object &#39;True&#39; not found 2.1.4 Exercises Write R code to create a numeric vector named vec_1 with values 7 24 8 26, get its length, and find out its type. Write R code to create a character vector named char_1 with values \"I\", \"am\", \"learning\", \"R!\", get its length, find out its type, and concatenate the vector into a single string with space as the separator. For the char_1 defined in Q2, find the number of characters in each string, and convert each string to upper case. Create a length-2 logical vector representing whether vec_1 and char_1 are of character type. "],["attr-coercion.html", "2.2 Vectors: Storage Types, Attributes and Coercion", " 2.2 Vectors: Storage Types, Attributes and Coercion Having learned vectors in Section 2.1, we first introduce an important concept called storage types and use two commonly used numeric classes (integers and doubles) as examples, then introduce the concept of attributes from a named vector, and discuss the coercion rule when you combine values of different types into a single vector. 2.2.1 Storage Types Having learned the numeric vector, character vector, and logical vector, it is time to introduce how they are stored in R. To find the internal storage type of an R object, you can use the typeof() function. Let’s see an example of numeric vector. my_double &lt;- c(1, 3, 4) class(my_double) #class #&gt; [1] &quot;numeric&quot; is.numeric(my_double) #&gt; [1] TRUE typeof(my_double) #storage type #&gt; [1] &quot;double&quot; We can see that the internal storage type of my_num is double, which is stored as a double precision numeric value. Looking at the values of my_num, it is easy to see that they are all integers. You may be wondering it is necessary to store the integers in a double type. The answer is no. You can definitely store the integers in a integer type, which offers great memory savings compared to doubles. The tricky part is that you usually need to explicitly tell R that you are storing them as integers. To create an integer vector, you can still use the c() function with the integers separated by comma as arguments. However, you need to put an “L” after each integer. Let’s create an integer and check its typeof(). my_int &lt;- c(1L, 3L, 4L) typeof(my_int) #&gt; [1] &quot;integer&quot; class(my_int) #&gt; [1] &quot;integer&quot; is.numeric(my_double) #&gt; [1] TRUE You can see that my_int is indeed of integer type, with the class of it being integer as well. It is also worth noting that the displaying value of my_double and my_int are the same. my_double #&gt; [1] 1 3 4 my_int #&gt; [1] 1 3 4 In addition to class() and typeof(), another useful function is str(), which gives the detailed structure of an R object along with the first few values. Whenever we have an R object, it is useful to apply class(), typeof(), and str() on it. str(my_double) #&gt; num [1:3] 1 3 4 str(my_int) #&gt; int [1:3] 1 3 4 From the str() results, my_int is stored as integers while my_double is stored as double precision numeric values. Despite the differences between integers and doubles, you can usually ignore their differences unless you are working on a very big data set. R will automatically convert objects between integers and doubles when necessary. 2.2.2 Named Vectors and Attributes In addition to storing the values of a vector, you can also create named vectors. To do that, the first option is to give each element a name in the processing of creating the vector using the form of name = value. x_wo_name &lt;- c(165, 60, 22) x_wo_name #&gt; [1] 165 60 22 x_w_name &lt;- c(height = 165, weight = 60, BMI = 22) x_w_name #&gt; height weight BMI #&gt; 165 60 22 A second way to assign names to a vector is to use the names() function. For example, if we want to represent whether it snows on each day using a logical vector. y &lt;- c(TRUE, FALSE, TRUE) y #&gt; [1] TRUE FALSE TRUE names(y) &lt;- c(&quot;Jan 1&quot;, &quot;Jan 2&quot;, &quot;Jan 3&quot;) y #&gt; Jan 1 Jan 2 Jan 3 #&gt; TRUE FALSE TRUE Note that the assignment operation looks similar to the object assignment operation. The values for names need to be a character vector. The names of a vector is a type of attributes of R Objects. We will introduce other types of attributes as we encounter them. The name attribute provides additional information regarding the meaning of each element, and enables us to extract values using the names (to be discussed in Section 2.6.3). To examine the attributes of an R object, you can use the attributes() function. The str() also displays the attributes. attributes(x_w_name) #&gt; $names #&gt; [1] &quot;height&quot; &quot;weight&quot; &quot;BMI&quot; str(x_w_name) #&gt; Named num [1:3] 165 60 22 #&gt; - attr(*, &quot;names&quot;)= chr [1:3] &quot;height&quot; &quot;weight&quot; &quot;BMI&quot; str(x_wo_name) #&gt; num [1:3] 165 60 22 You can see that x_w_name is a named numeric vector, with the names attribute. In contrast, str() function tells us x_wo_name is a plain numeric vector with no attributes. To directly extract certain attributes of an R object, you can use the attr() function on it with the second argument being the specific attribute you wish to extract. attr(x_w_name, &quot;names&quot;) #&gt; [1] &quot;height&quot; &quot;weight&quot; &quot;BMI&quot; 2.2.3 The Coercion Rule So far, you know that vectors are objects that have values of the same type, including numeric values (integers or doubles), strings, or logical values. But in practice, you may have values with a mix of different types. If you still want to combine them into a vector, R will unify all values into the most complex one, which is usually called the coercion rule. Specifically, R uses the following order of complexity (from simple to complex). \\[\\mbox{logical} &lt; \\mbox{numeric} &lt; \\mbox{character}\\] Let’s see a few examples to learn how the coercion works. The first example mixes logical values with numbers. mix_1 &lt;- c(TRUE, 7, 24, FALSE) mix_1 #&gt; [1] 1 7 24 0 typeof(mix_1) #&gt; [1] &quot;double&quot; class(mix_1) #&gt; [1] &quot;numeric&quot; You can see that the logical values are converted to numbers, in particular, TRUE will be converted to 1 and FALSE will be converted to 0 when they appear with numbers, that’s because numbers are more complex than logical values, and R will unify all values into the most complex one. Then you will see that mix_1 is a numeric vector with four numbers. This is the most commonly usage of coercion rule in R. Besides the coercion rule which automatically converts all elements into the most complex type, you can also use functions to do the conversion manually. In particular, as.numeric() converts its argument into numeric type. And as.logical() converts its argument into logical values. as.numeric(c(TRUE, FALSE)) #&gt; [1] 1 0 as.logical(c(1, 0)) #&gt; [1] TRUE FALSE as.logical(c(&quot;TRUE&quot;, &quot;FALSE&quot;)) #&gt; [1] TRUE FALSE The second example mixes numbers with strings. mix_2 &lt;- c(8, &quot;happy&quot;, 26, &quot;string&quot;) mix_2 #&gt; [1] &quot;8&quot; &quot;happy&quot; &quot;26&quot; &quot;string&quot; class(mix_2) #&gt; [1] &quot;character&quot; You can see that both 8 and 26 are converted into strings since strings are more complex than numbers. Then mix_2 will be a character vector. To manually converts an input into a character type, you can use the as.character() function. as.character(1:5) #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; The next example mixes logical values, numbers and strings. mix_3 &lt;- c(16, TRUE, &quot;pig&quot;) mix_3 #&gt; [1] &quot;16&quot; &quot;TRUE&quot; &quot;pig&quot; class(mix_3) #&gt; [1] &quot;character&quot; You can see in mix_3, both 97 and TRUE are converted to strings! That’s because values of character type are the most complex among all values. Here, you can use as.character() on the logical values. as.character(c(TRUE, FALSE)) #&gt; [1] &quot;TRUE&quot; &quot;FALSE&quot; Next, let’s see an interesting example in which we have two layers of coercion. mix_4 &lt;- c(c(16, TRUE), &quot;pig&quot;) mix_4 #&gt; [1] &quot;16&quot; &quot;1&quot; &quot;pig&quot; However, if you create another vector mix_4, you first have c(16, TRUE) which will be converted to c(16, 1) since numbers are more complex than logical values. Then, c(16, 1) will be converted to c(\"16\", \"1\") when you combine it with \"pig\", leading to the results of mix_4. Lastly, let’s talk about the coercion within numeric values. In particular, we have learned that there are two kinds of types numeric values are stored: namely integers and doubles. In the coercion rule, we have \\[\\mbox{integer} &lt; \\mbox{double}.\\] Let’s see the following examples. typeof(c(1, 5L)) #&gt; [1] &quot;double&quot; typeof(c(TRUE, 5L)) #&gt; [1] &quot;integer&quot; Let’s now summarize the coercion rule of all types we have learned. \\[\\mbox{logical} &lt; \\mbox{integer} &lt; \\mbox{double} &lt; \\mbox{character}\\] 2.2.4 Complex Vectors Another vector classes in R is complex, which stores complex numbers. my_complex &lt;- c(1 + 2i, 3 + 4i, -3 - 4i) my_complex #&gt; [1] 1+2i 3+4i -3-4i class(my_complex) #&gt; [1] &quot;complex&quot; typeof(my_complex) #&gt; [1] &quot;complex&quot; str(my_complex) #&gt; cplx [1:3] 1+2i 3+4i -3-4i You can use the functions Re(), Im(), and Mod() to get the real part, imaginary part, and the modulus of the complex vector, respectively. Re(my_complex) #&gt; [1] 1 3 -3 Im(my_complex) #&gt; [1] 2 4 -4 Mod(my_complex) #&gt; [1] 2.236068 5.000000 5.000000 2.2.5 Exercises If there are 3 lions, 5 tigers, 7 birds and 2 monkeys in the zoo, please write R code to create a named numeric vector zoo1 to clarify this situation. "],["vector-patterns.html", "2.3 Create Vectors with Patterns", " 2.3 Create Vectors with Patterns Now you are familiar with numeric vector, character vector and logical vector, and you can create them from scratch using the c() function. However, in many applications, we may want to create vectors with values of certain patterns. In this section, we will introduce several commonly used functions for generating vectors with patterns. 2.3.1 Create equally-spaced numeric vectors via : One of the commonly used patterns associated with numeric vectors is numeric vectors composed of equally-spaced integers, where the differences between adjacent values in the vectors are all \\(1\\) or \\(-1\\). Suppose we want to create a vector with consecutive integers from 1 to 5. The first method is to write all numbers down in c(), pattern1 &lt;- c(1, 2, 3, 4, 5) You can see that it is not too cumbersome to enumerate all 5 integers when creating pattern1. Let’s imagine if we want to create a vector containing 100 consecutive integers. Do we have a faster way than writing all 100 integers down? The answer is Yes! You can use the colon operator :, which is frequently used in everyday programming. (Note that you don’t need to use c() together with :) pattern2 &lt;- 1:5 #consecutive integers from 1 to 5 It is worth mentioning the subtle difference between pattern1 and pattern2. pattern1 #&gt; [1] 1 2 3 4 5 pattern2 #&gt; [1] 1 2 3 4 5 typeof(pattern1) #&gt; [1] &quot;double&quot; typeof(pattern2) #&gt; [1] &quot;integer&quot; You can see that although pattern1 and pattern2 appear to have the same values, they are stored as double and integer values, respectively. The reason is that when you create consecutive integers using :, R will store them as integers to save space. In addition to creating vectors with consecutive integers that is increasing, : can also be used to create vectors with integers in decreasing sequences. pattern3 &lt;- 6:2 #decreasing sequence from 6 to 2 pattern4 &lt;- 3:-3 #decreasing sequence from 3 to -3 Powerful the : operator is, it can only generate equally-spaced numeric vectors with increment 1 or -1. If you want to generate equally-spaced numeric vectors with different increments, you can use the more powerful seq() function. 2.3.2 Create equally-spaced numeric vectors via seq() A very efficient way to create equally-spaced numeric vectors is to use the seq() function, which is short for sequence. a. Create sequences with by argument To use the seq() function, you can specify the start value of the sequence in the from argument, the limit end value in the to argument, and the increment in the by argument. seq(from = 1, to = 5, by = 1) Here, the vector starts with 1, increases by 1 at each step, and ends at 5. Note that the from and by arguments are optional in seq(). If you don’t specify their values, seq() will use the default value 1 for both arguments. seq(to = 5) Now you have had four methods to create vectors with consecutive integers. c(1,2,3,4,5,6) #write all numbers down 1:6 #use colon operator seq(from = 1, to = 6, by = 1) #use seq() seq(to = 6) #use seq() Next, let’s change the increment to 2 and you will get a numeric vector with 1 3 5 as its values. seq(from = 1, to = 5, by = 2) #&gt; [1] 1 3 5 Note that the end value of the sequence doesn’t always equal the to argument. If you change the limit end value to 6, you still get the same sequence, since the next value in the sequence would be 7 which is larger than the limit end value 6. This is the reason why to is called the limited end value, not the end value. seq(from = 1, to = 6, by = 2) #&gt; [1] 1 3 5 Unlike :, you can set values of three arguments in seq() as decimal numbers. seq(from = 1.1, to = 6.2, by = 0.7) #&gt; [1] 1.1 1.8 2.5 3.2 3.9 4.6 5.3 6.0 Here, you will get a sequence which starts with 1.1, increases by 0.7 each time until it is larger than 6.2. You can also create a decreasing sequence by using a smaller to value than the from value, coupled with a negative value in the by argument. seq(from = 1.5, to = -1, by = -0.5) If a positive value is used in the by argument in a decreasing sequence, you will see an error message. seq(from = 1.5, to = -1, by = 0.5) #&gt; Error in seq.default(from = 1.5, to = -1, by = 0.5): wrong sign in &#39;by&#39; argument b. Create sequences with length.out argument Instead of setting the increment, you can also specify the length.out argument, which creates a sequence with equal space in the specified length. R will automatically calculate the interval between two neighboring numbers according to values of three arguments in seq(). seq(from = 1, to = 5, length.out = 9) Here, you will get a equally-spaced sequence of length 9 from 1 to 5. You can also create a decreasing sequence by using the length.out argument. seq(from = 5, to = -5, length.out = 9) Unlike creating sequences with by argument, if you specify the length.out argument in seq(), the start value and end value of the sequence you get will be exactly match the input arguments. c. Create sequences with both by and length.out arguments Lastly, if you provide both the by and length.out arguments, only one of from and to is needed. With one value (the start value or the limit end value) fixed, seq() will create a vector with specified increment and length. If you only have the from argument, you will get a sequence starting from the value you set with the increment in the by argument, until you get a sequence with specified length. seq(from = 1, by = 2, length.out = 5) If you only have the to argument, you will get a sequence end with the value you set with the increment in the by argument, until you get a sequence with specified length. seq(to = 1, by = 2, length.out = 5) One last thing regarding seq() is that you can at most provide three arguments. For example, you will see an error when running the following example since all four arguments are specified. seq(from = 1, to = 3, by = 1, length.out = 3) #&gt; Error in seq.default(from = 1, to = 3, by = 1, length.out = 3): too many arguments 2.3.3 Create matching numeric vectors via seq_along() Now, we will introduce one function related to seq(). Let’s first create a numeric vector, extend &lt;- seq(from = 2, to = 8, length.out = 9) From the seq() above, you know that the length of this vector is 9. Next, let’s put this numeric vector in seq_along(). seq_along(extend) #&gt; [1] 1 2 3 4 5 6 7 8 9 seq_along() takes a vector as its argument, and generates consecutive integers from 1 to the length of the input vector. The seq_along() function is commonly used when writing loops, which will be covered at a later time. You can also use 1:length(extend) to get the same result as seq_along(extend). 1:length(extend) 2.3.4 Create numeric vectors via sequence() Sometimes, you may want to combine multiple equally-spaced integer sequences into a single vector. To do this, you can use the function sequence(). The most common usage of sequence() is to supply a vector of integers as its input. comp_seq1 &lt;- sequence(c(2, 3, 5)) comp_seq1 #&gt; [1] 1 2 1 2 3 1 2 3 4 5 From the result, you can see that it firstly create equally-spaced vectors 1:2, 1:3, and 1:5, then combine all vectors into a single one. This avoids the trouble of writing something like c(1:2, 1:3, 1:5). 2.3.5 Create numeric, character and logical vectors with repetition Another commonly used pattern associated with vectors is repetition. Note that while the equally-spaced pattern only makes sense for numeric vectors, the repetition pattern work for all three kinds of vectors. To do repetition, you can use the rep() function, which works by repeating the first argument for the number of times indicated in the second argument. Firstly, let’s create a numeric vector with repetition. num1 &lt;- rep(2, 4) num1 #&gt; [1] 2 2 2 2 Since the first argument is 2 and the second argument is 4, 2 is repeated for 4 times, resulting a length-4 vector with all elements of value 2. The first argument can also be a numeric vector with several values. num2 &lt;- rep(c(1, 4, 2), 3) num2 #&gt; [1] 1 4 2 1 4 2 1 4 2 Here, the rep() will repeat the whole vector c(1, 4, 2) three times. Note that the vector is repeated as a whole, not elementwisely. You may be wondering what happens the second argument also has several numbers? Let’s try together. num3 &lt;- rep(c(1,5,7), c(3,2,1)) num3 #&gt; [1] 1 1 1 5 5 7 When the second argument is also a vector, R will do an element repeat operation by repeating each element in the first argument the number of times indicated in the corresponding location of the second argument, and combine the repeated vectors to a single vector. In this example, 1 is repeated 3 times, 4 is repeated twice, and 7 is repeated once. It is equivalent to c(rep(1,3), rep(4,2), rep(7,1)) The rep() function works the same way if the first argument is a character vector. animals1 &lt;- rep(c(&quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;), 2) animals1 animals2 &lt;- rep(c(&quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;), c(3, 2, 1)) animals2 You can also use logical vectors in the first argument. logic &lt;- rep(c(TRUE, FALSE), c(3,2)) logic 2.3.6 Getting unique elements and their frequencies So far, you have learned how to create vectors with different patterns. Sometimes, you may want to get the unique elements (elements of different values) of a vector and their corresponding frequencies. Let’s use num3 as an example. (Don’t forget to use ls() or check the environment panel to find all objects you have defined), num3 #check the values #&gt; [1] 1 1 1 5 5 7 You can use unique() to show all unique elements in vectors. unique(num3) #get the unique elements #&gt; [1] 1 5 7 From the result, you know the unique elements in num3 are 1,5, and 7. To get the frequency of each element, you can use the table() function. table(num3) #get the frequency table #&gt; num3 #&gt; 1 5 7 #&gt; 3 2 1 Here, the first row is the name of the object, the second row shows all unique elements, and the third row is the corresponding frequency of each element in the same column. In num3, there are three 1s, two 5s and one 7. unique() and table() work similarly for character vectors and logical vectors. You can try the following codes. animals unique(animals) table(animals) logic unique(logic) table(logic) 2.3.7 Exercises Use five different ways to create an equally-spaced sequence with 2 4 6 8 10 as result. Use two different ways to create a numeric vector with 1 2 3 1 2 3 4 5 1 2 3 4 5 6 7 as result. Show the unique elements and their corresponding frequency. Write R code using rep() function to create a character vector with the same result as c(\"sheep\",\"pig\", \"cat\",\"sheep\",\"pig\", \"cat\",\"sheep\",\"pig\", \"cat\") Write R code using rep() function to create character vector with the same result as c(\"sheep\",\"sheep\",\"pig\",\"pig\",\"pig\",\"pig\",\"cat\",\"cat\",\"cat\") "],["sort-vector.html", "2.4 Sort, Rank, &amp; Order", " 2.4 Sort, Rank, &amp; Order In the past two sections, you have mastered how to create vectors of different types including numeric, character and logical. In addition, you know how to create vectors with patterns. A vector usually contains more than one elements. Sometimes, you want to order the elements in various ways. In this section, we will introduce important functions that relate to ordering elements in a vector. 2.4.1 Numeric vectors Let’s start with numeric vectors. Firstly, let’s create a numeric vector which will be used throughout this part. x &lt;- c(2, 3, 2, 0, 4, 7) x #check the value of x a. Sort vectors The first function we will introduce is sort(). By default, the sort() function sorts elements in vector in the ascending order, namely from the smallest to largest. sort(x) #&gt; [1] 0 2 2 3 4 7 If you want to sort the vector in the descending order, namely from the largest to smallest, you can set a second argument decreasing = TRUE. sort(x, decreasing = TRUE) b. Ranks of vectors Next, let’s talk about ranks. The rank() function gives the ranks for each element of the vector, namely the corresponding positions in the ascending order. rank(x) #&gt; [1] 2.5 4.0 2.5 1.0 5.0 6.0 If you check the values of x, you can see that the smallest value of x is 0, which corresponds to the fourth element. Thus, the fourth element has rank 1. The second smallest value of x is 2, which is shared at the first and the third elements, resulting a tie (elements with the same value will result in a tie). Normally, these two elements would have ranks 2 and 3. To break the tie, the rank() function assigns all the elements involving in the tie (the first and third elements in this example) the same rank, which is average of all their ranks (the average of 2 and 3), by default. In addition to this default behavior for handling ties, rank() also provides other options by setting the ties.method argument. If you set ties.method = \"min\", all the tied elements will have the minimum rank instead of the average rank. In this case, the minimum rank is 2. rank(x, ties.method = &quot;min&quot;) #&gt; [1] 2 4 2 1 5 6 If you want to break the ties by the order element appears in the vector, you can set ties.method = \"first\". Then the earlier appearing element will have smaller ranks than the later one. In this example, the first element will have rank 2 and the third element has rank 3, since the first element appears earlier than the third element. There are other options for handling ties, which you can look up in the documentation of rank() if interested. rank(x, ties.method = &quot;first&quot;) #&gt; [1] 2 4 3 1 5 6 Unlike sort(), you can’t get positions in the descending order from the rank() function, which means you can’t add decreasing = TRUE in rank(). c. Order of vectors The next item we want to introduce is the order() function. Note that the function name order could be a bit misleading since ordering elements also has the same meaning of sorting. However, although it is related to sorting, order() is a very different function from sort(). Let’s recall the values of x and apply order() on x. x #&gt; [1] 2 3 2 0 4 7 order(x) #&gt; [1] 4 1 3 2 5 6 From the result, you can see that the order() function returns indices for the elements in the ascending order, namely from the smallest to the largest. For example, the first output is 4, indicating the 4th element in x is the smallest. The second output is 1, showing the 1st element in x is the second smallest. Unlike rank(), the order() function breaks the ties by the appearing order by default. If you want the indices corresponding to the descending order, then you can set decreasing = TRUE just like what we did in the sort() function. order(x, decreasing = TRUE) So far, we have covered sort(), rank() and order() functions for numeric vectors. It is helpful to provide a brief summary. The sort() function sorts elements in vectors. The rank() function will give ranks for each element of the vector. The order() function returns indices for the elements. 2.4.2 Character vectors Now, let’s move to character vectors. For character vectors, R uses the lexicographical ordering, which is sometimes called dictionary order since it is the order used in a dictionary. Similar to numeric vectors, let’s first prepare a character vector. Note that the strings in character vectors can contain letters, numbers, or symbols. char_vec &lt;- c(&quot;a&quot;, &quot;A&quot;, &quot;B&quot;, &quot;b&quot;, &quot;ab&quot;,&quot;aC&quot;, &quot;1c&quot;, &quot;.a&quot;, &quot;1a&quot;,&quot;2a&quot;,&quot;.a&quot;,&quot;&amp;u&quot;,&quot;3&quot;,&quot;_4&quot;) a. Ordering rules First, let’s discuss the ordering of a single character, including symbols, digits and letters. There are a few important ordering rules as follows. symbols &lt; digits &lt; letters: symbols appear first, followed by digits, and letters come last. symbols are ordered in the following way. syms &lt;- c(&quot; &quot;,&quot;,&quot;,&quot;;&quot;,&quot;_&quot;,&quot;(&quot;,&quot;)&quot;,&quot;!&quot;,&quot;[&quot;,&quot;]&quot;,&quot;{&quot;,&quot;}&quot;,&quot;-&quot;,&quot;*&quot;,&quot;/&quot;,&quot;#&quot;,&quot;$&quot;,&quot;%&quot;,&quot;^&quot;,&quot;&amp;&quot;,&quot;`&quot;,&quot;@&quot;,&quot;+&quot;,&quot;=&quot;,&quot;|&quot;,&quot;?&quot;,&quot;&lt;&quot;,&quot;&gt;&quot;,&quot;.&quot;) sort(syms) #&gt; [1] &quot; &quot; &quot;_&quot; &quot;-&quot; &quot;,&quot; &quot;;&quot; &quot;!&quot; &quot;?&quot; &quot;.&quot; &quot;(&quot; &quot;)&quot; &quot;[&quot; &quot;]&quot; &quot;{&quot; &quot;}&quot; &quot;@&quot; &quot;*&quot; &quot;/&quot; &quot;&amp;&quot; &quot;#&quot; #&gt; [20] &quot;%&quot; &quot;`&quot; &quot;^&quot; &quot;+&quot; &quot;&lt;&quot; &quot;=&quot; &quot;&gt;&quot; &quot;|&quot; &quot;$&quot; digits are in an ascending order: the smaller digits appear earlier than the bigger ones. nums &lt;- 0:9 sort(nums) #&gt; [1] 0 1 2 3 4 5 6 7 8 9 letters are alphabetically ordered, for the same letter，the lower case comes first. all_letters &lt;- c(letters,LETTERS) sort(all_letters) #&gt; [1] &quot;a&quot; &quot;A&quot; &quot;b&quot; &quot;B&quot; &quot;c&quot; &quot;C&quot; &quot;d&quot; &quot;D&quot; &quot;e&quot; &quot;E&quot; &quot;f&quot; &quot;F&quot; &quot;g&quot; &quot;G&quot; &quot;h&quot; &quot;H&quot; &quot;i&quot; &quot;I&quot; &quot;j&quot; #&gt; [20] &quot;J&quot; &quot;k&quot; &quot;K&quot; &quot;l&quot; &quot;L&quot; &quot;m&quot; &quot;M&quot; &quot;n&quot; &quot;N&quot; &quot;o&quot; &quot;O&quot; &quot;p&quot; &quot;P&quot; &quot;q&quot; &quot;Q&quot; &quot;r&quot; &quot;R&quot; &quot;s&quot; &quot;S&quot; #&gt; [39] &quot;t&quot; &quot;T&quot; &quot;u&quot; &quot;U&quot; &quot;v&quot; &quot;V&quot; &quot;w&quot; &quot;W&quot; &quot;x&quot; &quot;X&quot; &quot;y&quot; &quot;Y&quot; &quot;z&quot; &quot;Z&quot; Here, letters is a character vector pre-created by R, it has all 26 letters in the alphabet with lower case. And LETTERS is another character vector, which has all 26 letters in the alphabet with upper case. b. Sort vectors As before, you can apply sort() on character vectors. Basically, the elements of character vectors ordered by the first character of their values, move to the second character if there are ties in the first character (same first character), and look at more characters until the ties are broken or run out of characters. sort(char_vec) #&gt; [1] &quot;_4&quot; &quot;.a&quot; &quot;.a&quot; &quot;&amp;u&quot; &quot;1a&quot; &quot;1c&quot; &quot;2a&quot; &quot;3&quot; &quot;a&quot; &quot;A&quot; &quot;ab&quot; &quot;aC&quot; &quot;b&quot; &quot;B&quot; We have the following observations. Symbols appear first, followed by digits, and letters come last. According to the ordering rule of symbols, _4 is the first, .a should be the second and &amp;u is the third. 1a and 1c have the same first character, since a comes before c, 1a comes before 1c. ab and aC have the same first character, since b comes before C (regardless of the case), ab comes before aC. Of course, we can also have the order reversed by setting decreasing = TRUE. sort(char_vec, decreasing = TRUE) c. Ranks of vectors Similarly, you can look at the rank for each element according to the ordering rules. Here, the element with rank 1 is _4 and .a has rank 2. Just like numeric vectors, if you have elements with the same value in character vectors, the rank of these elements will be the same (the average of the corresponding ranks) by default. rank(char_vec) #&gt; [1] 9.0 10.0 14.0 13.0 11.0 12.0 6.0 2.5 5.0 7.0 2.5 4.0 8.0 1.0 As expected, you can set the ties.method argument in rank() to use other methods for breaking ties. rank(char_vec, ties.method = &quot;min&quot;) rank(char_vec, ties.method = &quot;first&quot;) d. Order of vectors Again, you can get the indices for each element in character vectors with the same order() function like that for numeric vectors. Also, the order() function breaks the ties by the appearing order by default. order(char_vec) #&gt; [1] 14 8 11 12 9 7 10 13 1 2 5 6 4 3 The decreasing argument still works for order()! order(char_vec, decreasing = TRUE) #&gt; [1] 3 4 6 5 2 1 13 10 7 9 12 8 11 14 2.4.3 Logical vectors Since there are only two possible values TRUE and FALSE for logical vectors, it is straightforward to sort them with the knowledge of FALSE &lt; TRUE. You can try the following example. logi_vec &lt;- c(TRUE, FALSE, FALSE, TRUE, TRUE) sort(logi_vec) rank(logi_vec) order(logi_vec) 2.4.4 Exercises Write R codes to solve the following problems. Create a numeric vector named exe with values 2, 0, -3, 0, 5, 6 and sort exe from the largest to the smallest. In exe, what’s the ranks of 2 and the first 0? For exe, get indices for the elements in the ascending order. Create a character vector with values \"&amp;5\", \"Nd\", \"9iC\", \"3df\", \"df\", \"nd\", \"_5\", \"9ic\" and sort it in the ascending order. Then, explain 1) why 3df goes before 9ic; 2) why &amp;5 goes before 3df; 3) why 9ic goes before 9iC. "],["vector-functions.html", "2.5 Statistical Functions on Vectors", " 2.5 Statistical Functions on Vectors In this section, we will continue talking about functions on vectors, and focus on various statistical functions. 2.5.1 Numeric vectors Let’s first create a numeric vector. h &lt;- c(3, 2, 75, 0, 100) h #check the value of h Next, we will divide statistical functions into several groups, and introduce them one by one. Group A: minimum and maximum min(h) max(h) range(h) First, you can get the minimum and maximum values of a numeric vector, and range() produces a length-2 vector with both the minimum value(the first element) and maximum value(the second element). which.min(h) which.max(h) In addition to getting the minimum and the maximum values, it is often useful to get the corresponding locations of them. Here, the fourth element in h has the minimum value 0, so you will get a result of 4 from which.min(). If there are multiple elements with the minimum value, which.min() will return the first location. Similarly, which.max() tells you the location of the maximum value. g &lt;- c(2, 2, 1, 1) which.min(g) which.max(g) The third element and the fourth element in g both have the minimum value, but which.min(g) has a value of 3 since the third element is the first location with the minimum value. Similarly, which.max() gives you a result of 1. cummin(h) cummax(h) In addition to calculating the minimum value of all elements, you can also use the cumulative minimum function, called cummin(). It returns a vector of the same length as the input vector, with the value at each location being the minimum of all preceding elements until that location in the original vector. For example, the first element of cummin(h) is 3 since the minimum of the first element in the original vector is always itself, the second element is 2 since the minimum of the first two elements (3 and 2) in his 2, and so on. Note that once we reach the minimum value of the vector, the remaining elements of the cumulative minimum function will always equal to the minimum value. There is also a corresponding function for computing the cumulative maximums, called cummax(). Group B: sum and product sum(h) cumsum(h) Next, let’s look at the sum() function, which produces the sum of all elements in the vector. For the numeric vector h, the sum is 3+2+75+0+100, which is 180. Similar to cummin(), you can use the cumsum() function to compute the cumulative sums, which works by summing up the elements of the original vector cumulatively up to each location. In cumsum(h), the first element is 3 since there is only one element to do summation, the second element is 5 since the summation of the first two elements (3 and 2) in h is 5, and you can easily verify the value of the remaining elements by yourself. prod(h) cumprod(h) We also have the prod() function, computing the product of all elements of h. Since there is 0 in h, the result is 0. Again, we have the cumulative product function cumprod() working by multiplying the elements of the original vector cumulatively up to each location. Group C: mean and median sort(h) #&gt; [1] 0 2 3 75 100 Before introducing this group, let’s first review the sort() function introduced in Section 2.4. By default, this function can sort elements from the smallest to the largest. mean(h) median(h) The mean() function returns the average of all elements. And the median() function returns the middle number in the resulting vector of sort() where the elements are listed in order from the smallest to the largest. If the vector length is odd, the middle number is the value of the element in the central location. In sort(h), we can see that the median corresponds to the third number out of five numbers since there are two numbers larger than 3 and two numbers smaller than 3. If the vector length is even, the middle number is the average of the two middle elements after sorting. sort(g) median(g) Take g for example, after sorting, you will see that 1 and 2 are in the middle. The median is then defined as the average of these two elements, equaling 1.5. Group D: quantiles quantile(h) #&gt; 0% 25% 50% 75% 100% #&gt; 0 2 3 75 100 quantile() produces sample quantiles of a given numeric vector. By default, it generates 5 numbers, the top row represents the different percentiles, including the 0 percentile, 25th percentile (0.25 quantile), 50th percentile (0.5 quantile), 75th percentile (0.75 quantile), and 100th percentile, and the second row consists of the corresponding values of each quantile. We next go over all five quantile values. First of all, 0 percentile and 100th percentile are always the minimum and the maximum values, respectively. The 50th percentile (0.5 quantile) is the same as the median. The 25-th percentile (0.25 quantile), also called the first quartile, is the value such that there are 25 percent (or a quarter) of the remaining data (whole data without this number) smaller than it. For vector h, the value is 2 since there is exactly 1 number, which is 25 percent of the remaining 4 numbers, smaller than 2. Similarly, the 75-th percentile, also called the third quartile, is the value such that 75 percent of the remaining data is smaller than this number. For vector h, the value is 75 since there are 3 numbers, which are 75 percent of the remaining 4 numbers, smaller than 75. You also have an important concept called interquartile range (IQR), defined as the difference between the 3rd quartile (75-th percentile) and the 1st quartile (25-th percentile). The interquartile range of h is 73, which is 75 - 2. IQR(h) In addition to the default five percentiles, you can also use the quantile() function to get any quantile between 0 and 1. To do this, you just need to specify the second argument probs. Let’s try to find the 95th quantile. quantile(h, probs = 0.95) As before, this asks you to compute the 95th percentile, meaning 95 percent of the remaining data is smaller than this value. Because you only have 5 values in this vector, it may not be very intuitive. However, if you have more elements in a vector, say 1001, you can count the number of the remaining data that is smaller than this value, which should be 950 (the number of remaining data is 1000, and 95 percent of 1000 is 950). In addition, the second argument can be a vector of probabilities, which will produce a numeric vector of the corresponding quantiles. quantile(h, probs = c(0.1, 0.2, 0.99)) Group E: summary statistics summary(h) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 0 2 3 36 75 100 Compared with quantile(), a more general function to have a comprehensive understanding of numeric vectors is summary(). From summary(), you can get the 5 percentiles and the mean. (Min: 0 percentile, 1st Qu: 25-th percentile, Median: 50-th percentile, 3rd Qu: 75-th percentile, Max: 100-th percentile) Group F: variance and standard deviation var(h) sd(h) The last group of functions are var() and sd() which compute the sample variance and sample standard deviation of a numeric vector, respectively. The formula of sample variance of vector \\(h\\) is \\[var(h) = \\frac{1}{n-1}\\sum_{i=1}^n (h_i-\\bar h)^2,\\] where \\(n\\) is the length of \\(h\\) and \\(\\bar h\\) is the average of all elements. By definition, the sample standard deviation is the square root of sample variance, which you can verify by sqrt(var(h)). For your convenience, we would like to provide a summary of all the functions introduced in the following table. Operation Explanation min(h) the minimum value max(h) the maximum value range(h) both the minimum value and the maximum value which.min(h) the (first) location of the minimum value which.max(h) the (first) location of the maximum value cummin(h) the cumulative minimum values cummax(h) the cumulative maximum values sum(h) the sum of all elements cumsum(h) the cumulative sum prod(h) the product of all elements cumprod(h) the cumulative products mean(h) the average of all elements median(h) the middle number in sort(h) quantile(h) the 0 percentile, 25-th percentile, 50-th percentile, 75-th percentile, and 100-th percentile IQR(h) the difference between the 3rd quartile and the 1st quartile quantile(h, probs = 0.95) the 95-th percentile quantile(h, probs = c(0.1, 0.2, 0.99)) several quantiles at a time summary(h) 5 percentiles and the mean var(h) the sample variance sd(h) the sample standard deviation 2.5.2 Character vectors Compared with numeric vectors, there are much less things you can do on character vectors. For character vectors, you can also apply summary(). animals &lt;- rep(c(&quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;), 3:1) summary(animals) From the result, you can see that the summary() function will only tell you the vector length (6 elements) and vector type (character vector), much less useful than the case for numeric vectors. 2.5.3 Logical vectors What if we apply summary() on logical vectors? logic &lt;- rep(c(T,F,T), 3:1) summary(logic) Similar to character vectors, you can get the vector type, which is logical here. You also get a frequency table for the times FALSE and TRUE appear in the vector. Different from character vectors, you can apply almost all the functions summarized in Table ?? to logical vectors, where the coercion rule introduced in Section 2.2.3 will be in effect to convert all logical values into numerical values. In particular, in the logical vector, TRUE will be converted to 1 and FALSE will be converted to 0. Let’s take a look at an example, a &lt;- c(TRUE, TRUE, FALSE, FALSE, TRUE) sum(a) mean(a) Clearly, sum(a) equals 3 since there are 3 TRUE values and mean(a) equals 0.6 since it is the average of three 1s and two 0s. You are welcome to try other functions on a logical vector. 2.5.4 Exercises Suppose x &lt;- c(5, 2, 4, 1, 2, 1), y &lt;- c(T, F, F, F, F, T, T, F, F, T) Write R code to reproduce each element of the summary vector summary(x) Write R code to generate the cumulative sum, cumulative product, cumulative minimum, and cumulative maximum of x. Write R code to generate a vector consisting of the 0.1, 0.2, 0.6, 0.8, 0.9 quantiles of x. Write R code to calculate the sample variance and sample standard deviation of x. Write R code to generate a length-2 vector consisting of the sum and mean of y. Then show the unique elements of y and their corresponding frequencies. "],["comparison-vector-subsetting.html", "2.6 Comparisons, Vector Subsetting &amp; Change Values", " 2.6 Comparisons, Vector Subsetting &amp; Change Values By now, you are more than familiar with the simplest type of R objects—vector, and you can create vectors and apply many useful functions on vectors. Sometimes you may be wondering how to extract certain elements from a vector? In this section, we will introduce some new operations on vectors that can help you get the desired subvector. 2.6.1 Comparisons on vectors of the same type The first type of operations we want to introduce is making comparisons between two vectors of the same type. Similar to the arithmetic operations between two numeric vectors in Section 2.1, we normally want to compare two vectors of the same length, but we can also compare two vectors of different lengths according to the recycling rule in R. a. Compare two vectors of the same length If two vectors are of the same length, the comparison is done elementwisely, just like the arithmetic operations in Section 2.1. Let’s take numeric vectors for example. You can create a numeric vector x with value 3, and compare it to another numeric vector 2 to find out whether the value of x is smaller than 2 or not. x &lt;- 3 x &lt; 2 #&gt; [1] FALSE Since 3 is bigger than 2, you will certainly get FALSE! In addition to the less than sign &lt;, there are a few other commonly useful operators for doing comparisons. x &lt; 2 #less x &lt;= 2 #less or equal to x &gt; 1 #bigger x &gt;= 1 #bigger or equal to x == 3 #equal to #x = 3 #assignment operator x != 3 #not equal to Note that if you want to check whether two vectors are equal, you have to use two equal signs as a single operator, which is ==, to do comparisons. If only one equal sign is used, it would work like an assignment operator. In addition, you can use an exclamation mark together with a equal sign, which is !=, to find out whether two vectors are not equal. Note that as we explained in Section 1.3.2, sometimes you need to execute an R expression because you can get its object type and value from the result. Here, you may notice that you get TRUE or FALSE as the result from the codes above. Since TRUE and FALSE are logical values (there are no pairs of double quotes around TRUE’s and FALSE’s when you use them as logical values), you know that all comparison operations generate logical vectors. Of course, you can assign the result to a name for future use. Let’s take x &gt; 1 for example. class(x &gt; 1) length(x &gt; 1) big1 &lt;- x &gt; 1 big1 class(big1) So x &gt; 1 and big1 are both logical vectors with length one. Also, you can create two length&gt;1 numeric vectors y and z with the same length, then do comparisons between them. y &lt;- c(3,5,7,5,3) z &lt;- c(2,6,7,6,3) y &gt; z #&gt; [1] TRUE FALSE FALSE FALSE FALSE From the result, you can see that y &gt; z is a length-5 logical vector. The values of y &gt; z are obtained by making elementwise comparisons between the corresponding elements in these two vectors. big2 &lt;- y &gt; z big2 class(big2) which(big2) By assigning y &gt; z to a big2, you create another logical vector. Here, the which() function returns the locations of all TRUE values, so you will get a result of 1 for big2. You can also compare two character vectors, which works by comparing the corresponding strings in the same location. The rule for comparison is the alphabetically order explained in Section 2.4.2. Similar to comparing numerical vectors, we also use two equal signs == to check whether the corresponding elements in the two input vectors have the same value. Let’s first create two character vectors with the same length, then use == to compare them. Since the expression of this comparison is again a logical vector, you can create a new logical vector same1 and get the locations of TRUE values. You can also use other comparison operators. animals &lt;- c(&quot;pig&quot;, &quot;monkey&quot;, &quot;pig&quot;) zoo &lt;- c(&quot;sheep&quot;, &quot;monkey&quot;, &quot;pig&quot;) same1 &lt;- animals == zoo which(same1) which(animals != zoo) Comparisons between logical vectors work similarly as character vectors, where we usually use == or != to compare corresponding elements in logical vectors. Here are some examples. logi1 &lt;- c(TRUE, FALSE, FALSE) logi2 &lt;- c(TRUE, TRUE, TRUE) same2 &lt;- logi1 == logi2 which(same2) which(logi1 != logi2) b. Compare between one vector with length &gt; 1 and another vector with length 1 The recycling rule also works for the comparison operations in R. With an vector of length 1, you can compare the value of it to the values of another vector with more than one elements one by one, which generates a logical vector. The length of the logical vector will be the same as that of the longer vector. Here are some examples. y != x animals == &quot;pig&quot; logi1 == TRUE 2.6.2 Comparisons on vectors of different types When you try to compare two vectors of different types, the coercion rule in Section 2.2.3 will apply. In particular, values of corresponding elements will be unified into the more complex one when making comparisons between two vectors. The order of complexity from simple to complex is still \\(\\mbox{logical} &lt; \\mbox{integer} &lt; \\mbox{double} &lt; \\mbox{character}\\). Let’s try to compare between a numeric vector and a logical vector, a &lt;- c(-1, 0, 1) b &lt;- c(TRUE, FALSE, TRUE) a == b #&gt; [1] FALSE TRUE TRUE Then you will get a length-3 logical vector. In a == b, the first element is obtained by using == to compare -1 and TRUE, then R will convert TRUE to 1 and make comparison between -1 and 1 since numbers are more complex than logical values. The second and third elements are also obtained in a similar fashion. This is the most common use of comparisons between vectors of different types. You can make comparisons between vectors of other types, the following example shows that the classic transitive property in math (\\(a=b\\) and \\(b=c\\) imply \\(a=c\\)) doesn’t hold in R. 1 == TRUE #&gt; [1] TRUE TRUE == &quot;TRUE&quot; #&gt; [1] TRUE 1 == &quot;TRUE&quot; #&gt; [1] FALSE 2.6.3 Vector subsetting Sometimes you may want to extract particular elements from a vector, then the extracted elements will constitute a new vector, which is a subvector of the original vector. This process is called vector subsetting, and the subvector will be of the same type as the original one. In this part, we will introduce two common ways to do vector subsetting in R. Before we get started, let’s create a vector which will be used throughout this part. h &lt;- c(3,1,4,2,90) a. Use logical vectors to do vector subsetting Firstly, we introduce how to use logical vectors to do vector subsettings. You need to use a pair of square brackets [ ] after a vector, then put a logical vector of the same length as the original vector inside the square brackets. Here is an example, h[c(TRUE, FALSE, TRUE, FALSE, TRUE)] #&gt; [1] 3 4 90 From the result, you can see that the values from h with the same positions of TRUEs are extracted. Since 3, 4 and 90 are parts of the values of h, the vector composed of 3 4 90 is a subvector of h. When assigning these three values to a name, you will get a named subvector sub1. sub1 &lt;- h[c(TRUE, FALSE, TRUE, FALSE, TRUE)] sub1 #&gt; [1] 3 4 90 In addition to writing the logical vector in an explicit form, you can also use a named logical vector or an expression whose result is a logical vector. Let’s say we want to find the subvector of h for all elements in h that are larger than 2. Then, you can first compare h with 2, getting a logical vector. big3 &lt;- h &gt; 2 big3 #&gt; [1] TRUE FALSE TRUE FALSE TRUE Then you may notice that both big3 and h &gt; 2 are identical to c(TRUE, FALSE, TRUE, FALSE, TRUE). So naturally you can also put big3 or h &gt; 2 into [ ], which generates the same subvector with 3 4 90 as values. h[c(TRUE, FALSE, TRUE, FALSE, TRUE)] h[big3] h[h &gt; 2] If you create a character vector home and compare it to \"pig\", you will get another logical vector same3. Let’s try to use same3 to do vector subsetting on h. home &lt;- c(&quot;pig&quot;, &quot;monkey&quot;, &quot;pig&quot;, &quot;monkey&quot;, &quot;pig&quot;) same3 &lt;- home == &quot;pig&quot; sub2 &lt;- h[same3] sub2 #&gt; [1] 3 4 90 Awesome! You still get the result of 3 4 90! As a result, as long as the logical vectors you use have the same values, you will get the same result after doing vector subsetting. Of course, you can do vector subsetting on character vectors or logical vectors. Keep in mind that the result will be the same type as the original one. Try the following code by yourself. home[same3] home[big3] lg &lt;- c(TRUE, FALSE, FALSE, FALSE, TRUE) lg[same3] lg[big3] b. Use indices to do vector subsetting Next, we will introduce how to use indices to do vector subsetting. To achieve this goal, you need to put a numeric vector inside [ ], for example, h[c(2,4)] #return values of the 2nd and 4th elements of h #&gt; [1] 1 2 You get values of the 2nd and 4th elements in h. If you add a minus sign - before the numeric vector, you will get all elements except the 2nd and 4th ones in h. h[-c(2,4)] #return values except the 2nd and 4th elements of h #&gt; [1] 3 4 90 Similar to using a named logical vectors, you can also use a named numeric vector to do vector subsetting. indices &lt;- c(2,4) sub3 &lt;- h[indices] sub3 Also, you can get subvectors of character vectors or logical vectors using indices. home[indices] lg[indices] In conclusion, there are two ways to get a subvector of h with values bigger than 2. h &lt;- c(3,1,4,2,90) h[h &gt; 2] #h &gt; 2 will return TRUE if the element in h has value bigger than 2 h[c(1,3,5)] #It&#39;s clear to see that the first, third and fifth elements have values bigger than 2 c. using names to do vector subsetting For a named vector, we can also use character vector consisting of the names as indices to do vector subsetting. x_w_name &lt;- c(height = 165, weight = 60, BMI = 22) x_w_name[&quot;height&quot;] #&gt; height #&gt; 165 x_w_name[c(&quot;weight&quot;, &quot;BMI&quot;)] #&gt; weight BMI #&gt; 60 22 2.6.4 Update values in sub-vectors In Section 2.1.1, we have learned how to update one element in a vector using the assignment operator. For example, x[ind] &lt;- new_value will update the ind-th element of x to the new_value. It turns out we can update the values of multiple elements of a vector in a similarly way. a. Change all values in subsets of vectors Firstly, let’s review values of vector h and get a subset of it. h &lt;- c(3,1,4,2,90) h[c(2,4)] Obviously, you will get a numeric vector with 1 and 2 as the values. Let’s see how to change values just for a subset of h, which is actually a very important usage of doing vector subsetting. You just need to assign new values to the subset, then you can verify the values of h. Let’s see an example, h[c(2,4)] &lt;- c(10, 20) h #&gt; [1] 3 10 4 20 90 h[c(2,4)] &lt;- 10 #recycling rule applies h #&gt; [1] 3 10 4 10 90 From the result, you can see that only 1 and 2 have been changed to 10, which means you have successfully change parts of h! b. Define the vector again Another way to change values in vectors is to do object assignment again using the same name, then you can change any values of it. Let’s first reset the values of h. h &lt;- c(3,1,4,2,90) In Section 1.3, you have learned about checking all the named objects and their values in the environment. So let’s review values of vector h from this panel together. Figure 2.3: Values of h (1) Now we all know that h is a numeric vector with 5 values. Then let’s try to do an object assignment again, this time you can assign different values to h and see what will happen to h. h &lt;- c(1,2,3,4,5) h #&gt; [1] 1 2 3 4 5 Then you can see that the values of h have been changed to the new ones! Another easier way to verify values of h is from the environment, so it is a good habit to monitor the environment from time to time to make sure everything look fine. Figure 2.4: Values of h (2) You can assign any values to h as you want, then h may change the vector type or even the object type according to the values assigned. By running the following code, h will be a character vector with three strings. h &lt;- c(&quot;pig&quot;, &quot;monkey&quot;, &quot;panda&quot;) Figure 2.5: Values of h (3) If you assign values of a subvector to a name, you will create a new named vector. Now hs is not the subset of h, it is a vector with the same value as the subset. If you assign different value(s) to hs, there will be no change on h. h &lt;- c(3,1,4,2,90) hs &lt;- h[c(2,4)] hs &lt;- 10 h 2.6.5 Exercises Consider the vector v1 &lt;- c(7, 2, 4, 9, 7), v2 &lt;- c(6, 2, 8, 7, 9), and v3 &lt;- 1:50. Find the locations in v1 where the corresponding value is smaller than v2. Find the subvector of v2 such that the corresponding location in v1 is larger than 5. Find the subvector of v3 such that it is divisible by 7. (Hint: the result of 7%%7 is equal to 0 since 7 is divisible by 7) For all elements of v3 that is divisible by 8, replace it by 100. "],["logical-operators.html", "2.7 Logical Operators", " 2.7 Logical Operators In last section, you learned how to do vector subsetting, which yields a subvector of the original vector. Let’s take a numeric vector x &lt;- 1:5 for example. In order to get a subvector of x with values bigger than 3, you can first create a logical vector xb3 &lt;- x &gt; 3, then use the xb3 as the index to do vector subsetting. x &lt;- 1:5 xb3 &lt;- x &gt; 3 set1 &lt;- x[xb3] set1 #&gt; [1] 4 5 Here, the numeric vector set1 has values 4 5. You can get another subvector of x by running the following codes. xs4 &lt;- x &lt;= 4 set2 &lt;- x[xs4] Sometimes, you may want to get a subvector with more than one conditions. For example, how can we find the subvector of x with values larger than 3 and less than or equal to 4? In this section, we will introduce several logical operators and use them to get subvectors. Here, we only introduce how to apply these operators on logical vectors. Before we get started, let’s create another numeric vector y and compare it to 8 and 9 separately, then you will get two logical vectors with same values as xb3 and xs4. y &lt;- 6:10 yb8 &lt;- y &gt; 8 #xb3 is the same as yb8 ys9 &lt;- y &lt;= 9 #xs4 is the same as ys9 2.7.1 NOT operator by ! The first operator we want to introduce is !, often called the NOT operator. Let’s see what happens if you apply the NOT operator on a logical vector, !c(FALSE, FALSE, FALSE, TRUE, TRUE) #the opposite of a logical vector #&gt; [1] TRUE TRUE TRUE FALSE FALSE From the result, you get another logical vector with the same length as the original one. The value of each element in the new vector is the opposite of the corresponding value in the original vector. It is intuitive to understand since if something is NOT FALSE, then it is TRUE; and if it is NOT TRUE, then it has to be FALSE. Since xb3 is also a logical vector, you can try to apply ! on xb3, and use !xb3 (which is also a logical vector) to do vector subsetting. Guess what will you get? !xb3 #&gt; [1] TRUE TRUE TRUE FALSE FALSE set3 &lt;- x[!xb3] set3 #&gt; [1] 1 2 3 Of course the resulting numeric vector set3 will have 1 2 3 as values! As a result, set1 and set3 are complement of each other from the whole vector x. From Section 2.6, you have learned that if the logical vectors you use are identical, you will get the same result after doing vector subsetting. So if you use !yb8 to do vector subsetting, you will get a vector with the same result as that when you use set3. x[!yb8] #&gt; [1] 1 2 3 2.7.2 AND operator by &amp; Secondly, we will introduce the AND operator &amp;. Similar to making comparisons between two logical vectors, &amp; performs comparisons elementwisely, which generates a vector with the same length if the input logical vectors are of the same length or with the same length as that of the longer vector. For each location of the resulting vector, the value will be TRUE if both values in the same location of the input two vectors are both TRUE, and will be FALSE otherwise. In particular, for each element, we have the following summary. Operation Result TRUE &amp; TRUE TRUE TRUE &amp; FALSE FALSE FALSE &amp; TRUE FALSE FALSE &amp; FALSE FALSE Let’s see an example of the AND operation between two logical vectors of the same length. c(FALSE, FALSE, FALSE, TRUE, TRUE) &amp; c(TRUE, TRUE, FALSE, TRUE, FALSE) #&gt; [1] FALSE FALSE FALSE TRUE FALSE As explained before, the AND operator works elementwisely and the intermediate step is as below. c(FALSE &amp; TRUE, FALSE &amp; TRUE, FALSE &amp; FALSE, TRUE &amp; TRUE, TRUE &amp; FALSE) #&gt; [1] FALSE FALSE FALSE TRUE FALSE As you can see from the result, only the fourth element is TRUE since the fourth element of both input logical vectors is TRUE. Since the AND operator makes comparisons elementwisely, the recycling rule also works here. But normally we want one vector with length &gt; 1 and another one with length 1. c(FALSE, FALSE, FALSE, TRUE, TRUE) &amp; FALSE #&gt; [1] FALSE FALSE FALSE FALSE FALSE After learning about the AND operator, you can now get a subvector of x with value(s) &gt; 3 and &lt;= 4 easily. At the beginning of this section, you have created two logical vectors xb3 and xs4 by making comparisons, then let’s apply &amp; on these vectors, xb3 &amp; xs4 #&gt; [1] FALSE FALSE FALSE TRUE FALSE From the result, you know that both xb3 and xs4 have value TRUE for the fourth element, which means the statement that the value is &gt; 3 and &lt;= 4 is TRUE for the fourth element in x. Then you can use xb3 &amp; xs4 (a logical vector) to do vector subsetting. x[xb3 &amp; xs4] #&gt; [1] 4 Here, you get a subvector of x with value 4. Since xs4 and ys9 have same values, you will get the same result if you include ys9 to get a subvector. You can try the following codes by yourself. x[xb3 &amp; ys9] x[yb8 &amp; ys9] Note that the logical vector used to do vector subsetting needs to be of the same length as the original vector. Since x and y have the same length, the logical vectors from above can be used to get subvectors of y as well. You will get the same result from the following four codes. y[xb3 &amp; xs4] y[yb8 &amp; ys9] y[xb3 &amp; ys9] y[yb8 &amp; xs4] 2.7.3 OR operator by | The OR operator | works similarly to the AND operator &amp;, but the difference is that | returns TRUE if there is at least one TRUE among the two elements at the same location in two vectors. Let’s go through some examples together. Operation Result TRUE | TRUE TRUE TRUE | FALSE TRUE FALSE | TRUE TRUE FALSE | FALSE FALSE Let’s try another example on length &gt; 1 vectors and compare the result with that when we use the AND operator &amp;. c(FALSE, FALSE, FALSE, TRUE, TRUE) | c(TRUE, TRUE, FALSE, TRUE, FALSE) #&gt; [1] TRUE TRUE FALSE TRUE TRUE c(FALSE, FALSE, FALSE, TRUE, TRUE) &amp; c(TRUE, TRUE, FALSE, TRUE, FALSE) #&gt; [1] FALSE FALSE FALSE TRUE FALSE You also get a length-5 logical vector with an elementwise OR operation |, which is very different from the result with AND operation &amp;. Of course you can also use xb3 | xs4 to do vector subsetting, with it being another length-5 logical vector. x[xb3 | xs4] #&gt; [1] 1 2 3 4 5 Wow! You get all five elements of x! That’s because the statement “the value is either &gt; 3 or &lt;= 4” is TRUE for all elements in x. 2.7.4 Exclusive OR by xor Last but not least, we introduce the exclusive OR operator xor. From the name, it’s easy to know that xor is an extended form of |. Here are some examples, Operation Result xor(TRUE, TRUE) FALSE xor(TRUE, FALSE) TRUE xor(FALSE, TRUE) TRUE xor(FALSE, FALSE) FALSE Different from the OR operator, xor() returns TRUE when there is one and only one TRUE among values of these two logical vectors. If these two vectors have the same value, both TRUE or both FALSE, you will get the value FALSE. For two length &gt; 1 vectors, xor() again performs comparisons elementwisely. You can check the result by yourself! xor(c(FALSE, FALSE, FALSE, TRUE, TRUE), c(TRUE, TRUE, TRUE, TRUE, FALSE)) #&gt; [1] TRUE TRUE TRUE FALSE TRUE Since you also get a logical vector after applying xor(), you can use it to do vector subsetting. Using different combinations to do vector subsetting is interesting. Try them! x[xor(xb3, xs4)] y[xor(!xb3, ys9)] y[xor(yb8, !ys9)] 2.7.5 Summary of Logical Operators Let’s summarize the logical operators between two vectors. The NOT operator ! gives the opposite of each value. The AND operator &amp; returns TRUE if both are TRUE. The OR operator | returns TRUE if at least one is TRUE. The exclusive OR operator xor() returns TRUE if one and only one is TRUE. 2.7.6 Exercises Consider the vector v1 &lt;- seq(from = 1, to = 100, by = 3), and v2 &lt;- sqrt(v1). Find the subvector of v1 with values bigger or equal to 30 and less than 60. And assign the subvector to name v1s. Find the subvector of v2 such that the corresponding value of v1 is less than 20 or larger than 50. Use an example to verify \\(xor(a, b) = (!a &amp; b) | (a &amp; !b)\\) "],["set-operations-between-two-vectors.html", "2.8 Set Operations between two vectors", " 2.8 Set Operations between two vectors In Section 2.7, we introduced logical operators which are operators between two logical vectors. In this section, we will discuss set operations between two vectors of the same type. Note that while the logical operators only make sense for logical vectors, the operations we will introduce work for all three kinds of vectors. In the rest of this section, we will introduce several operations one by one. 2.8.1 Numeric vectors Let’s start with numeric vectors. Firstly, let’s create two numeric vectors x and y. x &lt;- c(1, 2, 1, 3, 1) y &lt;- c(1, 1, 3, 4, 4, 5) a. Intersection To get values in both x and y, you can use the intersect() function. intersect(x, y) #&gt; [1] 1 3 Note that although x has three elements of 1 and y has two, the result of their intersection only has one 1, showing that only the unique elements are retained in the output. b. Union To get values in either x or y, you can use the union() function. union(x, y) #&gt; [1] 1 2 3 4 5 Again, only one copy of each value is retained in the output. c. Set difference To get values in x but not in y, you can use the setdiff() function. Notice that x is in the first argument and y is in the second in this situation. setdiff(x, y) #&gt; [1] 2 Then you will get the result of 2! But you may be wondering why you don’t get 1 2 as the result since there is one more 1 in x than in y? That’s because for this operation, you will get unique elements of x and y firstly, then find the set difference between them. Similarly, if you want to get values in y but not in x, y should be in the first argument and x is in the second. setdiff(y, x) #&gt; [1] 4 5 d. Set equality To check whether the two vectors x and y are the same, you can use the setequal() function. setequal(x, y) #&gt; [1] FALSE Of course you will get FALSE since x has value 2 which y doesn’t have. Similar to the setdiff() function, the setequal() function works by looking at whether the two vectors have same set of unique values. For example, you will get TRUE in the following example, setequal(c(1, 1, 2), c(1, 2)) #&gt; [1] TRUE e. Membership determination To check whether each element of x is inside y, you can use the is.element() function or the %in% operator. is.element(x, y) #&gt; [1] TRUE FALSE TRUE TRUE TRUE x %in% y #&gt; [1] TRUE FALSE TRUE TRUE TRUE In this example, it returns a logical vector of length-5, the same length as x. The first element of x is 1, and y also has elements with value 1, so the first element of the logical vector is TRUE. The second element of x is 2, but y doesn’t have any elements with value 2, hence the result is FALSE. You can verify the other elements by yourself. The order of vectors is important for membership determination since if you put y before x, you will check whether each element of y is inside x. is.element(y, x) #&gt; [1] TRUE TRUE TRUE FALSE FALSE FALSE y %in% x #&gt; [1] TRUE TRUE TRUE FALSE FALSE FALSE Please find a summary of the set operations between x and y in the following table. Operation Code Intersection intersect(x, y) Union union(x, y) Set Difference setdiff(x, y) Set Equality setequal(x, y) Membership Determination is.element(x, y) 2.8.2 Character vectors Now you must have been familiar with all the five operations! Similar to numeric vectors, you can also apply operations on character vectors. Here are some codes which you can run by yourself. a &lt;- c(&quot;sheep&quot;, &quot;monkey&quot;, &quot;sheep&quot;, &quot;chicken&quot;, &quot;dragon&quot;) b &lt;- c(&quot;sheep&quot;, &quot;pig&quot;, &quot;pig&quot;) intersect(a, b) union(a, b) setdiff(a, b) setequal(a, b) a %in% b 2.8.3 Logical vectors Of course you can also apply set operations on logical vectors. c &lt;- c(&quot;T&quot;, &quot;F&quot;, &quot;F&quot;, &quot;T&quot;) d &lt;- c(&quot;T&quot;, &quot;T&quot;, &quot;T&quot;) intersect(c, d) union(c, d) setdiff(c, d) setequal(c, d) c %in% d 2.8.4 Exercises Consider the vector s1 &lt;- seq(from = 1, to = 100, length.out = 7). Compare s1 to 50 to see whether the values of s1 are bigger than 50, then assign the result to name s2. Compare s1 to 80 to see whether the values of s1 are less or equal to 80, then assign the result to name s3. Use two methods (logical operators and set operations) to find the subvector of s1 with values bigger than 50 and less or equal to 80. For x &lt;- 1:200, use two methods (logical operators and set operations) to find the subvector of x that is divisible by 7, but not divisible by 2. "],["summary-of-operators.html", "2.9 Summary of Operators", " 2.9 Summary of Operators Now we have fully introduced the first object—-vectors. You have learned how to create vectors and apply various operations on them. There are several different types of operators to conduct different operations in R. In this section, we want to give you a brief review of some operators and operations according to their types. Let’s summarize the four types of operators we have learned. In the following parts, we will review each type one by one. Operator Section arithmetic operator 1.2 assignment operator 1.3 relational operator 2.6 logical operator 2.7 2.9.1 Arithmetic operator Arithmetic operators (Section 1.2) are operators that often used to some basic calculations. The following is a list of operators available in R. Operator Explanation + addition - subtraction * multiplication / division %/% integer division %% modulus ^ exponentiation 2.9.2 Assignment operator The assignment operator (Section 1.3) is the perhaps the most fundamental operator. It can help you to create objects with names. Operator Explanation &lt;- do object assignment 2.9.3 Relational operator Relational operators are operators that are often used to do comparisons. The following is a list of operators available in R. Operator Explanation &lt; less &lt;= less than or equal to &gt; bigger &gt;= bigger than or equal to == equal to != not equal to 2.9.4 Logical operator Logical operators are often used between two logical vectors when we want to do a particular vector subsetting. The following is a list of logical operators available in R. Operator Explanation ! NOT &amp; AND | OR xor() Exculsive OR In addition to using various operators to conduct operations, we can do much more using various functions in R. "],["na.html", "2.10 Missing Values (NA)", " 2.10 Missing Values (NA) In applications, you may encounter the situation where some values are missing in the data set. In this scenario, R uses NA to represent those values, indicating they are not available. Let’s see the following example. a &lt;- 1:10 a[11] #&gt; [1] NA Since you have defined a as a vector of length 10, there are 10 values in a. If you try to access the 11th element of a, it is not available, hence you will see NA as the result. Sometimes, the values of some elements in a vector are missing, then you can use NA for these elements. Here is an example containing NAs in values. If you want to get values of the 2nd and 4th elements in b, of course you will get NA NA as the result. b &lt;- c(1, NA, 2, NA, 3) b #&gt; [1] 1 NA 2 NA 3 b[c(2,4)] #&gt; [1] NA NA Now you have had a basic understanding of NA. In the following parts of this section, we want to introduce several properties of NA. Let’s start with NA is contagious. 2.10.1 NA is contagious NA implies that the underlying value is not available, in other words, there is uncertainty with the value. As a result, for most operations associated with NA, the results will also be NA, showing that NA is contagious. y &lt;- NA y + 3 #&gt; [1] NA y == 3 #&gt; [1] NA As you can see here, y is NA, indicating the value of y is not available. When you try to do operations like y + 3 or y == 3, the answers are clearly not available as well, hence both taking the value NA. How about we create another NA object and compare it with y? z &lt;- NA y == z #&gt; [1] NA It is again NA, which may be confusing at first. However, keep in mind that since both y and z are not available, there is no way to tell whether they are the same. Hence y == z is also NA. Think about what is the value of 1NA in R. Try to run it in R. Does it agree with your thoughts? Think about what is the value of 0NA in R. Try to run it in R. Does it agree with your thoughts? Answer 1. For any \\(x\\), we have \\(1^x = \\exp(\\log (1^x)) = \\exp(x \\log 1) = \\exp(x \\cdot 0) = 1\\). Since there is no uncertainty regarding the expression, the value of 1NA is 1 Answer 2. We have \\(0^0 = \\lim_{x\\to 0}x^x =\\exp[\\lim_{x\\to 0} x\\log(x)]=\\exp[0] = 1\\), and \\(0^1 = 0\\). Since NA represents uncertainty values, it can be 0 or 1 or other numbers. So 0NA is not deterministic because it can take different values according to the exponent. Hence, the value of 0NA is also NA. Now, let’s talk about what impact the NA values make when we apply statistical functions. Let’s create a vector containing NA values, and apply some functions on it. x &lt;- c(1, NA, 3, 4, NA, 2) x #&gt; [1] 1 NA 3 4 NA 2 sum(x) #&gt; [1] NA mean(x) #&gt; [1] NA sd(x) #&gt; [1] NA As you can see, for many statistical functions on vectors, as long as there exists at least one NA values in vectors, the results are often impossible to determine, hence resulting an NA value as well. As a result, you may want to ignore the NA values during the function evaluation. Fortunately, most statistical functions on vectors provide an optional argument na.rm, which takes a logical value, indicating whether to remove NA before applying the functions. Let’s see the following examples. sum(x, na.rm = TRUE) #&gt; [1] 10 mean(x, na.rm = TRUE) #&gt; [1] 2.5 sd(x, na.rm = TRUE) #&gt; [1] 1.290994 It is easy to verify that the results are what we expect to get if the NA values are removed. Feel free to try the following codes which apply the same functions on the subvector with the non-missing values. x_no_na &lt;- c(1, 3, 4, 2) sum(x_no_na) mean(x_no_na) sd(x_no_na) Interesting, the summary() function will deal with the NA values automatically by removing them before computing the five percentiles and the mean. In addition, the summary() function provides a column which shows the number of NAs in x. summary(x) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s #&gt; 1.00 1.75 2.50 2.50 3.25 4.00 2 2.10.2 Work with NA values When there are NA values in our vector, there is nothing to be afraid of as there are many useful tools we can use. Let’s use x &lt;- c(1, NA, 3, 4, NA, 2) throughout this part. a. Find indices with missing values Firstly, we will introduce how to find indices with missing values. To find the indices, you may be tempted to use the comparison operator introduced in Section 2.6. Let’s try to compare x with NA as the following code. x == NA You get a vector of all values equaling NA! This is actually not surprising for the following reason. Given that the NA you are comparing can take any unknown value, any comparison with it will result in an NA value due to the lack of information. Instead of using == for finding missing values, the correct way is to use the is.na() function, which returns a logical vector x_na representing whether the value of each element is missing or not. Then, you can use the which() function which can return the locations of all TRUE values to find the indices for the NA values. Here, the sum() function on the logical vector x_na returns the number of NA values in the vector, following the cocercion rule described in Section 2.5.3. x_na &lt;- is.na(x) #logical vector x_na #&gt; [1] FALSE TRUE FALSE FALSE TRUE FALSE which(x_na) #numeric vector #&gt; [1] 2 5 sum(x_na) #the number of NAs in x #&gt; [1] 2 sum(!x_na) #the number of non-NAs in x #&gt; [1] 4 If you only want to detect whether there is any NA values in the vector, you can use the anyNA() function. anyNA(c(NA, 1)) #&gt; [1] TRUE anyNA(1:3) #&gt; [1] FALSE b. Remove missing values Sometimes, you may want to simply remove the missing values. To do that, you can use a logical vector to do vector subsetting as introduced in Section 2.6.3. The specific logical vector you want to use is the opposite (!) of the logical vector that represents missing values. Then you will get a subvector of x which keeps all values except NA. x2 &lt;- x[!x_na] x2 #&gt; [1] 1 3 4 2 c. Impute missing values In many applications, naively removing the missing values before doing the analysis may lead to incorrect inference. Usually, it is useful to make the data complete by imputing the missing values. For example, you can use mean imputing or median imputing, which replaces the missing values with the mean or median of the non-missing values. x_impute &lt;- x mean(x, na.rm = TRUE) #&gt; [1] 2.5 x_impute[x_na] &lt;- mean(x, na.rm = TRUE) x_impute #&gt; [1] 1.0 2.5 3.0 4.0 2.5 2.0 x #&gt; [1] 1 NA 3 4 NA 2 If you want to compare the values of an object before and after some operations, you can create a new object with the same value as the original object (here, we create x_impute which has the same value as x), then make operations on x_impute without changing the value of x. In x_impute, values of the 2nd and 5th elements are replaced by 2.5, the average of the non-missing values of x. d. Replace non-standard missing values with NA in the vector Sometimes, the data we collected may not use NA to indicate missingness. For example, in the following vector x3, the value 999 represents the corresponding element is missing. x3 &lt;- c(4, 999, 1, 999, 3, 999, 999) It is highly recommended to convert the values into NA before carrying out any analysis. x3[x3 == 999] &lt;- NA x3 #&gt; [1] 4 NA 1 NA 3 NA NA Let’s see another example where both 999 and -999 represent the value is missing. You can convert all 999 and -999 into NA by using operations introduced in Section 2.8.1 x4 &lt;- c(4, 999, 1, -999, 3, -999, 999) ##999 and -999 are the values indicating missingness x4[x4 %in% c(999, -999)] &lt;- NA x4 #&gt; [1] 4 NA 1 NA 3 NA NA 2.10.3 Exercises For the vector x &lt;- rep(c(1, 2, NA), 3:5), verify each value of summary(x) by using other functions. find the indices with missing values; create a vector x_no_na containing the non-missing values in x; replace those missing values by the median of the non-missing values in x. For the vector y &lt;- rep(c(\"N\", 2, \"A\"), 5:3), the values of both \"N\" and \"A\" indicate missingness. Convert non-standard missing values to NA, then find the indices of y that correspond to missing values. "],["factor.html", "2.11 Character Vectors, Factors &amp; Ordered Factors", " 2.11 Character Vectors, Factors &amp; Ordered Factors Having learned character vectors in Section 2.1.2, we introduce a very important data type in this section, named factors. First, let’s create a character vector to be used in this section. animals &lt;- c(&quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;, &quot;sheep&quot;, &quot;sheep&quot;, &quot;pig&quot;) 2.11.1 Create a factor from a vector So, what exactly is a factor? It can be viewed as a special type of vector whose elements take on a fixed and known set of different values. You can create a factor from a vector using the factor() function. To understand the output of a factor, it is helpful to compare the results with the original vector animals. animals_fac &lt;- factor(animals) animals_fac #&gt; [1] sheep pig monkey sheep sheep pig #&gt; Levels: monkey pig sheep animals #&gt; [1] &quot;sheep&quot; &quot;pig&quot; &quot;monkey&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; First, note that the strings in the character vector all have quotation marks around the elements, while the corresponding factor doesn’t have them. Second, we see an additional row in the factor, starting with “Levels:” This shows the unique elements of animals ordered alphabetically. If you use the class() function on animals_fac, you will see it is indeed a factor. class(animals_fac) class(animals) To get a levels of a factor, you can use the function levels() on it. levels(animals_fac) #&gt; [1] &quot;monkey&quot; &quot;pig&quot; &quot;sheep&quot; To have deeper understanding on factors, it is helpful to check its internal storage type using typeof(). typeof(animals_fac) #&gt; [1] &quot;integer&quot; as.numeric(animals_fac) #&gt; [1] 3 2 1 3 3 2 Perhaps a bit surprisingly, a factor is stored as integers. The integers represent the corresponding locations of each element in the levels. For example, the first value of as.numeric(animals_fac) is 3, since the first element of animals_fac is \"sheep\", which is the third element in the levels. The particular storage mechanism for factors is very appealing in the sense that storing integers takes much less space than storing all the same levels repeatedly in the original character vector. As the same time, you can easily reproduce the original character vector using the integers and the factor levels using vector subsetting via indices. levels(animals_fac)[as.numeric(animals_fac)] #&gt; [1] &quot;sheep&quot; &quot;pig&quot; &quot;monkey&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; To show that factors indeed could take less memory than the corresponding character vectors when the levels are repeated many times, let’s see the following example where we use the object.size() function to check the estimate of memory used to store the corresponding object. many_animals &lt;- rep(c(&quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;), c(100,200,300)) many_animals_fac &lt;- factor(many_animals) object.size(many_animals) #&gt; 5016 bytes object.size(many_animals_fac) #&gt; 3032 bytes From this example, we can see that storing the information as a factor could offer substantial memory savings (about 40% in this example) compare to storing it as a character vector. Another advantage of factors over vectors is that it will detect any input that is outside of the levels. Let’s try to assign the string “Tiger” to the first element of both animals_fac and animals. animals_fac[1] &lt;- &quot;Tiger&quot; animals_fac #&gt; [1] &lt;NA&gt; pig monkey sheep sheep pig #&gt; Levels: monkey pig sheep animals[1] &lt;- &quot;Tiger&quot; animals #&gt; [1] &quot;Tiger&quot; &quot;pig&quot; &quot;monkey&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; Since \"Tiger\" is not inside the levels set, we see a warning in the assignment process and the value of the first element is changed to &lt;NA&gt;. When the same assignment is done on the vector animals, there is no warning and the first element of animals is changed to “Tigers” as instructed. This is an attractive feature of factors that can prevent input errors. In addition to creating factors from character vectors, you can also create them from numeric vectors as well as logical vectors. x &lt;- rep(3:1, 1:3) x_fac &lt;- factor(x) y &lt;- rep(c(T, F), c(5, 3)) y_fac &lt;- factor(y) It is worth noting that after we convert a numeric vector into a factor, the usual arithmetic operation can no longer be applied since the numbers become levels. x_fac[1] + 1 #&gt; Warning in Ops.factor(x_fac[1], 1): &#39;+&#39; not meaningful for factors #&gt; [1] NA The result is NA with a warning message. 2.11.2 Set the factor levels and labels As we have seen, the factor() function extracts the unique elements from a vector and sort them as its levels. To manually specify the levels and their order, you can set the levels argument. For example, if you only want \"sheep\" and \"pig\" in the level, you can use the following code. factor(animals_fac, levels = c(&quot;pig&quot;, &quot;sheep&quot;)) #&gt; [1] &lt;NA&gt; pig &lt;NA&gt; sheep sheep pig #&gt; Levels: pig sheep As you can see, the third element becomes NA, since it corresponding element \"monkey\" in the original vector is not in the set of levels. You can also create labels to represent each level of the factor by setting the labels argument in the factor() function. factor(animals_fac, levels = c(&quot;pig&quot;, &quot;sheep&quot;), labels = c(&quot;pretty_pig&quot;, &quot;smart_sheep&quot;)) #&gt; [1] &lt;NA&gt; pretty_pig &lt;NA&gt; smart_sheep smart_sheep pretty_pig #&gt; Levels: pretty_pig smart_sheep An alternative way to change the levels of the levels is to assign the desired level vector to the levels() function with the factor as its argument. For example, if you want to translate the animals names into Spanish, you can use levels(animals_fac) &lt;- c(&quot;mona&quot;, &quot;cerda&quot;, &quot;oveja&quot;) animals_fac #&gt; [1] &lt;NA&gt; cerda mona oveja oveja cerda #&gt; Levels: mona cerda oveja 2.11.3 Ordered factors By default, the function factor() creates an unordered factor, which is usually used when there are no natural ordering among the levels. Sometimes, there may be a natural ordering among the levels. Let’s see an example. conditions &lt;- c(&quot;excellent&quot;, &quot;good&quot;, &quot;excellent&quot;, &quot;good&quot;, &quot;average&quot;) factor(conditions) Different from the animals in animals, the conditions have a natural ordering. We know \\(average &lt; good &lt; excellent\\). To reflect this in a factor, you can create an so-called ordered factor by setting ordered = TRUE and specify the levels in the ascending order of the desired ordering. condition_ordered_fac &lt;- factor(conditions, ordered = TRUE, levels = c(&quot;average&quot;, &quot;good&quot;, &quot;excellent&quot;)) condition_ordered_fac #&gt; [1] excellent good excellent good average #&gt; Levels: average &lt; good &lt; excellent We can see that there is an ordering shown in the “Levels.” You can also do comparisons on ordered factors. condition_ordered_fac[1] &lt; condition_ordered_fac[2] #&gt; [1] FALSE The result is FALSE since \\(excellent &gt; good\\). We will revisit the topic of factor ordering when generating bar charts in Section 4.10.2. 2.11.4 Exercises What are the advantages of factors over vectors? Suppose we define x &lt;- factor(1:5), what is the result of x[1] &lt; x[2]? Please try to answer this question without R. (a): TRUE (b): FALSE (c): NA Suppose we define x &lt;- factor(1:5, ordered = TRUE), what is the result of x[1] &lt; x[2]? Please try to answer this question without R. (a): TRUE (b): FALSE (c): NA Suppose we define x &lt;- factor(1:5, ordered = TRUE, levels = 5:1), what is the result of x[1] &lt; x[2]? Please try to answer this question without R. (a): TRUE (b): FALSE (c): NA Suppose size &lt;- rep(c(\"big\", \"small\", \"medium\"), 3:1), convert it to an ordered factor with levels small &lt; medium &lt; big. "],["null.html", "2.12 NULL, NaN, and Inf", " 2.12 NULL, NaN, and Inf Having learned the special missing value representation NA in Section 2.10, we will introduce three additional values to represent unexpected results, namely the NULL, NaN, and Inf. During the process, we will talk about their relationships to NA as well. 2.12.1 NULL First, let’s take a look at str(), typeof() and length() of NULL. str(NULL) #&gt; NULL typeof(NULL) #&gt; [1] &quot;NULL&quot; length(NULL) #&gt; [1] 0 As you can see NULL only has class NULL with no values inside, hence the length is 0. It is worth to have comparison with NA regarding these items. str(NA) #&gt; logi NA typeof(NA) #&gt; [1] &quot;logical&quot; length(NA) #&gt; [1] 1 NULL is often returned by expressions and functions whose value is undefined. a. Undefined field of a list The first scenario of NULL is when you try to access an element of a list that is undefined. my_list &lt;- list(num = 1:3, char = c(&quot;a&quot;, &quot;b&quot;)) my_list$logi #&gt; NULL Here, the result is NULL since logi is not a defined field in my_list. b. Remove an element from a list You can remove an element from a list by assign it the NULL value. length(my_list) #&gt; [1] 2 my_list$num &lt;- NULL length(my_list) #&gt; [1] 1 my_list #&gt; $char #&gt; [1] &quot;a&quot; &quot;b&quot; As you can see from the output, the element num is removed from my_list, leading to the length of my_list reduced by 1. c. Initialize a list of certain length The NULL value is useful to serve as the default initial value when you want to create a list of certain length using the vector() function. my_list &lt;- vector(mode = &quot;list&quot;, length = 3) my_list #&gt; [[1]] #&gt; NULL #&gt; #&gt; [[2]] #&gt; NULL #&gt; #&gt; [[3]] #&gt; NULL It is worth mentioning that the vector() function is also useful to initialize a vector of given mode and length. vector(&quot;numeric&quot;, length = 2) ##default is 0 #&gt; [1] 0 0 vector(&quot;logical&quot;, length = 2) ##default is FALSE #&gt; [1] FALSE FALSE vector(&quot;integer&quot;, length = 2) ##default is 0 #&gt; [1] 0 0 vector(&quot;character&quot;, length = 2) ##default is empty string #&gt; [1] &quot;&quot; &quot;&quot; To check if an element is NULL, you can’t use the logical comparison == NULL. Instead, you need to use the is.null() function. a &lt;- NULL a == NULL #&gt; logical(0) is.null(a) #&gt; [1] TRUE It is worth explaining the result of a == NULL is logical(0), representing a logical vector of length 0. The underlying reason is that NULL contains no value and is of length 0. As the == comparison returns a logical type object, hencing leading to a logical vector of length 0. d. NULL values when creating a vector If you create a vector with NULL values, all NULL values will be removed if there exists at least one regular values. If all of them are NULL values, only one of them will be kept. Note that there is fundamentally different from NA values. NA means the value is there, but the exact value is not available to us. c(NULL, NULL, 1, NULL) #&gt; [1] 1 c(NULL, NULL) #&gt; NULL c(NA, NA) #&gt; [1] NA NA 2.12.2 NaN NaN, represents Not a Number, usually appears when you divide 0 by 0. 0/0 #&gt; [1] NaN Again, it is worth to look at str(), typeof() and length() of NaN. str(NaN) #&gt; num NaN typeof(NaN) #&gt; [1] &quot;double&quot; length(NaN) #&gt; [1] 1 As you can see from the results, NaN is a numeric vector of length 1, with the value NaN. To check if a value is NaN, you can’t use the == NaN similar to checking missing values, instead you need to use the function is.nan(). a &lt;- NaN a == NaN ##resulting an NA value #&gt; [1] NA is.nan(a) ##the correct way to check if the value is NaN #&gt; [1] TRUE is.nan(c(NA, 1, NaN)) #&gt; [1] FALSE FALSE TRUE 2.12.3 Inf The last special we want to introduce in this section is Inf, representing the value is positive infinity (\\(\\infty\\)), corresponding to a proper mathematical limit. Similarly, we also have negative infinity: -Inf. 1/0 #&gt; [1] Inf -2/0 #&gt; [1] -Inf Inf &gt; 3 #&gt; [1] TRUE Inf &lt; -1 #&gt; [1] FALSE Inf + Inf #&gt; [1] Inf -Inf + 1e10 #&gt; [1] -Inf 1/0 - 1/0 #it equals 0/0, hencing NaN #&gt; [1] NaN Again, it is worth to look at str(), typeof() and length() of Inf. str(Inf) #&gt; num Inf typeof(Inf) #&gt; [1] &quot;double&quot; length(Inf) #&gt; [1] 1 As you can see from the results, similar to NaN, Inf is a numeric vector of length 1, but with the value Inf. To check whether a value is finite or infinite, you can use the is.finite() and is.infinite() function. is.finite(1/0) #&gt; [1] FALSE is.infinite(-3/0) #&gt; [1] TRUE 2.12.4 A comparison of the four special values in R We would like to summarize the different behaviors of the four special values in R in the following table. Summary NA NULL NaN Inf class() \"logical\" \"NULL\" \"numeric\" \"numeric\" length() 1 0 1 1 check is.na() is.null() is.nan() is.finite() "],["dates.html", "2.13 Dates and Times", " 2.13 Dates and Times Now you have learned numeric vectors, character vectors and logical vectors which are quite intuitive. In this section, we want to introduce two special formats of vectors in R which are dates and times. Dates and times belong to vectors because they only contain values of the same type. 2.13.1 Dates a. Date class Let’s first look at a vector in the date format. First, to get today’s date, you can use the Sys.Date() function. Similarly, you can verify its class by using the class() function. today &lt;- Sys.Date() today #&gt; [1] &quot;2021-10-16&quot; class(today) #&gt; [1] &quot;Date&quot; Looking at the output, we know that today is a vector of the Date class. You may be wondering how are the dates stored in R. To get this information, you can use the typeof() function on a date object. typeof(today) #&gt; [1] &quot;double&quot; This may look a bit surprising to you. Indeed, dates objects are stored as numeric values (in “double” to be precise), representing the (signed) number of days that has passed since Jan 1, 1970 (The reference date in R). To get this information, you can convert it to a number by as.numeric(). as.numeric(today) #&gt; [1] 18916 Storing the dates as numbers make it handy to perform additions and subtractions. For example, you can use today - 1 to get the date of yesterday, and use today + 1 to get the date of tomorrow. today - 1 #&gt; [1] &quot;2021-10-15&quot; today + 1 #&gt; [1] &quot;2021-10-17&quot; The computation in R is done by adding or subtracting one to the number of days since Jan 1, 1970. Although the output of today looks similar to a string, you will get a character vector if you assign value(s) like \"2021-09-09\" to a name. You you can verify its class by using class(). Of course, an error will show up if you try to do addition or subtraction operations on a character vector. date_char &lt;- &quot;2021-09-09&quot; class(date_char) date_char - 1 #&gt; Error in date_char - 1: non-numeric argument to binary operator You can also get the days of week, months, and quarters for a date using the functions weekdays(), months(), and quarters(). weekdays(today) months(today) quarters(today) b. Converting between dates and strings Now, you may be wondering what information we can extract out of an object of the date class. We can use the format() function to convert a date class object into a string that contains various information about the date. First, let’s introduce a list of commonly used elements of dates and the corresponding conversion specification. A conversion specification is usually formed by % followed by a single letter. The following table shows a list of common conversion specifications. Code Name Example %m 2-digit month 10 %d 2-digit day 16 %y 2-digit year 21 %Y 4-digit year 2021 %a abbreviated weekday Sat %A full weekday Saturday %b abbreviated month Oct %B full month October Then, for a Date class object, we can create a format string that containing any number of the conversion specifications in the previous table. The working mechanism of format() is that it will scan through the format string, look for all the conversion specifications, and convert the conversion specifications into their corresponding values for the given date. Any character in the format string which is not part of a conversion specification is interpreted literally (and %% gives %). Let’s see an example. format(today, &quot;Today is %A (%a for short), %b %d, %Y. It is also %m/%d/%Y&quot;) #&gt; [1] &quot;Today is Saturday (Sat for short), Oct 16, 2021. It is also 10/16/2021&quot; On the other hand, we can also convert a string back into a Date class object. To do that, you can use the as.Date() function with the string along with the corresponding format string in the fomat argument. You can also specify the tryFormats argument, which contains a character vector with all possible formats to try. Aug &lt;- as.Date(&quot;08-01-2021&quot;, format = &quot;%m-%d-%Y&quot;) Aug #&gt; [1] &quot;2021-08-01&quot; class(Aug) #&gt; [1] &quot;Date&quot; Here, the value of format corresponds to each part in string. %m corresponds to 08, which is the month of the date. %d corresponds to 01, which is the day of the date. %Y corresponds to 2021, which is the year of the date. Now you have successfully converted the string into a vector of the Date class! The as.Date() function can be viewed as the inverse function of format() when we use the same format string. as.Date(format(today, format = &quot;%m-%d-%Y&quot;), format = &quot;%m-%d-%Y&quot;) Notice that the correspondence of the string and supplied format should follow the above table, otherwise you may get some unexpected result. as.Date(&quot;08-01-2021&quot;, format = &quot;%B-%d-%y&quot;) #wrong #&gt; [1] NA as.Date(&quot;August-01-2021&quot;, format = &quot;%B-%d-%y&quot;) #correct #&gt; [1] &quot;2020-08-01&quot; Here, you should use August rather than 08 in string because %B corresponds to full month, so you get NA as the result. In addition to use - as the separator, you can also use / as the separator. If the separators used in the string and the format doesn’t match in as.Date(), you will also get NA as the result. as.Date(&quot;08/01/2021&quot;, format = &quot;%m/%d/%y&quot;) #&gt; [1] &quot;2020-08-01&quot; as.Date(&quot;08/01/2021&quot;, format = &quot;%m-%d-%y&quot;) #&gt; [1] NA as.Date(&quot;08/01/2021&quot;, format = &quot;%m-%d/%y&quot;) #&gt; [1] NA You can try different combinations by yourself. Here are some examples！ as.Date(&quot;01-03-2021&quot;, format = &quot;%m-%d-%Y&quot;) #&gt; [1] &quot;2021-01-03&quot; as.Date(&quot;01-03-2021&quot;, format = &quot;%d-%m-%Y&quot;) #&gt; [1] &quot;2021-03-01&quot; as.Date(&quot;Apr-03-2021&quot;, format = &quot;%b-%d-%Y&quot;) #&gt; [1] &quot;2021-04-03&quot; as.Date(&quot;09/October/97&quot;, format = &quot;%d/%B/%y&quot;) #&gt; [1] &quot;1997-10-09&quot; as.Date(&quot;2010-02-29&quot;, format = &quot;%Y-%m-%d&quot;) #&gt; [1] NA It is worth noting that the last output is NA, indicating that Feb 29, 2010 is not a valid date. That’s because only leap years have 29 days in February! We can also construct date using the number of days since a reference date using the origin argument in the as_date() function. as.Date(10, origin = &quot;2021-01-01&quot;) #10 days after 2021-01-01 #&gt; [1] &quot;2021-01-11&quot; c. difftime class Now, let’s introduce a very useful class named difftime. From the name, you may be able to tell it is designed to represent time differences. Let’s see an example when we subtract between two dates objects. ref_date &lt;- as.Date(&quot;1970/01/01&quot;, format = &quot;%Y/%m/%d&quot;) days_diff &lt;- today - ref_date #the time difference between two dates days_diff #&gt; Time difference of 18916 days class(days_diff) #&gt; [1] &quot;difftime&quot; To learn more about the difftime class, let’s look at its structure. str(days_diff) #&gt; &#39;difftime&#39; num 18916 #&gt; - attr(*, &quot;units&quot;)= chr &quot;days&quot; You can see that it is stored as a number, with an attribute named \"units\" and the value \"days\". This attribute shows the units of the difference. To create a time difference in other units, you can use the difftime() function and specify the units argument to the desired units. hours_diff &lt;- difftime(today, ref_date, units = &quot;hours&quot;) weeks_diff &lt;- difftime(today, ref_date, units = &quot;weeks&quot;) You can also use the as.difftime() function to help getting date. For example, to get the date of 10 weeks and 3 days from today, you can use the following code. ten_week &lt;- as.difftime(10, units = &quot;weeks&quot;) today + ten_week + 3 #&gt; [1] &quot;2021-12-28&quot; 2.13.2 Times After talking about dates, it is natural to introduce how times are represented in R. Just like dates, let’s first get the time at the current moment using the Sys.time() function. You can also check its class, internal storage type, and structure by the class(), typeof(), and str() functions. now &lt;- Sys.time() now #&gt; [1] &quot;2021-10-16 10:26:26 EDT&quot; class(now) #&gt; [1] &quot;POSIXct&quot; &quot;POSIXt&quot; typeof(now) #&gt; [1] &quot;double&quot; str(now) #&gt; POSIXct[1:1], format: &quot;2021-10-16 10:26:26&quot; The object now is of class POSIXct. The second element of class(now) is POSIXt, which is a parent class for class POSIXct and class PISIXlt. This parent class POSIXt is used to allow operations such as subtraction to mix the two classes. From the result of typeof(now), we know that similar to dates, the POSIXct class used to represent times is also stored as double. Indeed, the class POSIXct represents the (signed) number of seconds since the beginning of 1970 as a numeric vector. You can also get the time of an hour ago or a minute later. Now, here the difference is in the unit of seconds instead of days for the date class. now - 3600 #&gt; [1] &quot;2021-10-16 09:26:26 EDT&quot; now + 60 #&gt; [1] &quot;2021-10-16 10:27:26 EDT&quot; Besides all the elements for dates you can use for the time class object, a list of other commonly used elements of times and the corresponding conversion specifications is summarized in the following table. Code Name Example %H hours 10 %M minutes 26 %S seconds 26 %Z time zone EDT Just like dates, you can format the time into characters via the format() function. format(now, &quot;Hi! The current time in %Z (Time Zone) is %A (weekday), year %Y, month %m, day %d, hour %H, min %M, second %S. &quot;) #&gt; [1] &quot;Hi! The current time in EDT (Time Zone) is Saturday (weekday), year 2021, month 10, day 16, hour 10, min 26, second 26. &quot; You can also display the time in a different time zone by setting the tz argument in the format() function. format(now, tz = &quot;UTC&quot;) #Coordinated Universal Time #&gt; [1] &quot;2021-10-16 14:26:26&quot; format(now, tz = &quot;America/Los_Angeles&quot;) #Pacific Standard Time #&gt; [1] &quot;2021-10-16 07:26:26&quot; format(now, tz = &quot;America/New_York&quot;) #Eastern Standard Time #&gt; [1] &quot;2021-10-16 10:26:26&quot; format(now, tz = &quot;Europe/London&quot;) #Greenwich Mean Time #&gt; [1] &quot;2021-10-16 15:26:26&quot; To create a time object from a character, you can use the as.POSIXlt() function with the optional format argument. as.POSIXct(&quot;2021-09-21 13:14:15&quot;, format = &quot;%Y-%m-%d %H:%M:%S&quot;) #&gt; [1] &quot;2021-09-21 13:14:15 EDT&quot; as.POSIXct(&quot;13:14:15, Sep 21, 2021&quot;, format = &quot;%H:%M:%S, %b %d, %Y&quot;) #&gt; [1] &quot;2021-09-21 13:14:15 EDT&quot; Similar as the difference of dates, the difference of two times is also an object of class difftime. You can again use the as.difftime() function to help with getting a time difference object in the given unit. For example, to get the time 2 days 3 hours and 4 minutes later, you can use the following. now + as.difftime(2, units = &quot;days&quot;) + as.difftime(3, units = &quot;hours&quot;) + as.difftime(4, units = &quot;mins&quot;) #&gt; [1] &quot;2021-10-18 13:30:26 EDT&quot; 2.13.3 Exercises From year 1900 to year 2021 (inclusive), calculate the number of leap years. (Hint: for a leap year, February has 29 days instead of 28. The value of as.Date(\"2010-02-29\", format = \"%Y-%m-%d\") is NA) If x &lt;- as.Date(\"69-01-01\", format = \"%y-%m-%d\") and y &lt;- as.Date(\"68-12-31\", format = \"%y-%m-%d\"), what is x - y? Please think about the answer first, then try it in R. What’s the date of the day that is 1000 days later than Feb 14, 2021. What’s the time that is 1 year, 2 days, 3 hours, 4 minutes, and 5 seconds past 8:15pm on July 4, 2021. "],["r-objects-other-types.html", "Chapter 3 R Objects (II): Other Types", " Chapter 3 R Objects (II): Other Types Having mastered vectors in Chapter 2, we will introduce other types of R objects, including matrix, array, data frame, and list. Type Section Matrix 3.1 Array 3.2 Data Frame 3.3 List 3.5 "],["matrix.html", "3.1 Matrix", " 3.1 Matrix Having mastered vectors which are an 1-dimensional objects containing elements of the same type, we now introduce another object type, called matrix, which is a rectangular array (2-dimensional) that consists of elements of the same type, arranged in rows and columns. 3.1.1 Create a matrix from a vector One of most common ways to create a matrix from a vector is to use the function matrix(). In the matrix() function, the first argument is the data vector, nrow and ncol represent the desired numbers of rows and columns of the matrix. matrix(data = 1:12, nrow = 3, ncol = 4) #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 Typically, the length of the supplied vector equals the number of rows multiplied by the number of columns. Otherwise, R will use the recycling rule on the vector to fill in the matrix. This recycling rule is particularly useful to create matrix consisting of elements of the same value. matrix(6, 3, 3) #&gt; [,1] [,2] [,3] #&gt; [1,] 6 6 6 #&gt; [2,] 6 6 6 #&gt; [3,] 6 6 6 Note that you can just specify nrow or ncol if the value of the other one can be implied. For example, you will get the same matrix using the following codes. matrix(data = 1:12, nrow = 3) matrix(data = 1:12, ncol = 4) Looking at the resulting matrix, you may notice that the matrix is created by fill in the columns sequentially with the elements from the input vector. That is, it first fill in the first column, then the second column, and so on. If you want to fill the rows instead of columns, you can add the argument byrow = TRUE. matrix(1:12, nrow = 4, byrow = TRUE) After defining a matrix, we can apply various functions on it. x &lt;- matrix(1:12, nrow = 4) dim(x) #the dimension of a matrix #&gt; [1] 4 3 nrow(x) #the number of row of a matrix #&gt; [1] 4 ncol(x) #the number of column of a matrix #&gt; [1] 3 t(x) #transpose of a matrix #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 2 3 4 #&gt; [2,] 5 6 7 8 #&gt; [3,] 9 10 11 12 Now, let’s check its class using class(), internal storage type using typeof(), structure using str(), and attributes using attributes(). class(x) #&gt; [1] &quot;matrix&quot; &quot;array&quot; typeof(x) #&gt; [1] &quot;integer&quot; str(x) #&gt; int [1:4, 1:3] 1 2 3 4 5 6 7 8 9 10 ... attributes(x) #&gt; $dim #&gt; [1] 4 3 We can see that x is of matrix class, and the storage type is integer. The reason is that when creating consecutive integers using the : operator, R will interpret it as integers. x has one attribute named dim with value 4 3. Attributes are very critical in determining the class as well as the structure of an R object. You can completely change the class and structure of an R object by specifying/changing its attributes. v &lt;- rep(1:3, 2) class(v) str(v) attr(v, &quot;dim&quot;) &lt;- c(2, 3) v class(v) str(v) In this example, you will convert a length-6 vector into a 2-by-3 matrix by setting the \"dim\" attributes. To set the names of a matrix, you can use rownames() and colnames() to set the row names and column names, respectively. rownames(x) &lt;- c(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;) #row names colnames(x) &lt;- c(&quot;x&quot;,&quot;y&quot;,&quot;z&quot;) #column names Interesting, you can use the same functions rownames() and colnames() to extract the row and column names. rownames(x) colnames(x) We can also convert a matrix to a vector, which will take the elements of the matrix column by column. as.vector(x) #convert matrix to a vector #&gt; [1] 1 2 3 4 5 6 7 8 9 10 11 12 In addition to numeric matrices, you can also create character matrices from a character vector. char_mat &lt;- matrix(letters[1:6], 2, 3) char_mat #&gt; [,1] [,2] [,3] #&gt; [1,] &quot;a&quot; &quot;c&quot; &quot;e&quot; #&gt; [2,] &quot;b&quot; &quot;d&quot; &quot;f&quot; Another way of creating matrix from a vector is to assign the desired dimensions (length-2 integer vector) to the dim() function. my_vec &lt;- 1:6 my_vec #&gt; [1] 1 2 3 4 5 6 dim(my_vec) &lt;- c(2, 3) my_vec #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 You can see here, my_vec becomes a matrix after we set its dimensions. 3.1.2 Combine vectors or matrices into a matrix To combine two vectors into a matrix, you can use the rbind() or cbind() function to stack the vectors together by row or by column, respectively. z &lt;- 1:4 w &lt;- 5:8 rbind(z,w) #&gt; [,1] [,2] [,3] [,4] #&gt; z 1 2 3 4 #&gt; w 5 6 7 8 cbind(z,w) #&gt; z w #&gt; [1,] 1 5 #&gt; [2,] 2 6 #&gt; [3,] 3 7 #&gt; [4,] 4 8 In addition to combine two vectors, you can also use rbind() and cbind() to combine two matrices. m1 &lt;- matrix(1:6, 2, 3) m2 &lt;- matrix(5:10, 2, 3) rbind(m1, m2) #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 #&gt; [3,] 5 7 9 #&gt; [4,] 6 8 10 cbind(m1, m2) #&gt; [,1] [,2] [,3] [,4] [,5] [,6] #&gt; [1,] 1 3 5 5 7 9 #&gt; [2,] 2 4 6 6 8 10 3.1.3 Matrix subsetting Like vector subsetting introduced in 2.6.3, we can do matrix subsetting as well. a. using indices to do matrix subsetting The first method for matrix subsetting is to specify the desired row indices and column indices, separated by ,. For example, we can extract the (1, 1) and (2, 3) element of x using the following codes. x[1, 1] #the element on the first row and first column #&gt; [1] 1 x[2, 3] #the element on the second row and third column #&gt; [1] 10 To get a submatrix with multiple rows and columns, you just need to supply the row and column indices separated by ,. x[1:2,2:3] #the elements on the first &amp; second row and second &amp; third column To keep all the rows or columns, you can leave the index location empty. x[2, ] #the elements on the second row x[, 3] #the elements on the third column x[, c(2,3)] #the elements on the second and third columns As you can see from the first two results, if the result is only one-dimensional, R will drop the other index and return a vector instead of a matrix. If you need to keep the result as a matrix, you can add a third dimension drop = FALSE in the subsetting operation. x[2, ,drop = FALSE] #&gt; x y z #&gt; b 2 6 10 x[, 3,drop = FALSE] #&gt; z #&gt; a 9 #&gt; b 10 #&gt; c 11 #&gt; d 12 Similar to vectors, you can use negative indices to get all the rows or columns except the specified one. x[-2, 3] #all rows except the 2nd row, the 3rd column x[-1, -c(2,3)] #all rows except the 1st row, except the 2nd and the 3rd column b. using row and column names to do matrix subsetting Just like vector subsetting for named vectors (Section 2.6.3), we can extract a submatrix using the row and columns names. x[&quot;a&quot;, &quot;z&quot;] x[c(&quot;a&quot;, &quot;c&quot;), c(&quot;x&quot;, &quot;y&quot;)] x[&quot;b&quot;,] c. using logical vectors to do matrix subsetting Similar to vector subsetting, you can also use logical vectors to do matrix subsetting. Note that different from vector subsetting, you can supply two logical vectors, one for rows and another for columns. Let’s see some examples. x[c(T, F, T, F), c(F, T, T)] x[c(F, T, F, T), ] x[, c(T, F, F)] In addition to using the logical values directly, you can also use create a logical vector and use it on the fly to do matrix subsetting. Let’s say we want to keep the rows with the value on the y column larger than 6. To do that, you can create a logical vector x[, \"y\"] &gt; 6, then use it to subset the corresponding rows. x[, &quot;y&quot;] &gt; 6 #logical vector for the rows such that the `y` column &gt; 6 #&gt; a b c d #&gt; FALSE FALSE TRUE TRUE x[x[, &quot;y&quot;] &gt; 6, ] #extract the corresponding rows #&gt; x y z #&gt; c 3 7 11 #&gt; d 4 8 12 Similarly, if we want to keep the columns with the value on the b row less than 7. To do that, you can create a logical vector x[\"b\", ] &lt; 7, then use it to subset the corresponding columns. x[&quot;b&quot;, ] &lt; 7 #logical vector for the columns such that the `b` row &lt; 7 #&gt; x y z #&gt; TRUE TRUE FALSE x[, x[&quot;b&quot;, ] &lt; 7] #extract the corresponding columns #&gt; x y #&gt; a 1 5 #&gt; b 2 6 #&gt; c 3 7 #&gt; d 4 8 Of course, you can combine the two requirements, namely, keep the rows with the value on the y column larger than 6 and the columns with the value on the b row less than 7. x[x[, &quot;y&quot;] &gt; 6, x[&quot;b&quot;, ] &lt; 7] 3.1.4 Update values in sub-matrices Just as updating values on sub-vectors (Section 2.6.4), we can use the same technique for updating values in sub-matrices. x[1, 2] &lt;- 10 #update the (1, 2) element x #&gt; x y z #&gt; a 1 10 9 #&gt; b 2 6 10 #&gt; c 3 7 11 #&gt; d 4 8 12 x[1:2, 3] &lt;- c(20, 30) #update the (1:2, 3) submatrix x #&gt; x y z #&gt; a 1 10 20 #&gt; b 2 6 30 #&gt; c 3 7 11 #&gt; d 4 8 12 x[, 2] &lt;- 40 #update the 2nd column to 40 x #&gt; x y z #&gt; a 1 40 20 #&gt; b 2 40 30 #&gt; c 3 40 11 #&gt; d 4 40 12 x[c(2, 4), c(1, 3)] &lt;- 50 x #&gt; x y z #&gt; a 1 40 20 #&gt; b 50 40 50 #&gt; c 3 40 11 #&gt; d 50 40 50 3.1.5 Operators and functions on matrices Now, let’s introduce some commonly used operators and functions on matrices. First of all, if you use arithmetic operators between two matrices, the specified operation will be performed elementwisely, similar to the operation between two vectors. m1 &lt;- matrix(c(2, 1, 1, 2), 2, 2) m2 &lt;- matrix(c(1, 2, 2, 1), 2, 2) m1 + m2 #&gt; [,1] [,2] #&gt; [1,] 3 3 #&gt; [2,] 3 3 m1 * m2 #&gt; [,1] [,2] #&gt; [1,] 2 2 #&gt; [2,] 2 2 m1 / m2 #&gt; [,1] [,2] #&gt; [1,] 2.0 0.5 #&gt; [2,] 0.5 2.0 You can also apply operations between a matrix and a number (a vector of length 1), where the recycling rule introduced in Section 2.1.1 will apply. m1 * 2 To perform the actual matrix product, you can use the operator %*% between two matrices. m1 %*% m2 #&gt; [,1] [,2] #&gt; [1,] 4 5 #&gt; [2,] 5 4 There are also functions for creating special matrices. To create a diagonal matrix, you can use the diag() function on a vector. diag(1:5) #&gt; [,1] [,2] [,3] [,4] [,5] #&gt; [1,] 1 0 0 0 0 #&gt; [2,] 0 2 0 0 0 #&gt; [3,] 0 0 3 0 0 #&gt; [4,] 0 0 0 4 0 #&gt; [5,] 0 0 0 0 5 The diag() function can also be used to extract the digonal elements of a square matrix. diag(m1) #&gt; [1] 2 2 For a squared matrix \\(A_{n\\times n} = [A_{ij}]\\), you can also calculate its determinant \\(det(A)\\) using det(A). If \\(A\\) is invertible, you can compute its inverse matrix \\(A^{-1}\\) using solve(A). det(m1) #&gt; [1] 3 solve(m1) #&gt; [,1] [,2] #&gt; [1,] 0.6666667 -0.3333333 #&gt; [2,] -0.3333333 0.6666667 m1 %*% solve(m1) ##verify we are getting the inverse of m1 #&gt; [,1] [,2] #&gt; [1,] 1 0 #&gt; [2,] 0 1 To apply a function on all elements of a matrix, you can directly use the function on the matrix object as if it is a vector. The result is equivalent to first convert the matrix into a vector using as.vector() and apply the function on the vector. sum(x) #&gt; [1] 395 mean(x) #&gt; [1] 32.91667 quantile(x, c(0.25, 0.5, 0.75)) #&gt; 25% 50% 75% #&gt; 17.75 40.00 50.00 cumsum(x) #&gt; [1] 1 51 54 104 144 184 224 264 284 334 345 395 3.1.6 Apply functions on each row or each column In many applications, we may want to apply certain function on each row or column. To do this, you can use the apply() function, which takes three arguments by default. The first argument is the object, the second argument is the dimension(s) to apply the function on, and the third argument is the function For example, if you want to calculate the mean and sum of each row for x, you can use apply(x, 1, mean) #calculate the mean of each row #&gt; a b c d #&gt; 20.33333 46.66667 18.00000 46.66667 rowMeans(x) #calculate the mean of each row #&gt; a b c d #&gt; 20.33333 46.66667 18.00000 46.66667 apply(x, 1, sum) #calculate the sum of each row #&gt; a b c d #&gt; 61 140 54 140 rowSums(x) #calculate the sum of each row #&gt; a b c d #&gt; 61 140 54 140 Here, 1 means the first dimension, i.e. the row. You can see that the mean for the row a is (1 + 5 + 9)/3 = 5, and the sum is 1 + 5 + 9 = 15. To get the mean and sum of each row, you can also use rowMeans() and rowSums(). To calculate the mean and sum of each column for x, you can use apply(x, 2, mean) #calculate the mean of each column #&gt; x y z #&gt; 26.00 40.00 32.75 colMeans(x) #&gt; x y z #&gt; 26.00 40.00 32.75 apply(x, 2, sum) #&gt; x y z #&gt; 104 160 131 colSums(x) #&gt; x y z #&gt; 104 160 131 Here, 2 means the second dimension, i.e. the column. You can see that the mean for the column y is (5 + 6 + 7 + 8)/4 = 6.5, and the sum is 5 + 6 + 7 + 8 = 26. In addition to the mean and sum functions, you can use any function defined on a vector. Following are some other examples. apply(x, 2, sd) #calculate the standard deviation of each column #&gt; x y z #&gt; 27.72484 0.00000 20.25463 apply(x, 1, max) #calculate the max of each row #&gt; a b c d #&gt; 40 50 40 50 In addition the three arguments, you can add additional arguments that will be passed when applying the specified function. For example, to calculate the first quartile of each column, apply(x, 2, quantile, 0.25) #&gt; x y z #&gt; 2.50 40.00 17.75 If the function you apply returns a vector with more than one elements, the apply() function will create a higher dimensional object. Let’s see an example of calculate the cumulative sum of each row. apply(x, 1, cumsum) #calculate the cumulative sum of each row #&gt; a b c d #&gt; x 1 50 3 50 #&gt; y 41 90 43 90 #&gt; z 61 140 54 140 The mechanism is to the cumsum() function is applied on each row of x and the resulting vectors are combined into a matrix. The following reproduces the results using the cbind() function on the cumulative sum results. cbind(cumsum(x[1,]), cumsum(x[2,]), cumsum(x[3,]), cumsum(x[4,])) As another example, you can use the following code to calculate the (0.25, 0.5, 0.75) quantiles for each column of x. apply(x, 2, quantile, c(0.25, 0.5, 0.75)) #&gt; x y z #&gt; 25% 2.5 40 17.75 #&gt; 50% 26.5 40 35.00 #&gt; 75% 50.0 40 50.00 Finally, let’s see an example of the apply() function on a character matrix. Let’s see we want to combine the strings in each column of the matrix with separator _. apply(char_mat, 2, paste, collapse = &quot;_&quot;) #&gt; [1] &quot;a_b&quot; &quot;c_d&quot; &quot;e_f&quot; 3.1.7 Exercises Use R to create the following matrix #&gt; [,1] [,2] [,3] [,4] [,5] [,6] #&gt; [1,] 2 1 1 1 1 1 #&gt; [2,] 1 2 1 1 1 1 #&gt; [3,] 1 1 2 1 1 1 #&gt; [4,] 1 1 1 2 1 1 #&gt; [5,] 1 1 1 1 2 1 #&gt; [6,] 1 1 1 1 1 2 For matrix x &lt;- matrix(1:16, 4, 4), compute the following questions using R. Compute the column means of x. Create a matrix that contains the 0.4 and 0.7 quantiles for each row of x. Compute the cumulative sum of each row of x. What type of object is the result? And explain the result of the first column. If b &lt;- 1:4, solve a such that \\(Xa = b\\). "],["array.html", "3.2 Array", " 3.2 Array Having learned the 1-dimensional vector and 2-dimensional matrix in Section 3.1, it is time to go to the higher dimensional space, namely array. Array can be viewed as an extension of vector and matrix to a higher dimensional (\\(&gt;=3\\)) space, and still only contains elements of the same type. 3.2.1 Create an array from a vector To create an array from a vector, you can use the function array(). Let’s see an example and use dim() to get its dimension. x &lt;- array(1:24, c(2,3,4)) x #&gt; , , 1 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 1 3 5 #&gt; [2,] 2 4 6 #&gt; #&gt; , , 2 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 7 9 11 #&gt; [2,] 8 10 12 #&gt; #&gt; , , 3 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 13 15 17 #&gt; [2,] 14 16 18 #&gt; #&gt; , , 4 #&gt; #&gt; [,1] [,2] [,3] #&gt; [1,] 19 21 23 #&gt; [2,] 20 22 24 dim(x) #&gt; [1] 2 3 4 You can see from the result, array has more than two dimensions. To display all elements, R will slice the array into many matrices by fixing the indices except the first two, then display one matrix at a time. As usual, we can learn more about an array by using the str(), class() and typeof() functions. str(x) #&gt; int [1:2, 1:3, 1:4] 1 2 3 4 5 6 7 8 9 10 ... class(x) #&gt; [1] &quot;array&quot; typeof(x) #&gt; [1] &quot;integer&quot; We can see that x is a three-dimensional array with integers as its elements. Similarly, you can create a higher-dimensional array. The following example creates a four-dimensional array with all elements equaling 6. y &lt;- array(6, 2:5) y dim(y) 3.2.2 Array subsetting Like vector subsetting in Section 2.6.3 and matrix subsetting in Section 3.1.3, we can do array subsetting as well. To do array subsetting, you can specify the indices for each dimension separated by ,. Since x is a three-dimensional array, you can specify at most 3 indices. If you leave the indices for certain dimensions empty, everything will be kept along the corresponding dimensions. You can also use negative index to dropping the specified elements. Let’s see a few examples. x[1, 2, 3] #the (1, 2, 3) element of x #&gt; [1] 15 x[, , 2] #the matrix where the index of the 3rd dimension equals 2 #&gt; [,1] [,2] [,3] #&gt; [1,] 7 9 11 #&gt; [2,] 8 10 12 x[2, , 4] #the vector whether the indices of the 1st and 3rd dimension equal 2 and 4. #&gt; [1] 20 22 24 x[-2, 3, -3] #&gt; [1] 5 11 23 Just like subsetting matrices, you can also use logical vectors on each dimension, as well as using names as the indices when the array is named. 3.2.3 Operators and functions on arrays Similar to vectors and matrices, arithmetic operations between arrays are performed elementwisely, with the recycling rule applying when the two arrays are of different dimensions. Let’s see the following example. array_1 &lt;- array(1:8, c(2, 2, 2)) array_2 &lt;- array(8:1, c(2, 2, 2)) array_1 + array_2 array_1 * array_2 array_1 * 3 To apply a function on all elements of an array, you can directly use the function on the array object as if it is a vector, as we did with a matrix. The result is equivalent to first convert the array into a vector using as.vector() and apply the function on the vector. sum(array_2) #&gt; [1] 36 mean(array_2) #&gt; [1] 4.5 quantile(array_2, c(0.25, 0.5, 0.75)) #&gt; 25% 50% 75% #&gt; 2.75 4.50 6.25 cumsum(array_2) #&gt; [1] 8 15 21 26 30 33 35 36 3.2.4 Apply functions along certain dimension(s) Just like when we work with matrices, it is of interest to apply functions not on the whole array, but along certain dimension(s). To do this, you can use the same function apply() as we did in matrices. apply(array_1, 1, mean) #calculate the mean along the first dim #&gt; [1] 4 5 mean(array_1[1, , ]) #verify the first element #&gt; [1] 4 mean(array_1[2, , ]) #verify the second element #&gt; [1] 5 apply(array_1, 2, sum) #calculate the sum along the second dim #&gt; [1] 14 22 apply(array_1, 3, sd) #calculate the sd along the third dim #&gt; [1] 1.290994 1.290994 In the second argument of apply(), in addition to specifying one dimension, you can also supply a vector of dimensions that the function will be applied upon. For example, the following code computes the sum along the first two dimensions. apply(array_1, 1:2, sum) #&gt; [,1] [,2] #&gt; [1,] 6 10 #&gt; [2,] 8 12 sum(array_1[1, 1, ]) #verify the [1, 1] element #&gt; [1] 6 sum(array_1[1, 2, ]) #verify the [1, 2] element #&gt; [1] 10 sum(array_1[2, 1, ]) #verify the [2, 1] element #&gt; [1] 8 sum(array_1[2, 2, ]) #verify the [2, 2] element #&gt; [1] 12 In addition the three arguments, you can add additional arguments that will be passed when applying the specified function as we did in Section 3.1.6. For example, the follow code generates the third quartile of along the third dimension. apply(array_1, 3, quantile, 0.75) #&gt; [1] 3.25 7.25 "],["dataframe.html", "3.3 Data Frame", " 3.3 Data Frame So far, we have learned vectors (Chapter 2), matrices (Section 3.1), and arrays (Section 3.2). The three different object types share an important features: they all consist of elements of the same type, namely numeric, character, or logical. In real applications, it is common to have mixed variable types. To accommodate this, let’s introduce a new object type, namely the data frame. 3.3.1 Introduction to Data Frames To create a data frame, you can use the data.frame() function with a collection of vectors of the same length. Let’s see an example of some health conditions of a sheep and a pig over the years 2019, 2020 and 2021. animal &lt;- rep(c(&quot;sheep&quot;, &quot;pig&quot;), c(3,3)) year &lt;- rep(2019:2021, 2) weight &lt;- c(110, 120, 140, NA, 300, 800) height &lt;- c(2.2, 2.4, 2.7, 2, 2.1, 2.3) condition &lt;- c(&quot;excellent&quot;, &quot;good&quot;, NA, &quot;excellent&quot;, &quot;good&quot;, &quot;average&quot;) condition &lt;- factor(condition, ordered = TRUE, levels = c(&quot;average&quot;, &quot;good&quot;, &quot;excellent&quot;)) healthy &lt;- c(rep(TRUE, 5), FALSE) my_data_frame &lt;- data.frame(animal, year, weight, height, condition, healthy) my_data_frame #&gt; animal year weight height condition healthy #&gt; 1 sheep 2019 110 2.2 excellent TRUE #&gt; 2 sheep 2020 120 2.4 good TRUE #&gt; 3 sheep 2021 140 2.7 &lt;NA&gt; TRUE #&gt; 4 pig 2019 NA 2.0 excellent TRUE #&gt; 5 pig 2020 300 2.1 good TRUE #&gt; 6 pig 2021 800 2.3 average FALSE Looking at the data frame my_data_frame, it has 6 columns, each of which represents one variable. The variables are of different types. The animal is factor, year is integer, both weight and height are doubles, condition is ordered factor, and healthy is logical. ’ This kind of data representation is impossible using matrices since the coercion rule will apply, converting everything into characters. Let’s combine everything into a matrix and check its value. my_mat &lt;- cbind(animal, year, weight, height, condition, healthy) my_mat #&gt; animal year weight height condition healthy #&gt; [1,] &quot;sheep&quot; &quot;2019&quot; &quot;110&quot; &quot;2.2&quot; &quot;3&quot; &quot;TRUE&quot; #&gt; [2,] &quot;sheep&quot; &quot;2020&quot; &quot;120&quot; &quot;2.4&quot; &quot;2&quot; &quot;TRUE&quot; #&gt; [3,] &quot;sheep&quot; &quot;2021&quot; &quot;140&quot; &quot;2.7&quot; NA &quot;TRUE&quot; #&gt; [4,] &quot;pig&quot; &quot;2019&quot; NA &quot;2&quot; &quot;3&quot; &quot;TRUE&quot; #&gt; [5,] &quot;pig&quot; &quot;2020&quot; &quot;300&quot; &quot;2.1&quot; &quot;2&quot; &quot;TRUE&quot; #&gt; [6,] &quot;pig&quot; &quot;2021&quot; &quot;800&quot; &quot;2.3&quot; &quot;1&quot; &quot;FALSE&quot; In the process of creating data frames, you can also name each column. my_data_frame2 &lt;- data.frame(ani = animal, y = year, w = weight, h = height, con = condition, hea = healthy) After creating the data frame, it is useful to examine its class using the class() function and structure using the str() function. class(my_data_frame) #&gt; [1] &quot;data.frame&quot; str(my_data_frame) #&gt; &#39;data.frame&#39;: 6 obs. of 6 variables: #&gt; $ animal : chr &quot;sheep&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; ... #&gt; $ year : int 2019 2020 2021 2019 2020 2021 #&gt; $ weight : num 110 120 140 NA 300 800 #&gt; $ height : num 2.2 2.4 2.7 2 2.1 2.3 #&gt; $ condition: Ord.factor w/ 3 levels &quot;average&quot;&lt;&quot;good&quot;&lt;..: 3 2 NA 3 2 1 #&gt; $ healthy : logi TRUE TRUE TRUE TRUE TRUE FALSE The str() tells us the data frame has 6 observations and 6 variables, along with the type and the first few values of each variable. From the output, you may be puzzled by the $ symbol before each variable name. In fact, you can easily extract a certain column corresponding to a variable with its name. my_data_frame$animal #&gt; [1] &quot;sheep&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; &quot;pig&quot; &quot;pig&quot; my_data_frame$weight #&gt; [1] 110 120 140 NA 300 800 In Section 2.5, we introduced the very useful function summary() which gives us important summary statistics for a vector. Using summary() on a data frame, you get the summary statistics for each variable. summary(my_data_frame) #&gt; animal year weight height condition #&gt; Length:6 Min. :2019 Min. :110 Min. :2.000 average :1 #&gt; Class :character 1st Qu.:2019 1st Qu.:120 1st Qu.:2.125 good :2 #&gt; Mode :character Median :2020 Median :140 Median :2.250 excellent:2 #&gt; Mean :2020 Mean :294 Mean :2.283 NA&#39;s :1 #&gt; 3rd Qu.:2021 3rd Qu.:300 3rd Qu.:2.375 #&gt; Max. :2021 Max. :800 Max. :2.700 #&gt; NA&#39;s :1 #&gt; healthy #&gt; Mode :logical #&gt; FALSE:1 #&gt; TRUE :5 #&gt; #&gt; #&gt; #&gt; From the results, you can see that depending on the variable type, you get different forms of summary. In the object my_data_frame, there are two missing values represented by NA. To remove the observations (rows) with NA values, you can use the na.omit() on the data frame. my_df_nona &lt;- na.omit(my_data_frame) my_df_nona #&gt; animal year weight height condition healthy #&gt; 1 sheep 2019 110 2.2 excellent TRUE #&gt; 2 sheep 2020 120 2.4 good TRUE #&gt; 5 pig 2020 300 2.1 good TRUE #&gt; 6 pig 2021 800 2.3 average FALSE You can see that the 3rd and 4th row are removed since they both have a missing observation. An alternative approach to remove all rows with missing observations is to first use the complete.cases() function to get a logical vector of whether a row has missing elements, and then use data frame subsetting. complete_ind &lt;- complete.cases(my_data_frame) my_data_frame[complete_ind, ] 3.3.2 Adding Observations or Variables in Data Frames Sometimes, you may want to add additional observations or variables to an existing data frame. To add additional observations, you need to put the additional observations or variables into a new data frame, and use the rbind() function. new_obs &lt;- data.frame(animal = &quot;pig&quot;, year = 2018, weight = 200, height = 1.9, condition = &quot;excellent&quot;, healthy = TRUE) rbind(my_data_frame, new_obs) #&gt; animal year weight height condition healthy #&gt; 1 sheep 2019 110 2.2 excellent TRUE #&gt; 2 sheep 2020 120 2.4 good TRUE #&gt; 3 sheep 2021 140 2.7 &lt;NA&gt; TRUE #&gt; 4 pig 2019 NA 2.0 excellent TRUE #&gt; 5 pig 2020 300 2.1 good TRUE #&gt; 6 pig 2021 800 2.3 average FALSE #&gt; 7 pig 2018 200 1.9 excellent TRUE To add an additional variable to the existing data frame, you just need to add a new field to the data frame. my_data_frame$age &lt;- my_data_frame$year - 2015 my_data_frame 3.3.3 Subsetting Data Frames As a two-dimensional object type, subsetting data frames is very similar to subsetting matrices. a. using indices to do data frame subsetting The first method for data frame subsetting is to specify the desired row indices and column indices, separated by ,. For example, we can extract the (1, 3) and (2, 4) element of x using the following codes. my_data_frame[1, 3] #&gt; [1] 110 my_data_frame[2, 4] #&gt; [1] 2.4 Similar to a matrix subsetting, if you omit the indices of one dimension, R will keep everything along that dimension. You can also use negative indices to keep everything except the provides indices. Let’s see some examples. my_data_frame[2, ] #&gt; animal year weight height condition healthy age #&gt; 2 sheep 2020 120 2.4 good TRUE 5 my_data_frame[, 2] #&gt; [1] 2019 2020 2021 2019 2020 2021 my_data_frame[2] #a single index corresponds to the columns #&gt; year #&gt; 1 2019 #&gt; 2 2020 #&gt; 3 2021 #&gt; 4 2019 #&gt; 5 2020 #&gt; 6 2021 my_data_frame[c(1,3), -c(3,4)] #&gt; animal year condition healthy age #&gt; 1 sheep 2019 excellent TRUE 4 #&gt; 3 sheep 2021 &lt;NA&gt; TRUE 6 b. using column names to do data frame subsetting Since data frames usually have column names, you can do subsetting using multiple column names. my_data_frame[, c(&quot;animal&quot;, &quot;weight&quot;)] #&gt; animal weight #&gt; 1 sheep 110 #&gt; 2 sheep 120 #&gt; 3 sheep 140 #&gt; 4 pig NA #&gt; 5 pig 300 #&gt; 6 pig 800 c. using logical vectors to do data frame subsetting Using logical vectors to do data frame subsetting is very useful. Suppose we want to find the condition of the pig in year 2021. is_2021 &lt;- my_data_frame$year == 2021 is_pig &lt;- my_data_frame$animal == &quot;pig&quot; my_data_frame$condition[is_2021 &amp; is_pig] #&gt; [1] average #&gt; Levels: average &lt; good &lt; excellent Now, let’s say we want to extract all the observations with an excellent condition. my_data_frame[my_data_frame$condition == &quot;excellent&quot;, ] #&gt; animal year weight height condition healthy age #&gt; 1 sheep 2019 110 2.2 excellent TRUE 4 #&gt; NA &lt;NA&gt; NA NA NA &lt;NA&gt; NA NA #&gt; 4 pig 2019 NA 2.0 excellent TRUE 4 my_data_frame[which(my_data_frame$condition == &quot;excellent&quot;), ] #remove the NA row #&gt; animal year weight height condition healthy age #&gt; 1 sheep 2019 110 2.2 excellent TRUE 4 #&gt; 4 pig 2019 NA 2.0 excellent TRUE 4 "],["tibble.html", "3.4 Tibble", " 3.4 Tibble Having learned data frames in Section 3.3, we would like to introduce a modern version of data frame, named tibbles. Tibbles are data frames, but change some behaviors of data frames to make coding easier. To use the tibble class, you need to install the tibble package, which is part of the tidyverse package. install.packages(&quot;tibble&quot;) 3.4.1 Introduction to tibbles After installing the tibble package, you can load the package and create a tibble the same way as you create a data frame. library(tibble) animal &lt;- rep(c(&quot;sheep&quot;, &quot;pig&quot;), c(3,3)) year &lt;- rep(2019:2021, 2) healthy &lt;- c(rep(TRUE, 5), FALSE) my_tibble &lt;- tibble(animal, year, healthy) my_tibble #&gt; # A tibble: 6 × 3 #&gt; animal year healthy #&gt; &lt;chr&gt; &lt;int&gt; &lt;lgl&gt; #&gt; 1 sheep 2019 TRUE #&gt; 2 sheep 2020 TRUE #&gt; 3 sheep 2021 TRUE #&gt; 4 pig 2019 TRUE #&gt; 5 pig 2020 TRUE #&gt; 6 pig 2021 FALSE Another way to create a tibble is using the as_tibble() function on a data frame. my_data_frame &lt;- data.frame(animal, year, healthy) as_tibble(my_data_frame) From the output, we can see that tibbles show the variable type under the name, which is very helpful. Another useful feature of tibble compare to data frame is that when you check its value, the output only shows at most the first 10 rows and the number of columns that can fit the output window, which avoids the console to be overcrowded. x &lt;- 1:1e5 tibble(id = x, value = sin(x)) #&gt; # A tibble: 100,000 × 2 #&gt; id value #&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 1 0.841 #&gt; 2 2 0.909 #&gt; 3 3 0.141 #&gt; 4 4 -0.757 #&gt; 5 5 -0.959 #&gt; 6 6 -0.279 #&gt; 7 7 0.657 #&gt; 8 8 0.989 #&gt; 9 9 0.412 #&gt; 10 10 -0.544 #&gt; # … with 99,990 more rows Be prepared that your console output will be flooded with numbers before running the following code. data.frame(id = x, value = sin(x)) Once we have a tibble, let’s learn its class and structure. class(my_tibble) #&gt; [1] &quot;tbl_df&quot; &quot;tbl&quot; &quot;data.frame&quot; str(my_tibble) #&gt; tibble [6 × 3] (S3: tbl_df/tbl/data.frame) #&gt; $ animal : chr [1:6] &quot;sheep&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; ... #&gt; $ year : int [1:6] 2019 2020 2021 2019 2020 2021 #&gt; $ healthy: logi [1:6] TRUE TRUE TRUE TRUE TRUE FALSE From the result, you can see that in addition to \"data.frame\", the tibble also has classes of \"tbl_df\" and \"tbl\", which contain many useful functions. We will be using tibbles extensively throughout the rest of book due to its advantages over the original data frames. Lastly, we summarize the different variables types of tibble in the following table. Type Section &lt;chr&gt; character vector &lt;int&gt; integer &lt;dbl&gt; double &lt;ord&gt; ordered factor &lt;fct&gt; unordered factor &lt;lgl&gt; logical vector &lt;date&gt; dates &lt;dttm&gt; date-times Since tibble belongs to data frame, all the functions we learned for data frames including addition observations or variables, and subsetting operations can be used in the exact same format. However, the tibble class offers additional functions which makes some tasks easier. 3.4.2 Adding Observations or Variables in Tibbles In a tibble, adding observations has an easier method than that in a data frame, via the add_row() function in the tibble package. add_row(my_tibble, animal = &quot;pig&quot;, year = c(2017, 2018), healthy = TRUE) #&gt; # A tibble: 8 × 3 #&gt; animal year healthy #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;lgl&gt; #&gt; 1 sheep 2019 TRUE #&gt; 2 sheep 2020 TRUE #&gt; 3 sheep 2021 TRUE #&gt; 4 pig 2019 TRUE #&gt; 5 pig 2020 TRUE #&gt; 6 pig 2021 FALSE #&gt; 7 pig 2017 TRUE #&gt; 8 pig 2018 TRUE From the results, we can see that multiple rows can be added at the same time by specifying the corresponding values for each variable name. Note the recycling rule applies for other variables with only one value specified. To add an additional variable, in addition to using the $ followed by a name as in data frames, you can also use the function add_column(). add_column(my_tibble, weight = c(110, 120, 140, NA, 300, 800), height = c(2.2, 2.4, 2.7, 2, 2.1, 2.3) ) 3.4.3 Tibble subsetting While the tibble subsetting is very similar to the data frame subsetting, we would like to point out a few key differences. First of all, when you use the [ and ] to do tibble subsetting, it always returns a tibble by default, even if only one column is selected. This behavior is different from subsetting data frames using [ and ]. If you would like to get a vector using only one column is selected, you need to add drop = TRUE in the subsetting process. You can also subset a single row and convert it into a vector by adding the same argument. my_tibble[, 1] #3*1 tibble #&gt; # A tibble: 6 × 1 #&gt; animal #&gt; &lt;chr&gt; #&gt; 1 sheep #&gt; 2 sheep #&gt; 3 sheep #&gt; 4 pig #&gt; 5 pig #&gt; 6 pig my_data_frame[, 1] #vector #&gt; [1] &quot;sheep&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; &quot;pig&quot; &quot;pig&quot; my_tibble[, 1, drop = TRUE] #vector #&gt; [1] &quot;sheep&quot; &quot;sheep&quot; &quot;sheep&quot; &quot;pig&quot; &quot;pig&quot; &quot;pig&quot; "],["list.html", "3.5 List", " 3.5 List In the last two sections, we have learned data frames and tibbles whose columns can contain variables of different types. Now, let’s learn the most complex object type in R, namely, the list. 3.5.1 Create a list To create a list, you can use the list() function with the elements separated by comma. dig_num &lt;- 1:6 ani_char &lt;- c(&quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;, &quot;pig&quot;, &quot;monkey&quot;, &quot;pig&quot;) x_mat &lt;- matrix(1:12, nrow = 3, ncol = 4) conditions &lt;- c(&quot;Excellent&quot;, &quot;Good&quot;, &quot;Average&quot;, &quot;Fair&quot;, &quot;Good&quot;, &quot;Excellent&quot;) cond_fac &lt;- factor(conditions, ordered = TRUE, levels = c(&quot;Fair&quot;, &quot;Average&quot;, &quot;Good&quot;, &quot;Excellent&quot;)) my_list &lt;- list(dig_num, ani_char, x_mat, cond_fac) my_list #&gt; [[1]] #&gt; [1] 1 2 3 4 5 6 #&gt; #&gt; [[2]] #&gt; [1] &quot;sheep&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; #&gt; #&gt; [[3]] #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 #&gt; #&gt; [[4]] #&gt; [1] Excellent Good Average Fair Good Excellent #&gt; Levels: Fair &lt; Average &lt; Good &lt; Excellent Here, we created a list named my_list, which contains four elements of different types. From the output, at the beginning of each element, its index is shown surrouding by the pair [[ and ]]. Usually, you want to assign a name for each element and the elements can be latter accessed by their names. my_list &lt;- list(number = dig_num, character = ani_char, matrix = x_mat, factor = cond_fac) my_list #&gt; $number #&gt; [1] 1 2 3 4 5 6 #&gt; #&gt; $character #&gt; [1] &quot;sheep&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; #&gt; #&gt; $matrix #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 #&gt; #&gt; $factor #&gt; [1] Excellent Good Average Fair Good Excellent #&gt; Levels: Fair &lt; Average &lt; Good &lt; Excellent After the elements are named, the output shows the $ followed by the name before each element. Let’s examine the class, structure, and internal storage type of my_list. class(my_list) #&gt; [1] &quot;list&quot; str(my_list) #&gt; List of 4 #&gt; $ number : int [1:6] 1 2 3 4 5 6 #&gt; $ character: chr [1:6] &quot;sheep&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; ... #&gt; $ matrix : int [1:3, 1:4] 1 2 3 4 5 6 7 8 9 10 ... #&gt; $ factor : Ord.factor w/ 4 levels &quot;Fair&quot;&lt;&quot;Average&quot;&lt;..: 4 3 2 1 3 4 typeof(my_list) #&gt; [1] &quot;list&quot; From this example, it is clear that lists are more general than all the object types we have learned. It can contain vectors, matrices, arrays, data frames/tibbles, and even lists. In R, data frames are actually stored as lists. Indeed, they are special lists where each element is a vector (could be of different types) and each element is of the same length. Let’s create a data frame and look at its typeof(). df_ex &lt;- data.frame(dig_num, ani_char) typeof(df_ex) length(df_ex) For this reason, data frame and matrix are treated completely differently in R. Most functions on lists can be used directly on data frames. 3.5.2 Extract a list element and list subsetting a. Extract a list element To extract a single element from a list, you can use the $ followed by the element name if the element is named, or use the index surrounded by [[ and ]]. After the elements are extracted, you can directly apply desired functions on them without the need to assign the values to another name. my_list$number #a vector #&gt; [1] 1 2 3 4 5 6 #my_list[[1]] #the first element #my_list$matrix #a matrix my_list[[3]] #the third element #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 mean(my_list$number) #&gt; [1] 3.5 rowMeans(my_list$matrix) #&gt; [1] 5.5 6.5 7.5 If you want to do list subsetting by extracting multiple elements, you can follow similar methods as subsetting a vector introduced in Section 2.6.3. b. Use indices to do list subsetting The first method is to use indices to do list subsetting. To get a sublist of the 3rd element of the original list my_list, you can use my_list[3] as below. my_list[3] #the second element of my_list #&gt; $matrix #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 It is worth to do a comparison between the results of my_list[[3]] and my_list[3]. The former is the third element of my_list which is a matrix, while the latter is a list containing a single matrix element. Let’s confirm this by looking at their structures. str(my_list[[3]]) #&gt; int [1:3, 1:4] 1 2 3 4 5 6 7 8 9 10 ... str(my_list[3]) #&gt; List of 1 #&gt; $ matrix: int [1:3, 1:4] 1 2 3 4 5 6 7 8 9 10 ... Of course, you can create a sublist containing multiple element, just like when creating subvectors using indices. my_list[c(1,3)] #the first and third elements of my_list #my_list[-3] #all elements except the third one c. Use names to do list subsetting When the list elements are named, you can also use names around [ and ] to do list subsetting. You can also use a character vector containing the element names. my_list[&#39;number&#39;] #&gt; $number #&gt; [1] 1 2 3 4 5 6 my_list[c(&#39;number&#39;, &#39;matrix&#39;)] #&gt; $number #&gt; [1] 1 2 3 4 5 6 #&gt; #&gt; $matrix #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 3.5.3 List inside a list One interesting aspect of the list type is that you can have lists inside a list. my_big_list &lt;- list(small_list = my_list, number = dig_num) my_big_list #&gt; $small_list #&gt; $small_list$number #&gt; [1] 1 2 3 4 5 6 #&gt; #&gt; $small_list$character #&gt; [1] &quot;sheep&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; #&gt; #&gt; $small_list$matrix #&gt; [,1] [,2] [,3] [,4] #&gt; [1,] 1 4 7 10 #&gt; [2,] 2 5 8 11 #&gt; [3,] 3 6 9 12 #&gt; #&gt; $small_list$factor #&gt; [1] Excellent Good Average Fair Good Excellent #&gt; Levels: Fair &lt; Average &lt; Good &lt; Excellent #&gt; #&gt; #&gt; $number #&gt; [1] 1 2 3 4 5 6 If you want to extract ani_char from my_list, you need to use two layers of extraction operations. my_big_list$small_list$ani_char #&gt; NULL my_big_list[[1]][[2]] #&gt; [1] &quot;sheep&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; You can further put the my_big_list in another list. my_big_big_list &lt;- list(big_list = my_big_list, character = ani_char) my_big_big_list To extract dig_num from my_big_big_list, you now need three layers of extraction operations. my_big_big_list$big_list$small_list[[1]] #&gt; [1] 1 2 3 4 5 6 my_big_big_list[[1]][[1]][[1]] #&gt; [1] 1 2 3 4 5 6 #my_big_big_list[[1]]$small_list[[1]] #mix the two ways for value extraction 3.5.4 Unlist a list Sometime, you may want to unlist a list into a vector. unlist(my_list) #&gt; number1 number2 number3 number4 number5 number6 character1 #&gt; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;sheep&quot; #&gt; character2 character3 character4 character5 character6 matrix1 matrix2 #&gt; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; &quot;1&quot; &quot;2&quot; #&gt; matrix3 matrix4 matrix5 matrix6 matrix7 matrix8 matrix9 #&gt; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; #&gt; matrix10 matrix11 matrix12 factor1 factor2 factor3 factor4 #&gt; &quot;10&quot; &quot;11&quot; &quot;12&quot; &quot;4&quot; &quot;3&quot; &quot;2&quot; &quot;1&quot; #&gt; factor5 factor6 #&gt; &quot;3&quot; &quot;4&quot; c(my_list[[1]], my_list[[2]], my_list[[3]], my_list[[4]]) #reproduce the result #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;sheep&quot; &quot;pig&quot; #&gt; [9] &quot;monkey&quot; &quot;pig&quot; &quot;monkey&quot; &quot;pig&quot; &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; #&gt; [17] &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; &quot;11&quot; &quot;12&quot; #&gt; [25] &quot;4&quot; &quot;3&quot; &quot;2&quot; &quot;1&quot; &quot;3&quot; &quot;4&quot; As you can tell from the result, the unlist() function works in the following steps. It visits each element of the list sequentially according to the indices, one at a time. Each element will be converted into a vector using the as.vector() function. Then converted vectors of each element will be combined into a longer vector using the c() function. During the c() operation, coercion rules will apply. The named of the final vector will the name of each element followed by the index of the corresponding value inside each list element. Here, my_list doesn’t contain an element that is also a list. When a list contains another list as one of its elements, the unlist() function will also apply the unlist operation on the element by default. In fact, the unlist operation will be applied recursively until none of the elements is a list. Please try to run the following example. unlist(my_big_big_list) If you just want to unlist a list at the first level, you can add the argument recursive = FALSE to the unlist() function. Note that the result will still be a list if the original list contains a list. You can check the result of the following code. unlist(my_big_big_list, recursive = FALSE) 3.5.5 Apply functions for each element of a list It is often useful to apply function on each element of a list. To do that, you can use the lapply() function (short for list apply). Let’s look at an example where we want to get the length of each element of my_list. lapply(my_list, length) #&gt; $number #&gt; [1] 6 #&gt; #&gt; $character #&gt; [1] 6 #&gt; #&gt; $matrix #&gt; [1] 12 #&gt; #&gt; $factor #&gt; [1] 6 You can see that the default output of lapply() is another list which is the result of the function applied on each element of the list. In this application, it might to better to use a vector to represent the result. To do this simplification, you can use the sapply() function, which is a user-friendly version and wrapper of lapply() which will return a vector or a matrix when appropriate. sapply(my_list, length) #&gt; number character matrix factor #&gt; 6 6 12 6 Let’s look at another example where we want to compute the quantiles of each element of a list. my_num_list &lt;- list(a = 1:20, b = rep(c(TRUE, FALSE), c(6,3))) sapply(my_num_list, quantile) #&gt; a b #&gt; 0% 1.00 0 #&gt; 25% 5.75 0 #&gt; 50% 10.50 1 #&gt; 75% 15.25 1 #&gt; 100% 20.00 1 "],["summary-r-objects.html", "3.6 Summary of R Objects", " 3.6 Summary of R Objects Throughout last chapter and this one, we have covered all types of R objects including vectors, matrices, arrays, data frames (tibbles), and lists. In this section, we would like to summarize what we have covered and highlight the differences of the different types of objects in terms of their dimensions and the data types they can contain. Type Section Dim Data Type Vector 2.1 1 Single Matrix 3.1 2 Single Array 3.2 &gt;=3 Single Data Frame/Tibble 3.3 - 3.4 2 Multiple List 3.5 1 Multiple "],["data-visualization.html", "Chapter 4 Data Visualization", " Chapter 4 Data Visualization Equipped with the knowledge of different R objects in Chapters 2 and 3, we are ready to dive into the colorful world of data visualization. In this chapter, you will learn all kinds of plots that can be generated in R. "],["intro-dataset.html", "4.1 Introduction to the Ames Housing Price Data Set", " 4.1 Introduction to the Ames Housing Price Data Set Before generating any beautiful plots, let’s first introduce the data set that will be used throughout this chapter. The data set is a part of the Ames Housing Price data, containing 165 observations and 12 features including the sale date and price. The data set sahp is located in the R package r02pro, the companion package of this book. Besides the r02pro package, we will also extensively use the ggplot2 package for visualization in this chapter. Like the tibble package, ggplot2 is another member of the tidyverse package. You can install the ggplot2 package if you haven’t done so. install.packages(&quot;ggplot2&quot;) First, let’s load the r02pro, ggplot2, and tibble packages. library(r02pro) library(ggplot2) library(tibble) After loading the three packages, you can type sahp to have a quick look of the dataset. sahp #&gt; # A tibble: 165 × 12 #&gt; dt_sold bedroom bathroom gar_car oa_qual liv_area lot_area house_style #&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 2010-03-25 3 2.5 2 6 1479 13517 2Story #&gt; 2 2009-04-10 4 3.5 2 7 2122 11492 2Story #&gt; 3 2010-01-15 3 2 1 5 1057 7922 1Story #&gt; 4 2010-04-19 3 2.5 2 5 1444 9802 2Story #&gt; 5 2010-03-22 3 2 2 6 1445 14235 1.5Fin #&gt; 6 2010-06-06 2 2.5 2 6 1888 16492 1Story #&gt; 7 2006-06-14 2 3 2 6 1072 3675 SFoyer #&gt; 8 2010-05-08 3 2 2 5 1188 12160 1Story #&gt; 9 2007-06-14 2 1 1 5 924 15783 1Story #&gt; 10 2007-09-01 5 2.5 2 5 2080 11606 2Story #&gt; # … with 155 more rows, and 4 more variables: kit_qual &lt;chr&gt;, heat_qual &lt;chr&gt;, #&gt; # central_air &lt;chr&gt;, sale_price &lt;dbl&gt; You can see that sahp is a tibble with 165 observations and 12 variables. By default, the output only shows the first 10 observations in the tibble along with the first few variables that can fit the window. To view the full dataset, you can use the view() function, which will open the dataset in a new window. view(sahp) To view the top rows of the dataset, you can use the head() function, which produces the first 6 observations by default. You can also set an optional second argument to pick any given number of observations. head(sahp) head(sahp, 15) To get a first impression on the dataset, you can use the summary() function introduced in Section 2.5. summary(sahp) In the output, we get the summary statistics for each variable. For numeric variables, we get the minimum, 1st quartile, median, mean, 3rd quartile, and the maximum. It also shows the number of NAs for a particular variable. For character variables, we only get the length of the vector, the class, and the mode. Although the types of each variable are shown in the result when typing sahp, a more detailed list can be found with the function str(). str(sahp) #&gt; tibble [165 × 12] (S3: tbl_df/tbl/data.frame) #&gt; $ dt_sold : Date[1:165], format: &quot;2010-03-25&quot; &quot;2009-04-10&quot; ... #&gt; $ bedroom : num [1:165] 3 4 3 3 3 2 2 3 2 5 ... #&gt; $ bathroom : num [1:165] 2.5 3.5 2 2.5 2 2.5 3 2 1 2.5 ... #&gt; $ gar_car : num [1:165] 2 2 1 2 2 2 2 2 1 2 ... #&gt; $ oa_qual : num [1:165] 6 7 5 5 6 6 6 5 5 5 ... #&gt; $ liv_area : num [1:165] 1479 2122 1057 1444 1445 ... #&gt; $ lot_area : num [1:165] 13517 11492 7922 9802 14235 ... #&gt; $ house_style: chr [1:165] &quot;2Story&quot; &quot;2Story&quot; &quot;1Story&quot; &quot;2Story&quot; ... #&gt; $ kit_qual : chr [1:165] &quot;Good&quot; &quot;Good&quot; &quot;Good&quot; &quot;Average&quot; ... #&gt; $ heat_qual : chr [1:165] &quot;Excellent&quot; &quot;Excellent&quot; &quot;Average&quot; &quot;Good&quot; ... #&gt; $ central_air: chr [1:165] &quot;Y&quot; &quot;Y&quot; &quot;Y&quot; &quot;Y&quot; ... #&gt; $ sale_price : num [1:165] 130 NA 109 174 138 ... The str() function gives a list of each component, the corresponding type, the length, and the first several values. 4.1.1 Are two-story houses more expensive than one-story ones? Let’s try to answer this question by doing some analysis. First, let’s create the logical vectors corresponding to two-story and one-story houses. story_2 &lt;- sahp$house_style == &quot;2Story&quot; story_1 &lt;- sahp$house_style == &quot;1Story&quot; Then, we create two vectors containing the prices of the two groups, respectively. sale_price_2 &lt;- sahp$sale_price[story_2] sale_price_1 &lt;- sahp$sale_price[story_1] Finally, we can run the summary() function on both vectors. summary(sale_price_2) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. NA&#39;s #&gt; 55.0 137.9 174.0 197.8 231.5 545.2 1 summary(sale_price_1) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 44.0 129.0 160.0 183.0 224.2 465.0 From these summaries, it is clear that the corresponding statistic is larger for two-story houses compared with one-story ones, for all 6 measures. As a result, we can draw the conclusion that the two-story houses indeed have a higher sale price than the one-story ones. 4.1.2 Converting Data Types When you import a data set into R, some variables may not have the desired types. In this case, it would be useful to convert them into the types you want before conducting further data analysis. a. Convert a character vector to an unordered factor Let’s look at the variable house_style in sahp. We can see from the output of str(sahp) that it is of chr type. Let’s confirm this and get it summary. is.character(sahp$house_style) #&gt; [1] TRUE summary(sahp$house_style) #&gt; Length Class Mode #&gt; 165 character character As briefly mentioned before, using the summary() function on a character vector doesn’t provide us much useful information. Let’s find the unique values of this vector and get the frequency table. unique(sahp$house_style) #&gt; [1] &quot;2Story&quot; &quot;1Story&quot; &quot;1.5Fin&quot; &quot;SFoyer&quot; &quot;SLvl&quot; table(sahp$house_style) #&gt; #&gt; 1.5Fin 1Story 2Story SFoyer SLvl #&gt; 21 81 50 5 8 We can see that there are five house styles along with their frequencies. It turns out to be particularly useful to convert this type of variable into a factor type. Let’s use the function as.factor() and run the summary function again. house_style_factor &lt;- factor(sahp$house_style) summary(house_style_factor) #&gt; 1.5Fin 1Story 2Story SFoyer SLvl #&gt; 21 81 50 5 8 b. Convert a character vector to an ordered factor Now, let’s take a look at another variable called kit_qual, measuring the kitchen quality. Again, let’s check the unique values. unique(sahp$kit_qual) #&gt; [1] &quot;Good&quot; &quot;Average&quot; &quot;Fair&quot; &quot;Excellent&quot; In addition to having four different quality values, they have an internal ordering among them. In particular, we know Fair &lt; Average &lt; Good &lt; Excellent. To reflect this, you can convert this variable in to an ordered factor using the factor() function. In particular, the ordered = TRUE argument reflects that we want to create an ordered factor. kit_qual_ordered_factor &lt;- factor(sahp$kit_qual, ordered = TRUE, levels = c(&quot;Fair&quot;, &quot;Average&quot;, &quot;Good&quot;, &quot;Excellent&quot;))#covert to ordered factor summary(kit_qual_ordered_factor) #&gt; Fair Average Good Excellent #&gt; 9 85 57 14 str(kit_qual_ordered_factor) #&gt; Ord.factor w/ 4 levels &quot;Fair&quot;&lt;&quot;Average&quot;&lt;..: 3 3 3 2 2 3 2 2 2 1 ... c. Convert a character vector to a logical vector Lastly, let’s look at the variable central_air, representing whether the house has central AC or not. As before, let’s get the unique elements. unique(sahp$central_air) #&gt; [1] &quot;Y&quot; &quot;N&quot; Intuitively, you can create a logical vector representing whether the house has central AC. central_air_logi &lt;- sahp$central_air == &quot;Y&quot; summary(central_air_logi) str(central_air_logi) Sometimes, you may also want to create additional variables from the existing ones. For example, we know the overall quality of the house ranges from 2 to 10. table(sahp$oa_qual) Maybe we want to call a house of good quality if oa_qual is larger than 5. We can then create a new logical variable as follows. good_qual &lt;- sahp$oa_qual &gt; 5 4.1.3 Recover Modified Values When you are working with a data set inside a package, you may accidentally modified some values in place by mistake. In this situation, you don’t need to panic as you can easily recover the data set into a faculty setting (i.e. the original version inside the package). To do this, you just need to use the data() function with the data set name as its argument. Let’s try to modify one value of sahp and recover the data set afterward. sahp[1,2] #get the original value #&gt; # A tibble: 1 × 1 #&gt; bedroom #&gt; &lt;dbl&gt; #&gt; 1 3 sahp[1,2] &lt;- 5 #modify the value sahp[1,2] #verify the modified value #&gt; # A tibble: 1 × 1 #&gt; bedroom #&gt; &lt;dbl&gt; #&gt; 1 5 data(sahp) #recover the data sahp[1,2] #verify the value is recovered #&gt; # A tibble: 1 × 1 #&gt; bedroom #&gt; &lt;dbl&gt; #&gt; 1 3 "],["scatterplots.html", "4.2 Scatterplots", " 4.2 Scatterplots From this section, you will learn various kinds of plots, that involves one or more variables in a data set. Considering the housing prices, a natural question you may have is that are the bigger houses more expensive? To answer this question, you need to look at the relationship between liv_area and the sale_price in the sahp data set. To visualize the relationship between two continuous variables, the most commonly used plot is the scatterplot, which is a 2-dimensional plot with a collection of all the datapoints, where the x-axis and y-axis correspond to the two variables, respectively. 4.2.1 Using the plot() function In base R, we can use the plot() function to generate this scatterplot with the first argument being the variable on the x-axis and the second argument being the variable on the y-axis. library(r02pro) plot(sahp$liv_area, sahp$sale_price) From the scatterplot, we can see a clear increasing trend between sale_price and liv_area, which is consistent with our intuition. The plot() function provides a rich capability of customization by setting the graphical parameters. We summarize a few commonly used parameters for scatterplots as below. Parameter Meaning Example col Color “red” xlab A title for the x-axis “Living Area” ylab A title for the y-axis “Sale Price” main A overall title for the plot “Sale Price vs. Living Area” pch Shape of the points 2 cex Size of text and symbols 2 Let’s see the effect of these parameters in the following example. plot(sahp$liv_area, sahp$sale_price, col = &quot;red&quot;, xlab = &quot;Living Area&quot;, ylab = &quot;Sale Price&quot;, main = &quot;Sale Price vs. Living Area&quot;, pch = 2, cex = 2) 4.2.2 Using the ggplot() function Although the plot() function gets the work done, the ggplot2 package provides a superior user experience which allows us to create complex plots with ease. Since the ggplot2 package is a member of the tidyverse package, you don’t need to install it separately if tidyverse was already installed. Let’s first load the package ggplot2 and create a scatterplot. library(ggplot2) ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) Aside from the expected scatterplot, you can see a warning message “Removed 1 rows containing missing values (geom_point).” This indicate that there is 1 row in sahp that contains missing values and it was removed during the plotting process. The removal of missing values is a default behavior for all plots generated by the ggplot2 package. Now, let’s walk through the mechanism of ggplot2. In a nutshell, ggplot2 implements the grammar of graphics, a coherent system for describing and building graphs. A more detailed description on the grammar of graphics can be found in Wickham (2010). Let’s break it down into two steps. In ggplot2, we always start with the function ggplot() with a data frame or tibble as its argument. ggplot(data = sahp) After running this code, you can see an empty plot. This is because ggplot does not yet know which variables or what type of plots you want to create. To generate a scatterplot, you can use add a layer using the + operator followed by the geom_point() function. The geom_point() is one of the many available geoms in ggplot. Inside geom_point(), you need to set the value of the mapping argument. The mapping argument takes a functional form as mapping = aes(), where the aes is short for aesthetics. For example, you can use aes() to tell ggplot to use which variable on the x-axis, which variable on the y-axis. Let’s take another look at this example. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) Here, inside the aes() function, we set x = liv_area and y = sale_price, indicating that the variable liv_area will appear on the x-axis and sale_price will appear on the y-axis. 4.2.3 Exercises Using the sahp dataset, Create a scatterplot to visualize the relationship between bedroom (on the x-axis) and sale_price (on the y-axis) without using any package, then set labels according to variable names and change all points to red. References "],["aes.html", "4.3 Aesthetics in ggplot", " 4.3 Aesthetics in ggplot Knowing how to generate a scatterplot using geom_point(), let’s discuss one of the most important aspects in a geom, namely, the aesthetics. Aesthetics include various parameters that you can change that affect the appearances of a plot. Some commonly used aesthetics include color, size, shape, and so on. Note that although we will introduce aesthetics via the example of scatterplot, they are used for all kinds of plots which will be covered at a later time. 4.3.1 Global Aesthetics First, we discuss global aesthetics, which change certain features of a plot globally. Let’s first review the code we used to generate the scatterplot between liv_area and sale_price. library(ggplot2) library(r02pro) ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) Now, let’s see how to set global aethetics in geom_point(). a. Color To change the color of all points, you can set the color argument in the geom_point() function. Note that it is placed outside of the aes() function. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price), color = &quot;red&quot;) Clearly, all points are changed to red. b. Size Similarly, you can set the size element in the geom_point() function to change the size of the all points. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price), size = 3) You may notice that the points are now bigger than before. Looking at the plot, many points are overlapping with each other, which is sometimes called overplotting. To solve this issue, you can change the transparency level of the points by setting the alpha argument. c. Transparency ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price), size = 3, alpha = 0.5) By setting alpha = 0.5, the points become more visible and the overplotting problem is largely alleviated. d. Shape Lastly, we can also change the shape of the points from the default one (circle) to other shapes by the shape argument in geom_point(). ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price), shape = 2) e. Multiple Aesthetics Of course, we can combine multiple global aesthetics in the same plot. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price), color = &quot;red&quot;, size = 3, shape = 2) Here, we have all points red, size of 3, and of triangle shape. 4.3.2 Map Discrete Variables to Aesthetics Knowing how to use global aesthetics to change the global appearance of a plot, you may want to differentiate different groups with different values of aesthetics. For example, you want to use different colors according to the different house_style in the scatterplot. To do this, you can map a discrete variable (say house_style), to an aesthetic (say color) by setting color = house_style as an argument in the aes() function. a. Color Now, let’s map house_style to color. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price, color = house_style), size = 3) From this figure, we can clearly see houses of different styles in distinct colors. In addition, ggplot automatically created a legend to show the correspondence between the house styles and colors. Sometimes, you may want to use specific colors for different values of the factor. To customize the colors, you can add a layer to the ggplot with function scale_colour_manual with argument values containing a character vector consisting of the colors. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price, color = house_style), size = 3) + scale_colour_manual(values = c(&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;orange&quot;,&quot;purple&quot;)) Similarly, you can also map central_air to color. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price, color = central_air), size = 3) The plot tells us the majority of the houses have central AC and the ones without it have relatively lower sale price. b. Size In addition to color, you can also map a discrete variable to the size aesthetic. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price, size = house_style), alpha = 0.5) You can see from the plot that the sizes of the points are now different according to the house_style. To alleviate the overplotting issue, we added a global aesthetic alpha = 0.5, making all points more transparent. There is a warning message: “Using size for a discrete variable is not advised.” The reason is that different sizes may implicitly indicate a particular ordering of the groups, which are usually not clear for a discrete variable. c. Shape We can also map a discrete variable to the shape aesthetic. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price, shape = house_style), size = 2, alpha = 0.5) Again, we added global aesthetics size and alpha to make the points more visible. d. Multiple mappings Just like global aesthetics, you can also have multiple mappings for aesthetics, and mix them with the global aesthetic when necessary. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price, color = house_style, shape = central_air), size = 3) Here, we can see the points have different colors according to house_style and are of different shapes depending on the value of central_air. Note that there are two legends on the plot showing the color and shape, respectively. 4.3.3 Change Legend Order via Factors Let’s first generate a scatterplot between liv_area and sale_price where we map the heat_qual (heating quality) to the color aesthetic. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price, color = heat_qual), size = 3) Looking at the legend, you can see that different heat_qual values are in alphabetical order as introduced in Section 2.4 when we introduced the ordering of character vectors. Sometimes, you may want to arrange these values in a different order in the plot, for example from the worst to the best. To achieve this, you can use the factor() function with the argument levels which specifies the desired order. sahp$heat_qual &lt;- factor(sahp$heat_qual, levels = c(&quot;Fair&quot;,&quot;Average&quot;,&quot;Good&quot;,&quot;Excellent&quot;)) ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price, color = heat_qual), size = 3) After changing the heat_qual variable to a factor with desired levels, you can see the order in the legend changes accordingly. 4.3.4 Map Continuous Variables to Aesthetics Knowing how to map discrete variables to aesthetics, it is natural to ask whether we can also map continuous variables to aesthetics. The answer is positive. a. Color Let’s again start with the color aesthetic by mapping oa_qual to color. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price, color = oa_qual)) Here, we can see the color of all points vary from dark blue to light blue, depending on the value of oa_qual. Instead of showing different colors in the discrete variable case, the legend now displays a bar showing a continuous color scale according to the value of oa_qual. To customize the color scale, you can add another lay using the function scale_color_continuous with arguments low and high being two colors corresponding to the colors when the variable is of low and high values, respectively. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price, color = oa_qual)) + scale_color_continuous(low = &quot;green&quot;, high = &quot;red&quot;) Here, the low value of oa_qual is mapped to green color and the high value of oa_qual is mapped to red color. You can also try out the following examples. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price, color = oa_qual)) + scale_color_continuous(low = &quot;yellow&quot;, high = &quot;blue&quot;) ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price, color = bedroom), size = 3) + scale_color_continuous(low = &quot;yellow&quot;, high = &quot;blue&quot;) b. Size In addition to the color aesthetic, we can also map continuous variables to the size aesthetic. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price, size = lot_area)) In this example, you can see the points corresponding to larger lot_area values are larger than those corresponding to smaller lot_area values. Note that although the legend only shows three different sizes, the actual size of the point is continuous corresponding to the value of lot_area. How about the shape aesthetic? Can we map a continuous variable to it? Let’s try it. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price, shape = lot_area)) #continuous variable can not be mapped to shape You will see an error message: “A continuous variable can not be mapped to shape.” The reason is intuitive: the shape can’t be naturally changed continuously. 4.3.5 Map Converted Logical Variable to Aesthetics Lastly, you can also create logical variables on the fly and map them to aesthetics. For example, if you want to differentiate the points according to whether the value of lot_area is larger than 1e4, a logical variable lot_area &gt; 1e4 can be created. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price, shape = lot_area &gt; 1e4), size = 3) We can see the houses with lot_area larger than 1e4 are of different shapes from those with less than 1e4 in lot area. Let’s see another example where we want to highlight the different between two-story houses from the other types. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price, shape = house_style == &quot;2Story&quot;)) Now, the two-story houses are triangles and other houses are circles. Clearly, you can easily create new logical variables using any logical operations on existing variables, and map them into any aesthetics just like the existing categorical variables. 4.3.6 Exercises Using the sahp dataset with the ggplot2 package, answer the following questions. Create a scatterplot to visualize the relationship between lot_area (on the x-axis) and sale_price (on the y-axis). In the scatterplot from Q1, change the size of all points to 3 and use different colors according to the value of house_style. Change legend order in the scatterplot from Q2 to be “1Story,” “SFoyer,” “1.5Fin,” “2Story,” “SLvl” from top to bottom. In the scatterplot from Q1, change the shape of all points to triangle and map bedroom to the color aesthetic. Then map the low value of bedroom to the yellow color and map the high value of bedroom to the green color. In the scatterplot from Q1, change the color of all points to green and use different shapes to distinguish whether the house has more than 3 bedrooms. "],["smoothline.html", "4.4 Smoothline Fits", " 4.4 Smoothline Fits Now, you know how to create scatterplots with many possible customizations via specifying different aesthetics. In addition to scatterplots, a very useful type of plots that can capture the trend of pairwise relationship is the smoothline fits. 4.4.1 Creating Smoothline Fits using geom_smooth() To create a smoothline fit, you can use the geom_smooth() function in the ggplot2 package. Let’s say you want to find the trend between the sale price and the living area of a house. library(ggplot2) library(r02pro) ggplot(data = sahp) + geom_smooth(mapping = aes(x = liv_area, y = sale_price)) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; Perhaps it is helpful to review the code for generating a scatterplot between liv_area and sale_price. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) We can see that the only difference is the use of different geoms. In fact, the mechanism of geom_smooth() is that it fits a smooth line according to the points of the given variable pair. By default, it uses the loess method (locally estimated scatterplot smoothing), which is a popular nonparametric regression technique. In addition to the smoothline, it also generates a shaded area, representing the confidence interval around the fitted smoothline. To hide this shaded area, you can add the argument se = FALSE as a global aesthetic. ggplot(data = sahp) + geom_smooth(mapping = aes(x = liv_area, y = sale_price), se = FALSE) In addition to the default loess method for smoothline fit, geom_smooth() also provides other smoothing methods. For example, we can set method = \"lm\" to fit a linear line. ggplot(data = sahp) + geom_smooth(mapping = aes(x = liv_area, y = sale_price), method = &quot;lm&quot;) #&gt; `geom_smooth()` using formula &#39;y ~ x&#39; 4.4.2 Aesthetics in Smoothline Fits As in scatterplots, you can also set global aesthetics as well as map variables to aesthetics in smoothline fits. Let’s begin with mapping variables to aesthetics. We first define a new logical vector good_qual which is TRUE when oa_qual &gt; 5. sahp$good_qual &lt;- sahp$oa_qual &gt; 5 a. Group When we map a variable to the group aesthetic, geom_smooth will first divide all the data points into different groups according to the variable value, and then fit a separate smoothline for each group. ggplot(data = sahp) + geom_smooth(mapping = aes(x = liv_area, y = sale_price, group = good_qual)) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; You can see that two smoothlines are generated. However, it is not clear from the plot which group each smoothline corresponds to. To make the two smoothlines different, you can map the variable to other aesthetics. b. Color As in geom_point(), we can map the variable to the color aesthetic. ggplot(data = sahp) + geom_smooth(mapping = aes(x = liv_area, y = sale_price, color = good_qual)) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; This is a more informative plot than the one using group aesthetic as you can see the two smoothlines have different colors according to the good_qual variable.ß c. Linetype Another useful aesthetic that was not applicable in geom_point() is linetype, which controls the linetypes for each smoothline. ggplot(data = sahp) + geom_smooth(mapping = aes(x = liv_area, y = sale_price, linetype = good_qual)) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; The plot shows a dashed line for the smoothline corresponding to good_qual == TRUE, and a solid line for the smoothline corresponding to good_qual == FALSE. d. Size You can also map good_qual to the size aesthetic, which controls the width of each smoothline fit. ggplot(data = sahp) + geom_smooth(mapping = aes(x = liv_area, y = sale_price, size = good_qual)) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; It is worth to mention that shape is not a valid aesthetic for geom_smooth as it doesn’t make sense to talk about the shape of a line. ggplot(data = sahp) + geom_smooth(mapping = aes(x = liv_area, y = sale_price, shape = good_qual)) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; When you try to map a variable to the shape aesthetic, geom_smooth() will show a warning message “Warning: Ignoring unknown aesthetics: shape,” and use the group aesthetic instead. Naturally, you can also have global aesthetic and it is straightforward to combine multiple aesthetics in the same plot. ggplot(data = sahp) + geom_smooth(mapping = aes(x = liv_area, y = sale_price, color = good_qual), linetype = 2) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 4.4.3 Exercises Using the sahp dataset with the ggplot2 package, answer the following questions. Create a smoothline fit to visualize the relationship between lot_area (on the x-axis) and sale_price (on the y-axis). Create several smoothlines with different colors corresponding to the value of kit_qual to visualize the relationship between lot_area (on the x-axis) and sale_price (on the y-axis). Create smoothlines without confidence interval around and with different linetypes to distinguish whether the house has more than 2 bedrooms to visualize the relationship between lot_area (on the x-axis) and sale_price (on the y-axis) . "],["multi-geom.html", "4.5 Multiple geoms and Aesthetics", " 4.5 Multiple geoms and Aesthetics So far, you have learned to create scatterplots using geom_point() and smoothline fits using geom_smooth(). It is sometimes useful to combine multiple geoms in the same plot. Let’s first review the scatterplot and smoothline fit between liv_area and sale_price. library(r02pro) library(tidyverse) #&gt; ── Attaching packages ─────────────────────────────────────── tidyverse 1.3.1 ── #&gt; ✓ tidyr 1.1.3 ✓ stringr 1.4.0 #&gt; ✓ readr 1.4.0 ✓ forcats 0.5.1 #&gt; ✓ purrr 0.3.4 #&gt; ── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ── #&gt; x dplyr::filter() masks stats::filter() #&gt; x dplyr::lag() masks stats::lag() ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) ggplot(data = sahp) + geom_smooth(mapping = aes(x = liv_area, y = sale_price)) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; To combine multiple geoms, you can simply use + to add them. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) + geom_smooth(mapping = aes(x = liv_area, y = sale_price)) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; As expected, you see all the points and the smoothline fit on the same plot, which contains very rich information. As usual, you can add aesthetics to both geoms. Let’s first map good_qual (defined as oa_qual &gt; 5 in Section 4.4) to the color aesthetic for geom_smooth(). ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) + geom_smooth(mapping = aes(x = liv_area, y = sale_price, color = good_qual)) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; To verify the two smoothline fits are indeed fitted from the data points in the two groups, you can map good_qual to the color aesthetic for geom_point() as well. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price, color = good_qual)) + geom_smooth(mapping = aes(x = liv_area, y = sale_price, color = good_qual), se = FALSE) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; The plot is reassuring that the two smoothline fits indeed correspond to the data points in the two groups defined by good_qual. Note that the legend also shows a NA category since there is a missing value in the variable good_qual. In addition to mapping variables to aesthetics, you can also use global aesthetics. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price, color = good_qual, shape = house_style == &quot;2Story&quot;)) + geom_smooth(mapping = aes(x = liv_area, y = sale_price, color = good_qual), linetype = 2, se = FALSE) #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 4.5.1 Exercises Using the sahp dataset with the ggplot2 package, answer the following questions. With lot_area on the x-axis and sale_price on the y-axis, create a plot that contains both the scatterplot and smoothline fits, where we use different colors in the scatterplot to distinguish whether heat_qual is excellent and different linetypes for the smoothline fits depending on whether house_style is 2Story. "],["global-local-mapping.html", "4.6 Global and Local Aesthetic Mappings", " 4.6 Global and Local Aesthetic Mappings In Section 4.5, you learned how to combine the scatterplot and smoothline fit into a single plot by using two geoms. Let’s first review the code. library(r02pro) library(tidyverse) ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) + geom_smooth(mapping = aes(x = liv_area, y = sale_price)) You may notice that the arguments inside geom_point() and geom_smooth() are identical. Now, thinking about if we want to generate another plot by replacing the liv_area with lot_area (the size of lot area), both instances of liv_area need to be changed to lot_area, which is a bit cumbersome. It turns out we can use the so-called global mapping to simplify the code. Correspondingly, we call a mapping inside a specific geom local mapping. To use the global mapping, we move the mapping argument from the geoms into the ggplot() function. ggplot(data = sahp, mapping = aes(x = liv_area, y = sale_price)) + geom_point() + geom_smooth() We can also map variables to aesthetics in the global mapping. The global aesthetic mapping will be inherited in all geoms used. ggplot(data = sahp, mapping = aes(x = lot_area, y = sale_price, color = kit_qual)) + geom_point() + geom_smooth() Clearly, the use of global mapping greatly simplify our code as we would need to repeat the same mapping argument in both geoms. In addition to using the same mapping in each geom as the global mapping, we can also extend or overwrite the global mapping in each geom. 4.6.1 Extend Global Aesthetic Mappings In addition to the global aesthetic mappings, you can add additional mappings in each geom. ggplot(data = sahp, mapping = aes(x = lot_area, y = sale_price, color = kit_qual)) + geom_point(mapping = aes(shape = gar_car &gt; 1)) + geom_smooth(mapping = aes(linetype = kit_qual)) Here, both geom_point() and geom_smooth() will first inherit the global mappings, then add the shape and linetype aesthetics, respectively. As you can see from the legend, there are some missing values for the variable gar_car. If you want to remove the observations that has a missing gar_car, you can use the function remove_missing(). ggplot(data = remove_missing(sahp, vars = &quot;gar_car&quot;), mapping = aes(x = lot_area, y = sale_price, color = kit_qual)) + geom_point(mapping = aes(shape = gar_car &gt; 1)) + geom_smooth(mapping = aes(linetype = kit_qual)) In the remove_missing() function, we use the argument vars = \"gar_car\" to indicate that only the observaitons with a missing gar_car are removed. Note that you may be tempting to use the function na.omit() on the data sahp. However, it is not recommended as the function will remove all observations whenever there is missing value for one variable, even if the variable is not used in the visualization process. 4.6.2 Overwrite Global Aesthetic Mappings When you add the same aesthetic mapping in the local geom as one of the global mappings, the corresponding local aesthetic mapping will be overwritten. ggplot(data = sahp, mapping = aes(x = lot_area, y = sale_price, color = kit_qual)) + geom_point(mapping = aes(color = gar_car &gt; 1)) + geom_smooth(mapping = aes(color = gar_car &gt; 1)) Here, you can see that the color aesthetic mapping corresponding to the logical variable gar_car &gt; 1. It is worth to note the difference between global aesthetics (introduced in Section 4.3) and the global aesthetic mappings introduced here. The global aesthetics set the aesthetic for all points/lines on the graph while the global aesthetic mapping represents the mapping which will be passed to all geoms. Although we can set global aesthetic mappings, it is impossible to set global global aesthetics. Let’s try to set all points and lines to be red. ggplot(data = sahp, mapping = aes(x = lot_area, y = sale_price), color = &quot;red&quot;) + geom_point() + geom_smooth() As you can see the color = \"red\" argument was ignored during the plotting process. To achieve this, you need to use color = \"red\" as global aesthetics for both geoms as below. ggplot(data = sahp, mapping = aes(x = lot_area, y = sale_price)) + geom_point(color = &quot;red&quot;) + geom_smooth(color = &quot;red&quot;) 4.6.3 Mix As you may have expected, it is straightforward to mix global aesthetic mappings, local aesthetic mappings, and global aesthetics for each geom. ggplot(data = remove_missing(sahp, vars = &quot;kit_qual&quot;), mapping = aes(x = liv_area, y = sale_price, color = kit_qual)) + geom_point(mapping = aes(shape = house_style == &quot;2Story&quot;), size = 2) + geom_smooth(linetype = 2, se = FALSE) Note that we again use the remove_missing() function to remove observations with missing kit_qual. 4.6.4 Exercises Using the sahp dataset with the ggplot2 package, and using global and local mappings to answer the following questions. Create a plot of liv_area (on the x-axis) and sale_price (on the y-axis) that contains both the scatterplot and the smoothline fit. In the plot from Q1, using different colors for both the scatterplot and the smoothline fit to distinguish whether the house has more than 3 bedrooms and make all points to be size 2. If you run the following code ggplot(data = sahp, mapping = aes(x = liv_area, y = sale_price), color = \"green\") + geom_point() + geom_smooth(), do you think all the points and the smoothline will be green? If not, explain the reason and make them green. If you run ggplot(data = sahp, mapping = aes(x = liv_area, y = sale_price, color = house_style)) + geom_point(mapping = aes(color = bedroom &gt; 3)) + geom_smooth(mapping = aes(color = bedroom &gt; 3)), explain why you only see two colors in the plot? "],["line-plot.html", "4.7 Line Plots", " 4.7 Line Plots In this section, we will introduce the line plot, which is very useful for visualizing trends and often used in time series. In the sahp dataset, it would be interesting to generate a plot showing the trend of the sale price as a function of the sold date of the house. 4.7.1 Line Plots via plot() To generate a line plot, you can use the plot() function by setting the argument type = \"l\". Before calling the plot() function, you need to first sort the observations (in Section 2.4) according to the variable on the x-axis, which is dt_sold in this example. library(r02pro) dt_sold_order &lt;- order(sahp$dt_sold) plot(sahp$dt_sold[dt_sold_order], sahp$sale_price[dt_sold_order], type = &quot;l&quot;, xlab = &quot;Date Sold&quot;, ylab = &quot;Sale Price&quot;) The plot() works by first getting the location of the value pairs of dt_sold and sale_price. Then, connect the points in the order of the observations. In the line plots, we would like to introduce two additional graphical parameters we can customize in the plot() function. Parameter Meaning Example lty The line type “dashed” lwd The line width 2 The line type can be either a integer from 0 to 6, or the corresponding character string in the following table. Intgers Strings lty = 0 “blank” lty = 1 “solid” lty = 2 “dashed” lty = 3 “dotted” lty = 4 “dotdash” lty = 5 “longdash” lty = 6 “twodash” Let’s see an example with the two parameters. plot(sahp$dt_sold[dt_sold_order], sahp$sale_price[dt_sold_order], type = &quot;l&quot;, xlab = &quot;Date Sold&quot;, ylab = &quot;Sale Price&quot;, lty = 2, lwd = 2) The plot() function also offers the capability to show the points and line on the same plot by changing type = \"b\". plot(sahp$dt_sold[dt_sold_order], sahp$sale_price[dt_sold_order], type = &quot;b&quot;, xlab = &quot;Date Sold&quot;, ylab = &quot;Sale Price&quot;) 4.7.2 Line Plots via geom_line() In addition to the plot() function, we can use the geom_line() function in the ggplot family. library(r02pro) library(tidyverse) ggplot(data = sahp) + geom_line(mapping = aes(x = dt_sold, y = sale_price)) The generated line plot looks essentially the same as that generated by plot(). It is worth noting that here, the points are connected not by the order of the observations, but by the variable on the x-axis, i.e. dt_sold, which avoids the need to sort the observations by the x-axis. To get a better view on how geom_line() works, let’s focus on the houses that were sold before 2007. sahp_2006 &lt;- sahp[format(sahp$dt_sold, &quot;%Y&quot;) &lt; 2007, ] #all houses sold before 2007 ggplot(data = sahp_2006) + geom_line(mapping = aes(x = dt_sold, y = sale_price)) Next, we add the scatterplot onto the plot using the global mappings. ggplot(data = sahp_2006, mapping = aes(x = dt_sold, y = sale_price)) + geom_line() + geom_point() 4.7.3 Aesthetics in Line Plots As expected, we can also map variables to aesthetics in line plots. ggplot(data = sahp) + geom_line(mapping = aes(x = dt_sold, y = sale_price, color = kit_qual)) Here, the observations are divided into groups according to the value of kit_qual and separate line plots are generated for each group, representing as different colors. In addition, we can also map variables to the linetype aesthetic as in the geom_smooth() function. ggplot(data = sahp) + geom_line(mapping = aes(x = dt_sold, y = sale_price, linetype = kit_qual)) In addition to mapping aesthetics, you can also set global aesthetics as before. ggplot(data = sahp) + geom_line(mapping = aes(x = dt_sold, y = sale_price ), color = &quot;blue&quot;, linetype = 3) 4.7.4 Exercises First, create a data set sahp_2006 by running the following code sahp_2006 &lt;- sahp[format(sahp$dt_sold, &quot;%Y&quot;) &lt; 2007, ] #all houses sold before 2007 Then, use sahp_2006 to answer the following questions. Using plot() to create a line plot of dt_sold (on the x-axis) and sale_price (on the y-axis) to show the trend of the sale price as a function of the sold date of the house, then give title “DS” for the x-axis and title “SP” for the y-axis and make the line to be a “twodash” line. Using the ggplot2 package to create a line plot of dt_sold (on the x-axis) and sale_price (on the y-axis) with different linetypes depending on the value of house_style. "],["add-auxiliary.html", "4.8 Add Auxiliary Lines", " 4.8 Add Auxiliary Lines Having learned how to generate scatterplots, smoothline fits, and line plot, it is sometimes helpful to add auxiliary lines to existing plots to provide additional information. 4.8.1 Using abline() with plot() Let’s first review the scatterplot between liv_area and sale_price. library(r02pro) plot(sahp$liv_area, sahp$sale_price) In this plot, you may want to add some auxiliary lines. You can use the function abline() after a call of plot() to do this. To add a vertical line, you can set the parameter v; to add a horizontal line, you can set the parameter h. plot(sahp$liv_area, sahp$sale_price) abline(v = 2000, col = &quot;purple&quot;) ##Add a vertical line at liv_area = 2000 plot(sahp$liv_area, sahp$sale_price) abline(h = 300, col = &quot;blue&quot;) ##Add a horizontal line at sale_price = 2000 Note that the v and h arguments can also be vectors with more than one values, which will lead to multiple vertical or horizontal lines. The corresponding argument col can also be a vector with multiple values. plot(sahp$liv_area, sahp$sale_price) abline(h = c(100, 200, 300), col = c(&quot;red&quot;,&quot;blue&quot;,&quot;green&quot;)) ##Add multiple horizontal lines In addition to adding vertical lines and horizontal lines, you can also add any line with the abline() function. We know a line can be represented as a function \\(y = a + b\\times x\\), where \\(a\\) is the intercept and \\(b\\) is the slope. In the abline(), you can generate such a line by specifying the parameter a for the intercept and b for the slope. Note that you can run abline() multiple times to add multiple lines. plot(sahp$liv_area, sahp$sale_price) abline(h = 300, col = &quot;blue&quot;) abline(a = 100, b = 0.1, col = &quot;green&quot;) 4.8.2 Using geom_hline(), geom_vline() and geom_abline() Let’s first review the following scatterplot between liv_area and sale_price. library(r02pro) library(tidyverse) ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) Looking at the scatterplot, it maybe helpful to add a horizontal line. To do this, you can use the geom_hline() function with argument yintercept specifying the value on the y-axis. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) + geom_hline(yintercept = 300, color = &quot;red&quot;) Here, a horizontal line at 300 is added to the scatterplot. You can also add both vertical lines and horizontal lines to the same plot. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) + geom_vline(xintercept = 2000, color = &quot;green&quot;) + geom_hline(yintercept = 300, color = &quot;red&quot;) In addition to adding vertical lines and horizontal lines, you can also add any line with the geom_abline() function. We know a line can be represented as a function \\(y = a + b\\times x\\), where \\(a\\) is the intercept and \\(b\\) is the slope. In the geom_abline(), you can generate such a line by specifying the slope and intercept arguments. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) + geom_abline(slope = 0.1, intercept = 100, color = &quot;blue&quot;) Similar to smoothline fit and line plots, you can change line type here. Different numbers correspond to different line types. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) + geom_abline(slope = 0.1, intercept = 100, linetype = 3) 4.8.3 Exercises Using the sahp data, using plot() to generate a scatterplot between lot_area (x-axis) and sale_price (y-axis), and add horizontal lines at 150 with color “blue” and 200 with color “red.” Using the sahp data, using ggplot() to generate a scatterplot between sale_price (x-axis) and liv_area (y-axis), and add the following lines to the plot: \\(y = 5\\times x + 1000\\) (in green color, dashed line) \\(y = 3\\times x + 1500\\) (in purple color, solid line) "],["jitter-count.html", "4.9 Jitter and Count Plots", " 4.9 Jitter and Count Plots We have seen that scatterplot is a useful tool to visualization the relationship between two continuous variables. You may be wondering what will happen if we use it on two discrete variables. 4.9.1 Overplotting As an example, let’s generate a scatterplot between kit_qual and heat_qual. library(r02pro) library(tidyverse) ggplot(data = sahp) + geom_point(mapping = aes(x = kit_qual, y = heat_qual)) #overplotting From the plot, you may immediately realize that there are many overlapping data points. Actually, there will be at most 16 possible distinct points on the plot since both variables have 4 categories. This phenomenon is called overplotting. Overplotting is not desirable since it hides useful information about the joint distribution. For example, we don’t know which value pairs out of the 16 possibilities appear more frequently in the data. To solve the overplotting issues, we introduce two solutions, namely jittering and count plots. 4.9.2 Jittering The first method for solving the overplotting issue is to add a small random perturbation to all datapoints, i.e., jittering. You can use the geom_jitter() function which works by first perturb the data points and then generate a scatterplot. ggplot(data = sahp) + geom_jitter(mapping = aes(x = kit_qual, y = heat_qual)) For the jittered plot, we can clearly see which pair of kit_qual and heat_qual have more observations. By default, the perturbation will be performed both vertically and horizontally with the same amount of 40% of the resolution of the data. To customize the amount of jittering, you can specify the arguments width as the amount of horizontal jittering and height as the amount of vertical jittering in the unit of the resolution of the data. To turn off the horizontal jittering, you can specify width = 0. ggplot(data = sahp) + geom_jitter(mapping = aes(x = kit_qual, y = heat_qual), width = 0.1, height = 0.1) 4.9.3 Counts Plots When we want to visualize the distribution of a pair of discrete variables, another method to solve the overplotting issue is the counts plot, which uses circles of different sizes to represent the frequency of each value pair. You can use the function geom_count() to generate a counts plot. ggplot(data = sahp) + geom_count(mapping = aes(x = kit_qual, y = heat_qual)) From this plot, you can clearly tell the frequency of each value pair by the legend showing the relationship between the size of the circle and the count. 4.9.4 Exercises For the sahp dataset, answer the following questions. Create a scatterplot between bedroom and bathroom. What problem do you think this plot have? Provide two different plots to address this issue. "],["bar-charts.html", "4.10 Bar Charts via geom_bar()", " 4.10 Bar Charts via geom_bar() For visualizing the relationship between two continuous variables, we have been learned various kinds of plots, including scatterplot (Sections 4.2 and 4.3), smoothline fit (Section 4.4), and line plot (Section 4.7). In this section, we will introduce a new kind of plot called bar chart. A bar chart uses rectangular bars with heights or lengths proportional to the values they represent, in order to visualize a discrete variable. 4.10.1 An Introduction to Bar Chart In the sahp dataset, you may be interested in the distribution of kitchen quality of the house (denoted in the kit_qual variable). To generate a bar chart, you can use the function geom_bar(). library(ggplot2) library(r02pro) ggplot(data = sahp) + geom_bar(mapping = aes(x = kit_qual)) In the bar chart, the x-axis displays different values of kit_qual, and the y-axis displays the number of observations with each kit_qual value. To verify this, let’s check how many house have kit_qual equals Excellent. sum(sahp$kit_qual == &quot;Excellent&quot;) #&gt; [1] 14 We can see the answer 14 matches the value on the bar chart. You may have noticed that the y-axis count is not a variable in sahp! This is also the reason that we don’t need to specify the y argument in the aes() function. In this sense, bar charts are very different from many other graphs like scatterplots, which plot the raw values of datasets. Sometimes, we would like to find out the proportion for each value of x, then we can display a bar chart of proportion, rather than count. To do this, we need to add y = stat(prop) and group = 1 as additional arguments in the aes() function. The stat(prop) is a statistical function used to calculate proportions. The group = 1 implies that all the observations belong to one single group when calculating the proportions. We will try to set group to another variable in the next part. ggplot(data = sahp) + geom_bar(mapping = aes(x = kit_qual, y = stat(prop), group = 1)) 4.10.2 Reordering Bars in Bar Charts In our bar chart example, the bars are ordered alphabetically. Sometimes, we may want to reorder the bars according to certain criterion. a. Reorder in ascending/descending order of heights To order the bars in ascending/descending order of their heights, you can use the fct_reorder() function to reorder the factor. library(forcats) ggplot(data = sahp) + geom_bar(mapping = aes(x = fct_reorder(kit_qual, kit_qual, length))) #increasing order The above code reorders the bar chart to the increasing order of their heights. The fct_reorder() is a very powerful function used to record the levels of a factor. The function fct_reorder(.f, .x, .fun = median) has three arguments: .f: the discrete variable/factor to reorder .x: one variable .fun: the function to be applied to .x The levels of f are reordered so that the values of .fun(.x) are in ascending order. In our example, we reorder the levels of kit_qual such that the length of kit_qual is in ascending order, i.e. the bars are in ascending order of their heights. To reorder in descending order of heights, you can add and additional argument .desc = TRUE in the fct_reorder() function. ggplot(data = sahp) + geom_bar(mapping = aes(x = fct_reorder(kit_qual, kit_qual, length, .desc = TRUE))) #decreasing order b. Manual Reorder In addition to reordering according to certain function values, you can use the function fct_relevel() to manually reorder the bars in a bar chart. In our example of kit_qual, perhaps a common thought is to order the levels from the worst quality to the best quality. ggplot(data = sahp) + geom_bar(mapping = aes(x = fct_relevel(kit_qual, c(&quot;Average&quot;, &quot;Fair&quot;, &quot;Good&quot;, &quot;Excellent&quot;)))) As you can imagine, the second argument of fct_relevel() contains the desired order of the factors, which will be reflected in the order of the bars. 4.10.3 Aesthetics in Bar Charts As before, we can use aesthetics to control the appearance of bar charts. First, let’s look at a new aesthetic called fill, which fills the bar with different colors according to the value of the mapped variable (usually another discrete variable). Here, we want to look at the distribution of kit_qual for different values of central_air. ggplot(data = sahp) + geom_bar(mapping = aes(x = kit_qual, fill = central_air)) We can see that each bar is divided into stacked sub-bars with different colors. The different colors in each sub-bar correspond to the value of central_air. And the height of each sub-bar represents the count for the cases with a particular value of kit_qual and another value of central_air. Let’s verify the first bar. sum(sahp$kit_qual == &quot;Average&quot; &amp; sahp$central_air == &quot;Y&quot;) #&gt; [1] 74 Clear, the result matches the blue portion of the first bar. When we map a variable to the fill aesthetic, the appearance of different subbars can be customized using the position argument as a global aesthetic in geom_bar(). a. stacked bars The default value of the position argument is \"stack\", which generated a collection of stacked bars with different colors. ggplot(data = sahp) + geom_bar(mapping = aes(x = kit_qual, fill = central_air), position = &quot;stack&quot;) b. dodged bars Using the stacked bars, it is sometimes difficult to compare the counts for different subbars. To make the comparison easier, you can use position = \"dodge\". ggplot(data = sahp) + geom_bar(mapping = aes(x = kit_qual, fill = central_air), position = &quot;dodge&quot;) Now, the plot places the sub-bars beside one another, which makes it easier to compare individual counts for each combination of kit_qual and central_air. c. filled bars ggplot(data = sahp) + geom_bar(mapping = aes(x = kit_qual, fill = central_air), position = &quot;fill&quot;) position = \"fill\" works like stacking, but makes each set of stacked bars the same height. The y axis should be labeled as “proportion” rather than “count.” This makes it easier to compare proportions of different values of central_air for different values of kit_qual. For example, we can see that the proportion of central_air = TRUE is much higher for kit_qual = \"Good\" than that for kit_qual = \"Fair\". Lastly, you can also use the polar coordinates. ggplot(data = sahp) + geom_bar(mapping = aes(x = kit_qual)) + coord_polar() 4.10.4 Exercises Use the sahp data set to answer the following questions. Create a bar chart to represent the distribution of the number of available car spaces in the garage (gar_car). For the bar chart in Q1, divide each bar into sub-bars according to whether oa_qual &gt; 5. What findings do you have in this plot? For the bar chart in Q2, change the position of the sub-bar to reflect the proportion for oa_qual &gt; 5 for each value of gar_car. "],["customization-axes.html", "4.11 Customization of x and y Axes", " 4.11 Customization of x and y Axes In this section, we would like to digress a little bit to learn some possible customizations of the x and y axes. First, let’s review the scatterplot between liv_area and sale_price. library(ggplot2) library(r02pro) ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) 4.11.1 Customizing the Breaks on the x and y Axes In the above plot, the breaks on the x axis are 1000, 2000, and 3000. The breaks on the y axis are 100, 200, 300, 400, and 500. Sometimes, we may want to customize the breaks, e.g. to show a finer scale. To do this, we can use the scale_x_continous() and scale_y_continuous() functions. Both functions take an argument called breaks which is a numeric vector specifying the desired breaks on the x and y axes. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) + scale_x_continuous(breaks = seq(from = 500, to = 3500, by = 500)) + scale_y_continuous(breaks = seq(from = 50, to = 600, by = 50)) In this example, we have customized the breaks for liv_area to be a equally-spaced sequence from 500 to 3500 with increment 500, and the breaks for sale_price to be another equally-spaced sequence from 50 to 600 with increment 50. When the specified breaks do not cover the full range of the data, you will see the breaks changed but all the data points are still visible. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) + scale_y_continuous(breaks = seq(from = 300, to = 600, by = 50)) On the other hand, if the specified breaks go beyond the value of the data, ggplot() will only show the breaks values within the data range. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) + scale_x_continuous(breaks = seq(from = 500, to = 5000, by = 500)) + scale_y_continuous(breaks = seq(from = 200, to = 800, by = 50)) 4.11.2 Zoom In to a Specific Region of the Data Sometimes, you want to zoom in to the specific region of the data to see a finer detail. To do this, you can use the coord_cartesian() function with arguments xlim and ylim for specifying the desired region. Let’s say we want to focus on the houses with liv_area between 1000 and 2000. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) + coord_cartesian(xlim = c(1000, 2000)) Let’s narrow down further to only the houses with liv_area between 1000 and 2000, and sale_price between 200 and 300. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) + coord_cartesian(xlim = c(1000, 2000), ylim = c(200, 300)) 4.11.3 Plot with Transformed Variables and Log-scale Plot In some applications, instead of using the original variables, you may want to generate a plot with certain transformations of them. In our scatterplot, maybe we want to change the y-axis to the logarithm of the sale price. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = log10(sale_price))) The working mechanism is to first generate a temporary variable log10(sale_price) on the fly, and then generate a scatterplot between liv_area and the transformed variable. For this particular log10() transformation, an alternative is to generate a Log-scale Plot by setting the trans argument in the scale_y_continous() function. The log-scale plot is a popular way for displaying numerical data over a very wide range of values in a compact fashion. The default value of trans is \"identity\" meaning no transformation. There are many different trans choices including log, exp, log10, sqrt, and others. ggplot(data = sahp) + geom_point(mapping = aes(x = liv_area, y = sale_price)) + scale_y_continuous(trans = &quot;log10&quot;) This works in a very different way by change the scale of the y-axis. 4.11.4 Exercises Use the sahp data set to answer the following questions. Create a scatterplot between lot_area (x-axis) and sale_price (y-axis), with the breaks on the x-axis being an equally-spaced sequence from 0 to 40000 with increment 5000, and the breaks on the y-axis being (0, 200, 300, 550). For the plot in Q1, create a zoom-in plot where lot_area is between 10000 and 15000, and sale_price is between 200 and 300. For the plot in Q1, create a corresponding log-log plot, where both the x-axis and y-axis are in log-scale. "],["histogram.html", "4.12 Histograms", " 4.12 Histograms In Section 4.10, we learned how to use geom_bar() to generate bar charts for visualizing the distributions of discrete variables. You may be wondering, how about visualizing continuous variables? One popular plot is called histograms. Let’s again use the sahp housing price data set. 4.12.1 Using the hist() function To generate a histogram, you can simply use hist() with the variable as the argument. library(r02pro) hist(sahp$sale_price) On the x-axis, the histogram displays the range of values for the sale price. Then, the histogram divides the x-axis into bins with equal width, and a bar is erected over the bin with the y-axis showing the corresponding number of observations (called Frequency on the y-axis label). 4.12.2 Using the geom_histogram() function In addition to using the hist() function in base R. The geom_histogram() function in the ggplot2 package provides richer functionality. Let’s take a quick look. library(ggplot2) ggplot(data = sahp) + geom_histogram(mapping = aes(x = sale_price)) #&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. We could see a message, saying “stat_bin() using bins = 30” which implies the histogram has 30 bins by default. Next, we introduce three different ways to customize the bins. a. Use aesthetic bins. We can change the number of bins with the global aesthetic bins. ggplot(data = sahp) + geom_histogram(mapping = aes(x = sale_price), bins = 5) We can see that the histogram now has 5 bins and each bin has the same width. b. Use aesthetic binwidth. And from the message, another way to change the number of bins is to specify the binwidth, which is another global aesthetic. ggplot(data = sahp) + geom_histogram(mapping = aes(x = sale_price), binwidth = 1e2) c. Manually set the bins. If desired, you can manually set the bins via the breaks argument in the geom_histogram() function. ggplot(data = sahp) + geom_histogram(mapping = aes(x = sale_price), breaks = seq(from = 0, to = 600, by = 100)) The breaks argument is a numeric vector specifying how the bins are constructed. Let’s verify the height of the first bin. #verify the first bin count sum(sahp$sale_price &lt; 100) 4.12.3 Aesthetics in geom_histogram() Next, we introduce the aesthetics in histograms, which are very similar to those in bar charts. For example, we can map a variable to the fill aesthetic. ggplot(data = sahp) + geom_histogram(mapping = aes(x = sale_price, fill = house_style), bins = 5) We can see that like the bar chart, the bar for each bin is now divided into sub-bars with different colors. The different colors in each sub-bar correspond to the values of house_style. And the height of each sub-bar represents the count for the cases with the sale_price in this particular bin and the specific value of house_style. Just like geom_bar(), we have a global aesthetic called position, which does position adjustment for different sub-bars. The default position value is again \"stack\" if you don’t specify it. a. Stacked bars ggplot(data = sahp) + geom_histogram(mapping = aes(x = sale_price, fill = house_style), position = &quot;stack&quot;, bins = 5) As expected, we get the same histogram as before. b. Dodged bars The second option for position is \"dodge\", which places the sub-bars beside one another, making it easier to compare individual counts for the combination of a bin of sale_price and house_style. ggplot(data = sahp) + geom_histogram(mapping = aes(x = sale_price, fill = house_style), position = &quot;dodge&quot;, bins = 5) c. Filled bars Another option for optional is position = \"fill\". It works like stacking, but makes each set of stacked bars the same height. ggplot(data = sahp) + geom_histogram(mapping = aes(x = sale_price, fill = house_style), position = &quot;fill&quot;, breaks = seq(from = 0, to = 600, by = 100)) Just like geom_bar(), the y axis may be labeled as “proportion” rather than “count,” to be more precise. This makes it easier to compare proportions of different values of cut for different bins of price. For example, we can see that the proportion of house_style = \"1.5Fin\" is highest for the houses with sale price less than 100. 4.12.4 Density Estimate Using Histograms In addition to using histograms to visualize the distribution of a discrete variable, you can also construct a density density of variable using a proper normalization. To generate such a density estimate, you can add y = ..density.. as a mapping in the aes() function in geom_historgram(). Let’s see an example as below. ggplot(data = sahp) + geom_histogram(aes(x = sale_price, y = ..density..), breaks = seq(from = 0, to = 6e2, by = 1e2)) + scale_y_continuous(breaks = seq(from = 0, to = 7e-3, by = 1e-3)) Here, we added the breaks arguments on the bins as well as on the y-axis. Let’s try to calculate the height of the first bar together. We know that the total area of the bars is 1, agreeing with the definition of density. First, we get the area of the first bar. Then we divide it by the width to get the height. sale_price_no_na &lt;- na.omit(sahp$sale_price) sum(sale_price_no_na &lt; 1e2)/length(sale_price_no_na) #area of the first bar #&gt; [1] 0.1036585 sum(sale_price_no_na &lt; 1e2)/length(sale_price_no_na) /1e2 #height of the first bar #&gt; [1] 0.001036585 You can see that the height matches the y axis for the first bar. 4.12.5 Exercises Use the sahp data set to answer the following questions. Create histograms on the living area (liv_area) for each of the following settings Use 10 bins Set the binwidth to be 300 Se the bins manually to an equally-spaced sequence from 0 to 3500 with increment 500. Create histograms on the living area (liv_area) with 5 bins, and show the information of different kit_qual values in each bar. What conclusions can you draw from this plot? "],["density-plot.html", "4.13 Density Plots", " 4.13 Density Plots In Section 4.12, we have learned to use geom_histogram() as a way to visualize the distribution of a continuous variable. In addition, we can also use it to generate a piece-wise constant estimate of the probability density function. Today, we will introduce another visualization method for continuous data, namely the density plots. First, let’s review the geom_histogram() for estimating the density function. library(ggplot2) library(r02pro) ggplot(data = sahp) + geom_histogram(aes(x = sale_price, y = ..density..)) #&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. There are 30 bins by default. You may notice that this density estimate is not smooth, sometimes we may prefer a smoothed estimate. Then, we can use the geom_density() function to achieve this. ggplot(data = sahp) + geom_density(aes(x = sale_price)) This plot shows the so-called “kernel density estimate,” a popular way to estimate the probability density function from sample. The density estimate can be viewed as a smoothed version of the histogram. We can combine the two plots together using global mapping. ggplot(data = sahp, aes(x = sale_price)) + geom_histogram(aes(y = ..density..)) + geom_density(color = &quot;red&quot;, size = 2) #&gt; `stat_bin()` using `bins = 30`. Pick better value with `binwidth`. Here, we added some global aesthetics in geom_density() to make the density plot red and the line width by setting size = 2. It is clear that the density plot is a useful alternative to the histogram for visualizing continuous data. 4.13.1 Aesthetics in Density Plots Now, let’s introduce some commonly used aesthetics for density plots. a. Color ggplot(data = remove_missing(sahp, vars = &quot;oa_qual&quot;)) + geom_density(aes(x = sale_price, color = oa_qual &gt; 5)) Here, we divide the data into two groups according to the value of oa_qual, then generate separate density estimates with different colors for oa_qual &gt; 5 and oa_qual &lt;= 5. The blue curve represents the density estimates for larger values of oa_qual while the red curve corresponds to that of the houses with smaller values. b. Fill Another way to generate different density estimates is to use the fill aesthetic. Let’s see the following example. ggplot(data = remove_missing(sahp, vars = &quot;oa_qual&quot;)) + geom_density(aes(x = sale_price, fill = oa_qual &gt; 5)) The fill aesthetic also divides the data into groups according to oa_qual, then generate separate density estimates. The difference between fill and color aesthetics is that fill generates shaded areas below each density curve with different colors while color generates density curves with different colors. As we can see from the plot, there is a substantial overlap of the shaded areas. To fix this issue, we can change the transparency of the shades by adjusting the value of the alpha aesthetic. ggplot(data = remove_missing(sahp, vars = &quot;oa_qual&quot;)) + geom_density(aes(x = sale_price, fill = oa_qual &gt; 5), alpha = 0.5) We can now see both shaded areas in a clearly way. c. Linetype We can also use different linetypes for different curves. ggplot(data = remove_missing(sahp, vars = &quot;oa_qual&quot;)) + geom_density(aes(x = sale_price, linetype = oa_qual &gt; 5)) d. Global aesthetics As usual, we can also set global aesthetics for geom_density() and combine it with the mapped aesthetics. ggplot(data = remove_missing(sahp, vars = &quot;oa_qual&quot;)) + geom_density(aes(x = sale_price, linetype = oa_qual &gt; 5), size = 1, color = &quot;red&quot;) Here, the size controls the width of the density curve. 4.13.2 Exercises Use the sahp data set to answer the following questions. Create density plot on the living area (liv_area) with dashed lines and different colors for different values of kit_qual. What conclusions can you draw from the plot? Try to create density plot for kit_qual. Do you think this plot is informative? If not, create a plot that captures the distribution of kit_qual. "],["boxplots.html", "4.14 Boxplots", " 4.14 Boxplots So far, we have learned two ways to visualize a continuous variable, namely the histograms (Section 4.12) and density plots (Section 4.13). Now, we introduce another popular plot for visualizing the distribution of a continuous variable, namely the boxplot. Let’s say we want to generate a boxplot for the variable sale_price in the sahp dataset. 4.14.1 Using the boxplot() function To generate a boxplot, you can just use boxplot() with the variable as the argument. library(r02pro) sale_price &lt;- na.omit(sahp$sale_price) boxplot(sale_price) The boxplot compactly summarize the distribution of a continuous variable by visualizing five summary statistics (the median, two hinges, and two whiskers), and show all “outlying” points individually. All five summary statistics on the boxplot are related to the summary statistics we learned in Section 2.5. Let’s first review the summary function and the inter quartile range (IQR). summary(sale_price) #&gt; Min. 1st Qu. Median Mean 3rd Qu. Max. #&gt; 44.0 130.0 157.9 179.9 201.6 545.2 IQR(sale_price) #&gt; [1] 71.6125 Let’s discuss the five lines on the boxplot. The solid line in the middle represents the median value, which is 157.95. The lower solid line, also known as the lower hinge, is the first quartile Q1 = 129.9625. The upper solid line, also known as the upper hinge, is the third quartile Q3 = 201.575. The lower whisker is the smallest observation value that is greater than or equal to Q1 - 1.5 * IQR. To find this value, we first calculate Q1 - 1.5 * IQR = 22.54375. Then, the smallest observation larger than 22.54375 is lower_whisker_loc &lt;- which.min(sale_price &gt;= quantile(sale_price, 0.25) - 1.5 * IQR(sale_price)) sale_price[lower_whisker_loc] #&gt; [1] 130.5 The upper whisker is the largest observation value that is smaller than or equal to Q3 + 1.5 * IQR. Similarly, the value is upper_whisker_loc &lt;- which.max(sale_price &gt;= quantile(sale_price, 0.75) + 1.5 * IQR(sale_price)) sale_price[upper_whisker_loc] #&gt; [1] 344.133 To summarize, the five lines on the boxplot, from the top to bottom, are upper whisker (&lt;= Q3 + 1.5*IQR) upper hinge (Q3) median (50-th percentile) lower hinge (Q1) lower whisker (&gt;= Q1 - 1.5*IQR) For the observations that are larger than the upper whisker or smaller than the lower whisker, the points are shown individually as outliers. 4.14.2 Using the geom_boxplot() function As before, we will spend more time to discuss geom_boxplot() as it provides more functionality. Let’s first create the boxplot for sale_price. library(tidyverse) ggplot(data = sahp) + geom_boxplot(aes(x = &quot;&quot;, y = sale_price)) Note that here we set x = \"\" since no information is needed on the x-axis. In addition to the default summary statistics, we can add other values to the boxplot, for example, we can add the mean value to the plot. ggplot(data = sahp, aes(x = &quot;&quot;, y = sale_price)) + geom_boxplot() + geom_point(stat = &quot;summary&quot;, fun = &quot;mean&quot;, shape = 20, size = 4, color = &quot;red&quot;) The geom_point() function will first calculate the mean hwy, and add it to the boxplot. Note that we used some global aesthetics for geom_point(). 4.14.3 Compare distributions in different groups One common use of boxplot is to compare the distribution of a continuous variable in different groups. To do this, you just need to set the x-axis to be the discrete variable that encodes the different groups. Let’s say we want to compare the sale_price for houses with different kit_qual. ggplot(data = sahp) + geom_boxplot(aes(x = kit_qual, y = sale_price)) This plot shows the boxplots of sale_price for different values of kit_qual side-by-side, which makes the comparison of distributions straightforward. Just like in bar charts, you may want to arrange the boxplots in a particular order. For example, to order the boxplots in ascending order of the sale_price, you can use ggplot(data = remove_missing(sahp, vars = &quot;sale_price&quot;)) + geom_boxplot(aes(x = fct_reorder(kit_qual, sale_price, median), y = sale_price)) To order it by the mean sale_price in descending order, you can use ggplot(data = remove_missing(sahp, vars = &quot;sale_price&quot;)) + geom_boxplot(aes(x = fct_reorder(kit_qual, sale_price, mean, .desc = TRUE), y = sale_price)) If you want to generate a flipped version of the boxplot, you can add coord_flip() to the ggplot() function. Actually, this works with any ggplot. ggplot(data = sahp) + geom_boxplot(aes(x = kit_qual, y = sale_price)) + coord_flip() As an alternative, you can also switch the x and y arguments. ggplot(data = sahp) + geom_boxplot(aes(x = sale_price, y = kit_qual)) Now, you have learned how to compare the distributions of a continuous variable for different groups implied by a discrete variable. How about groups implied by a continuous variable? To do this, you can use the function cut_width() to convert a continuous variable to a discrete one by dividing the observations into different groups, just like in histograms. Let’s try to convert the continuous variable oa_qual into a discrete one. cut_width(sahp$oa_qual, width = 2) #&gt; [1] (5,7] (5,7] (3,5] (3,5] (5,7] (5,7] (5,7] (3,5] (3,5] (3,5] #&gt; [11] (5,7] (5,7] (3,5] (7,9] (5,7] (3,5] (3,5] (3,5] (5,7] (5,7] #&gt; [21] (3,5] (7,9] (7,9] &lt;NA&gt; (5,7] (3,5] (3,5] (3,5] (3,5] (7,9] #&gt; [31] (7,9] (7,9] (5,7] (7,9] (5,7] (3,5] (5,7] (5,7] (3,5] (3,5] #&gt; [41] (9,11] (3,5] (3,5] (3,5] (7,9] (3,5] (5,7] (3,5] (5,7] (5,7] #&gt; [51] (3,5] (5,7] (5,7] (3,5] (5,7] (5,7] (7,9] (7,9] (3,5] (5,7] #&gt; [61] (5,7] (5,7] (5,7] (5,7] (3,5] (3,5] (5,7] (5,7] (3,5] (5,7] #&gt; [71] (5,7] (3,5] (7,9] (5,7] (3,5] (7,9] (7,9] (3,5] [1,3] (5,7] #&gt; [81] (5,7] (5,7] (3,5] (5,7] (5,7] (3,5] (3,5] (5,7] (3,5] (3,5] #&gt; [91] (7,9] (5,7] (5,7] (5,7] (5,7] (3,5] (5,7] (3,5] (9,11] (5,7] #&gt; [101] (5,7] (7,9] (3,5] (5,7] (3,5] (5,7] (5,7] (3,5] (3,5] (5,7] #&gt; [111] (5,7] (5,7] (7,9] (7,9] (7,9] (5,7] (7,9] (5,7] (5,7] (5,7] #&gt; [121] (5,7] (5,7] (3,5] (3,5] (5,7] (5,7] (3,5] (7,9] (5,7] (5,7] #&gt; [131] (3,5] (7,9] (5,7] (5,7] (5,7] (5,7] (5,7] [1,3] (3,5] (5,7] #&gt; [141] (3,5] (5,7] (5,7] (3,5] (3,5] (3,5] (3,5] (3,5] (3,5] (5,7] #&gt; [151] (7,9] (7,9] (3,5] (5,7] (7,9] [1,3] (7,9] (7,9] (5,7] (5,7] #&gt; [161] (7,9] (5,7] (3,5] (5,7] (3,5] #&gt; Levels: [1,3] (3,5] (5,7] (7,9] (9,11] The working mechanism of cut_width() is that it makes groups of width width and create a factor with the levels be the different groups. For example, the first observation has oa_qual = 6, belong to the (5,7] group. Note there are also functions cut_interval() and cut_number() which also discretise continuous variable into a discrete one by making groups with equal range and equal number of observations, respectively. Now, you can compare the distributions of a continuous variable on the constructed groups from another continuous variable. ggplot(data = remove_missing(sahp, vars=&quot;oa_qual&quot;)) + geom_boxplot(aes(x = cut_width(oa_qual, width = 2), y = sale_price)) This agrees perfectly with our intuition that houses with higher overall quality have higher sale prices. 4.14.4 Map aesthetics to boxplot Before talking about aesthetics, let’s create a boxplot of sale_price for different values of house_style. ggplot(data = na.omit(sahp), aes(x = house_style, y = sale_price)) + geom_boxplot() + scale_x_discrete(limits=c(&quot;1Story&quot;, &quot;2Story&quot;)) Note that we only show the two boxplots with house_style equaling \"1Story\" or \"2Story\". To simply the codes, it is sometimes helpful to store the intermediate plot object and build additional plots on top of it. For example, we can generate the same boxplot using the following two steps. g &lt;- ggplot(data = na.omit(sahp), aes(x = house_style, y = sale_price)) + scale_x_discrete(limits=c(&quot;1Story&quot;, &quot;2Story&quot;)) g + geom_boxplot() a. map the grouping variable to color First, let’s try to map the variable house_style to the color aesthetic. g + geom_boxplot(mapping=aes(color = house_style)) We can see that the boxplots have different colors according to the value of house_style. b. map the grouping variable to fill You can also use the fill aesthetic to fill in the boxes with different colors according to the value of house_style. g + geom_boxplot(mapping=aes(fill = house_style)) c. map a third variable to color So far, we have only mapped the discrete variable on the x-axis to the aesthetic. You can map a third variable to an aesthetic if a further refined comparision is needed. Let’s try to map the oa_qual &gt; 5 to color. g + geom_boxplot(mapping=aes(color = oa_qual &gt; 5)) You will get a boxplot for each combination of house_style and oa_qual grouped by the variable house_style, just like when we create the bar charts in Section 4.10. As before, you can also cut a continuous variable and map it to aesthetic. g + geom_boxplot(mapping=aes(color = cut_width(oa_qual, 2))) d. map a third variable to fill Similarly, you can also map the variable to the fill aesthetic. g + geom_boxplot(mapping=aes(fill = oa_qual &gt; 5)) e. global aesthetics In addition to mapping variables to aesthetics, you can also use global aesthetics in boxplot. For example, to make the box green and the lines and points red, you can use g + geom_boxplot(fill = &quot;green&quot;, color = &quot;red&quot;) If you want to change the shape and size of the outliers, you can set the arguments outlier.shape and outlier.size. g + geom_boxplot(outlier.color = &quot;green&quot;, outlier.shape = 2, outlier.size = 3) 4.14.5 Notched Boxplots In addition to the regular boxplot, there is a more sophiscated version, called notched boxplot. We can generate such a boxplot by setting the global aesthetic notch = TRUE in the geom_boxplot() function. ggplot(data = sahp) + geom_boxplot(aes(x = &quot;&quot;, y = sale_price), notch = TRUE) In a notched box plot, a notch is generated around the median, with the vertical width on each side being 1.58 times IQR divided by the squared root of the sample size: \\(1.58 * IQR / sqrt(n)\\). This gives a roughly 95% confidence interval for the median. As a result, if the notches of two boxplots do not overlap, it offers evidence of a statistically significant difference between the two medians. In this example, the upper and lower points of the notch are median(sale_price) + 1.58*IQR(sale_price)/sqrt(length(sale_price)) #&gt; [1] 166.7854 median(sale_price) - 1.58*IQR(sale_price)/sqrt(length(sale_price)) #&gt; [1] 149.1146 4.14.6 Exercises Use the sahp data set to answer the following questions. Create a boxplot on the living area (liv_area) and find out the following values on the boxplot using R codes. solid line in the middle lower hinge upper hinge lower whisker upper whisker Create a boxplot to compare the distribution of living area (liv_area) for different values of kitchen quality (kit_qual). What conclusions can you draw from the plot? For the boxplot in Q2, for different kit_qual values, add the following three points to the plot. minimum liv_area value (in red) maximum liv_area value (in blue) the mean liv_area value (in green) For the boxplot in Q2, order it by the mean lot_area value in ascending order. For the boxplot in Q2, use different colors to represent whether oa_qual is larger than 5. "],["violin.html", "4.15 Violin Plots", " 4.15 Violin Plots In this section, we introduce how to combine music with R via creating violin plots. In fact, the violin plot elegantly combines boxplot (Section 4.14) and density plots (Section 4.13) into a single plot. 4.15.1 The basic violin plot Let’s say we want to generate a basic violin plot for the variable sale_price in the sahp dataset. library(r02pro) library(ggplot2) ggplot(data = sahp, aes(x = &quot;&quot;, y = sale_price)) + geom_violin() To introduce the detail of the generation process of violin plot, it is helpful to review the density plot. ggplot(data = sahp, aes(y = sale_price)) + geom_density() Looking at these two plots, it is easy to see that the basic violin plot is nothing but a Mirrored Density plot with the kernel density estimates on each side. 4.15.2 Violin plot with boxplot Usually, the violin plot includes the boxplot inside it, providing extra information about the data. To do this, we just add the boxplot layer on top of the violin plot. ggplot(data = sahp, aes(x = &quot;&quot;, y = sale_price)) + geom_violin() + geom_boxplot(width = 0.1) Here, we set the aesthetic width = 0.1 in the boxplot to make it thinner. Just like in the boxplot, we can compare the distributions of a continuous variable for different values of a discrete variable. We can achieve this by mapping the discrete variable to the x axis. ggplot(data = sahp, aes(x = house_style, y = sale_price)) + geom_violin() + geom_boxplot(width = 0.1) We can restrict the x-axis to a subset of the possible house_style values. ggplot(data = sahp, aes(x = house_style, y = sale_price, color = house_style)) + geom_violin() + geom_boxplot(width = 0.1) + scale_x_discrete(limits=c(&quot;1Story&quot;, &quot;2Story&quot;)) Similarly, we can map a third variable to an aesthetic. ggplot(data = remove_missing(sahp, vars=&quot;oa_qual&quot;), aes(x = house_style, y = sale_price, fill = oa_qual &gt; 5)) + geom_violin() + geom_boxplot(width = 0.1) + scale_x_discrete(limits=c(&quot;1Story&quot;, &quot;2Story&quot;)) As you can see, the boxplot doesn’t align well inside the violin plot. To fix this issue, you can add the global aesthetic position = position_dodge(0.9) to both geoms. ggplot(data = remove_missing(sahp, vars=&quot;oa_qual&quot;), aes(x = house_style, y = sale_price, fill = oa_qual &gt; 5)) + scale_x_discrete(limits=c(&quot;1Story&quot;, &quot;2Story&quot;)) + geom_violin(position = position_dodge(0.9)) + geom_boxplot(width = 0.1, position = position_dodge(0.9)) You can also try to add other global aesthetics to both geoms to change their appearances. ggplot(data = sahp, aes(x = house_style, y = sale_price, fill = house_style)) + geom_violin(color = &quot;green&quot;, size = 2) + geom_boxplot(width = 0.1, color = &quot;blue&quot;, size = 1) + scale_x_discrete(limits=c(&quot;1Story&quot;, &quot;2Story&quot;)) "],["errorbar.html", "4.16 Error Bars", " 4.16 Error Bars So far, we have learned several ways to compare continuous distributions for different groups, including the density plot, boxplot, and the violin plot. In this lesson, we introduce another visualization method, called error bar, which is a graphical representations of the uncertainty in a certain measurement. Let’s prepare a ggplot object to get started. library(r02pro) library(ggplot2) g &lt;- ggplot(data = sahp, aes(x = house_style, y = sale_price)) + scale_x_discrete(limits=c(&quot;1Story&quot;, &quot;2Story&quot;)) Here, we visualize the error bar as the mean \\(\\pm\\) standard error. To show the mean of sale_price for different house_style groups, you can use the geom_point() function with arguments stat = \"summary\" and fun = \"mean\". g + geom_point(stat = &quot;summary&quot;, fun = &quot;mean&quot;) To add error bars to the mean points, we use geom_errorbar() coupled with the fun.data = \"mean_se\" argument. g + geom_point(stat = &quot;summary&quot;, fun = &quot;mean&quot;) + geom_errorbar(stat = &quot;summary&quot;, fun.data = &quot;mean_se&quot;) You can control the width of the errorbar by setting the width argument. g + geom_point(stat = &quot;summary&quot;, fun = &quot;mean&quot;) + geom_errorbar(stat = &quot;summary&quot;, fun.data = &quot;mean_se&quot;, width = 0.2) This plot is called a mean-error-bar plot. Let’s take a detailed look at this plot. The distance from the mean point to the lower bound of the error bar is the so called standard error, which is defined as the standard deviation of the sample divided by the square root of the sample size. Let’s try to calculate the upper and lower bounds of the error bar. sale_price_1_story &lt;- sahp$sale_price[sahp$house_style == &quot;1Story&quot;] sale_price_1_story_se &lt;- sd(sale_price_1_story)/sqrt(length(sale_price_1_story)) mean(sale_price_1_story) + sale_price_1_story_se #&gt; [1] 192.251 mean(sale_price_1_story) - sale_price_1_story_se #&gt; [1] 173.8044 You may notice that we are referring the data as sample since the sahp dataset contains only a subset of the population with all houses in the world. An important application of error bar is to construct the 95% confidence interval of the population mean. You know that the 95% confidence interval for a normal distribution is mean \\(\\pm\\) 1.96*se. If the data follows a normal distribution, you can construct such a confidence interval by setting the multiplier of the standard error in the error bar to be 1.96. g + geom_point(stat = &quot;summary&quot;, fun = &quot;mean&quot;) + geom_errorbar(stat = &quot;summary&quot;, fun.data = &quot;mean_se&quot;, width = 0.2, fun.args = list(mult = 1.96)) Of course, you can also add the error bar on top of the other plots like the boxplot or violin plot. g + geom_point(stat = &quot;summary&quot;, fun = &quot;mean&quot;) + geom_boxplot() + geom_errorbar(stat = &quot;summary&quot;, fun.data = &quot;mean_se&quot;, width = 0.2) g + geom_point(stat = &quot;summary&quot;, fun = &quot;mean&quot;) + geom_violin() + geom_errorbar(stat = &quot;summary&quot;, fun.data = &quot;mean_se&quot;, width = 0.2) "],["arrange-multi-plots.html", "4.17 Arrange Multiple Plots", " 4.17 Arrange Multiple Plots So far, you have mastered many geoms, and you know one popular way to add the information of additional variables to a plot is mapping them to certain aesthetics. Another way to achieve this goal is to divide the data into different groups according to the additional variables, generate different plots for each group, and arrange the plots into facets. This is particularly useful for categorical variables. Let’s use the sahp dataset and generate a scatterplot for sale_price vs. liv_area and save it as g. library(ggplot2) library(r02pro) g &lt;- ggplot(data = na.omit(sahp)) + geom_point(mapping = aes(x = liv_area, y = sale_price)) 4.17.1 Facet wrap The first function is called facet_wrap(), which generate separate plots for each category and wrap the plots into 2d panels. Let’s first divide to data according to oa_qual. g + facet_wrap(&quot;oa_qual&quot;) You can see that there are nine different scatterplots between sale_price and liv_area according to the value of oa_qual. The scatterplots are nicely arranged in a 3-by-3 grid with the value of oa_qual on top of each subplot. Note that the scales of all nine plots are the same, which make it straightforward to compare between different groups. On the other hand, the points for some of the groups (e.g., oa_qual == 5) are scrambled together, making us difficult to see the details. To make the subplots having their own scales, you can set scales = \"free\". g + facet_wrap(&quot;oa_qual&quot;, scales = &quot;free&quot;) From the plot, it is clear that each subplot has its own scale depending on the data range in the subset of the data. If you want to make the subplots to have fixed scale only on the x-axis or the y-axis, you can set scales = \"free_y\" or scales = \"free_x\" respectively. In addition to the default layout, you can set the desired number of rows or columns. For example, to arrange the plots in two rows for the variable kit_qual, you can use g + facet_wrap(&quot;kit_qual&quot;, nrow = 2) In addition to using one variable to form the subgroups, you can also use multiple variables by using a vector of their names in the facet_wrap() function. g + facet_wrap(c(&quot;kit_qual&quot;,&quot;central_air&quot;)) This will show the plots for combinations of kit_qual and central_air. For example, the top left plot is the scatterplot between liv_area and sale_price for houses with kit_qual == \"Average\" and central_air == \"Y\". Let’s find out how many different values are there for kit_qual and central_air. unique(sahp$kit_qual) #&gt; [1] &quot;Good&quot; &quot;Average&quot; &quot;Fair&quot; &quot;Excellent&quot; unique(sahp$central_air) #&gt; [1] &quot;Y&quot; &quot;N&quot; Clearly, there are in total eight possible combinations of values for these two variables. Upon a careful look, you may realize there is no plot for kit_qual == \"Excellent\" and central_air == \"N\". The reason is due to the fact there are no houses satisfying both criteria. Let’s verify as follows. sum(sahp$kit_qual == &quot;Excellent&quot; &amp; sahp$central_air == &quot;N&quot;) #&gt; [1] 0 Note that the facet_wrap() function can be combined with any geoms we have learned. Let’s see an example of bar charts. a&lt;- ggplot(data = sahp) + geom_bar(mapping = aes(x = kit_qual)) a + facet_wrap(&quot;house_style&quot;) 4.17.2 Facet grid g + facet_grid(rows = vars(kit_qual), cols = vars(central_air)) In addition to facet wrap, you can also use the function facet_grid() to form a matrix of plots defined by row and column faceting variables. It is mostly useful when you have two discrete variables, and most combinations of the variables exist in the data. Comparing with the plot generated by facet_wrap(), facet_grid() will also show empty plots if there are no observations with certain combinations, e.g. kit_qual == \"Excellent\" and central_air == \"N\". This particular way to arrange plots is very informative. Similar to facet_wrap(), you can also allow the scales of each subplot to be different by setting the scales argument. g + facet_grid(rows = vars(kit_qual), cols = vars(central_air), scales = &quot;free&quot;) 4.17.3 Exercises Use the sahp data set to answer the following questions. Create a boxplot for liv_area and assign it to the name my_boxplot. Using my_boxplot in Q1, generate separate plots according to the value of bedroom. What conclusions can you draw from the plot? Using my_boxplot in Q1, generate a matrix of subplots with kitchen quality (kit_qual) as the row and whether the house has central ac (central_air) as the column. Do you see a subplot for all combinations of kit_qual and central_air? If not, explain the reason. "],["customization.html", "4.18 Customization of Labels and Titles", " 4.18 Customization of Labels and Titles In Section 4.11, we discussed the customization of the x and y axes in ggplot. Now, we will introduce other types of customization, and the concept of themes. Let’s first review the scatterplot we created between liv_area and sale_price and save it into as an object g. library(r02pro) library(tidyverse) g &lt;- ggplot(data = sahp, mapping = aes(x = liv_area, y = sale_price)) + geom_point() a. customize x and y labels and title By default, the x and y labels are the variables names, and there is no title for the plot. You can customize the x and y labels using the xlab() and ylab() function, and add a title with the ggtitle() function. g1 &lt;- g + xlab(&quot;Living Area&quot;) + ylab(&quot;Sale Price&quot;) + ggtitle(&quot;Price vs. Area&quot;) g1 b. customize the font of the x and y breaks In addition, you can further customize the font of the x and y breaks using the theme() function with the argument axis.text. g1 + theme(axis.text = element_text(size = 25, color = &quot;red&quot;)) c. customize the font of labels To customize the font, you can use axis.title argument to change the size, color, and face of the labels. g1 + theme(axis.title = element_text(size = 18, color = &quot;red&quot;, face = &quot;italic&quot;)) d. customize the font of the title Similarly, you can use the plot.title argument to customize the font of the title. g1 + theme(plot.title = element_text(size = 24, color = &quot;magenta&quot;, face = &quot;bold&quot;)) e. center the title Sometimes, we may want to center the title. We can achieve this by setting the hjust parameter. g1 + theme(plot.title = element_text(size = 24, color = &quot;magenta&quot;, face = &quot;bold&quot;,hjust = 0.5)) f. mix Apparently, you are free to mix all the different customizations. Let’s see an example as below. g1 + theme(axis.title = element_text(size = 18, color = &quot;red&quot;, face = &quot;italic&quot;), axis.text = element_text(size = 12, color = &quot;blue&quot;), plot.title = element_text(size = 24, color = &quot;magenta&quot;, face = &quot;bold&quot;, hjust = 0.5)) g. save as a theme As you can see from the code, the code gets complicated if we want to customize many things at the same time. To save time, you can actually save the desired into an R object and reuse it later. mytheme &lt;- theme(axis.title = element_text(size = 18, color = &quot;red&quot;, face = &quot;italic&quot;), axis.text = element_text(size = 12, color = &quot;blue&quot;), plot.title = element_text(size = 24, color = &quot;magenta&quot;, face = &quot;bold&quot;, hjust = 0.5)) Then, we can generate the same plot with mytheme using g1 + mytheme Similarly, you can add another layer of smoothline fit and apply mytheme. g1 + geom_smooth() + mytheme You may notice that title is not accurate. So, we want to change the title to reflect the addition of the smoothline fit. Let’s simply add another ggtitle() function to overwrite the existing one in the theme. g1 + geom_smooth() + mytheme + ggtitle(&quot;Scatterplot + smoothline&quot;) "],["summary-geom.html", "4.19 Summary of Geoms &amp; Grammatical Structure of ggplot()", " 4.19 Summary of Geoms &amp; Grammatical Structure of ggplot() In this section, we will have a concise review for using ggplot() to do data visualization. 4.19.1 Summarize all geoms First, let’s summarize all the geoms we have covered. #&gt; Error in library(kableExtra): there is no package called &#39;kableExtra&#39; #&gt; Error in pack_rows(., &quot;One continuous variable and one discrete variable (e.g. `kit_qual` and `sale_price`):&quot;, : could not find function &quot;pack_rows&quot; Note that in the summary, we are only using the basic geoms. Clearly, we can map variables to aesthetics or use facet_wrap() (in Section 4.17.1) or facet_grid() (in Section 4.17.2) to arrange the subplots into facets depending on the grouping variable(s). There are more than 40 geoms in the ggplot2 package with many more geoms developed in other packages. So far, we’ve covered the most commonly used geoms. You can feel free to explore other geoms by doing an online search or looking at the documentation. 4.19.2 The grammatical structure of ggplot() Next, we review the grammatical structure of ggplot(). #&gt; Error in loadNamespace(name): there is no package called &#39;kableExtra&#39; 4.19.3 A complex ggplot() example To conclude this chapter, let’s look at an example with all components. library(r02pro) library(tidyverse) ggplot(data = na.omit(sahp)) + geom_bar( mapping = aes(x = kit_qual, fill = oa_qual &gt; 5), stat = &quot;count&quot;, #Default stat for geom_bar, can be removed position = &quot;fill&quot;) + coord_flip() + facet_wrap(vars(house_style)) + scale_y_continuous(breaks = seq(from = 0, to = 1, by = 0.2)) + theme(plot.title = element_text(size = 24, color = &quot;magenta&quot;)) + ylab(&quot;proportion&quot;) + ggtitle(&#39;A bar chart for the sahp dataset&#39;) This plot shows a bar chart using the data sahp for the variable kit_qual, map the variable oa_qual &gt; 5 to the fill aesthetic and with fill position, with the x and y coordinates flipped, faceted using the variable house_style, and with the breaks on the y axis, the title and its font, the label on the y axis being customized. "],["import-export.html", "Chapter 5 Data Import and Export", " Chapter 5 Data Import and Export So far in this book, you have been creating objects by yourself or working with existing data in R packages. When working on a project, you often need to import existing data into R, or export the created object into a file on the computer. In this chapter, you will learn how to import and export data of different file types. "],["export-data.html", "5.1 Exporting Data to Delimited Files", " 5.1 Exporting Data to Delimited Files We will start by introducing how to export data to a file in this chapter. 5.1.1 Set the working directory Firstly, we will introduce an important concept of Working Directory. To conduct the data export and import, you are recommended to set the working directory since we usually use a path relative to the working directory for interacting with files on the computer in R, . To set the working directory, you can click Session on the menu and click Set Working Directory. ADD a screenshot with this menu here There are three options under this menu. To Source File Location: this is the same directory as the current R script. To Files Pane Location: this is the same directory as shown in the Files Panel on the bottom right of RStudio. Choose Directory…: this will open up a window from which you can choose any desired directory. After selecting any of the three options, we can see a line of code containing the function setwd() executed in the console. ADD a screenshot with this line of code here Indeed, this menu operation is equivalent to using the setwd() function with the argument being the full path or relative path of the desired directory. Another related function is getwd() which tells us the absolute path representing the current working directory. getwd() 5.1.2 Delimited files In most applications, you will use a specific file type called delimited file. In a delimited file, each row represents a single observation, and it has values separated by the delimiter. In principle, any character (including letters, numbers, or symbols) can be used as a delimiter, with the most commonly used ones being comma, tab, colon, and space. 5.1.3 Write an object into a .csv file First, let’s work with one popular kind of delimited files called comma-separated value file, usually with the file extension .csv. In a .csv file, the delimiter is comma (,). Let’s review the data frame you created in Section???. dig_num &lt;- 7:1 ani_char &lt;- c(&quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;, &quot;pig&quot;, &quot;monkey&quot;, NA, &quot;pig&quot;) conditions &lt;- c(&quot;Excellent&quot;, &quot;Good&quot;, &quot;N&quot;, &quot;Fair&quot;, &quot;Good&quot;, &quot;Good&quot;, &quot;Excellent&quot;) my_animals&lt;- data.frame(dig_num, ani_char, conditions) my_animals Now, let’s write the data frame my_animals into a file called “my_animals.csv” in the currently working directory. To write an object into a .csv file, you will use the write_csv() function in the readr package. Since readr is a subpackage of tidyverse, you don’t need to install it separately, but you need to load the package in each new R session. library(readr) write_csv(my_animals, &quot;my_animals.csv&quot;) You can verify the .csv file has been indeed created and open the file with RStudio or any text editor to verify its contents. Shall we use a screenshot again? We can see that all the information has been written in the .csv file, which has commas separating the values on each line. In particular, you may find out the first row of the file corresponds to the column names. If you don’t want to include the column names, you can set the argument col_names to be FALSE. write_csv(my_animals, &quot;my_animals_no_colname.csv&quot;, col_names = FALSE) By default, write_csv() writes the data into a file in which NA is used to represent all the missing values, just like in the tibble. If you want to use another string to represent the missing values in the file, you can set the argument na to be the string. write_csv(my_animals, &quot;my_animals_missing.csv&quot;, na = &quot;This value is missing!&quot;) 5.1.4 Write an object into a delimited file As introduced at the beginning, there are different types of delimited files depending on the specific delimiter. The function write_delim() enables us to write an object into a delimited file with any chosen delimiter. The usage of write_delim() is almost identical to write_csv(), except that it has an additional argument delim, which specifies the delimiter to be used. Let’s see the following example with * as the delimiter. write_delim(my_animals, &quot;my_animals_star.csv&quot;, delim = &quot;*&quot;) 5.1.5 Exercises If we have a data frame named my_data in R, write R code to write the data frame into a .csv file named “my_data_no_name.csv” without column names. If we have a data frame named my_data in R which contains NA values, write R code to write the data frame into a delimited file called “my_data_na.csv” with # as the delimiter and use 999 as the indicator for missing values. "],["import-data.html", "5.2 Importing Data from Delimited Files", " 5.2 Importing Data from Delimited Files Knowing how to export data into delimited files, let’s see how to import data from the delimited files. 5.2.1 Import .csv Files using read_csv() To import .csv files, we can use the function read_csv() in the readr package, which is a sub-package of tidyverse. If you have already installed tidyverse, you can directly load the readr package. After loading the readr package, you can try to import the data from “my_animals.csv,” which you want to make sure is in the current working directory. library(readr) my_animals &lt;- read_csv(&quot;my_animals.csv&quot;) #&gt; #&gt; ── Column specification ──────────────────────────────────────────────────────── #&gt; cols( #&gt; dig_num = col_double(), #&gt; ani_char = col_character(), #&gt; conditions = col_character() #&gt; ) We can see there is a message showing the Column specification during the import process. In particular, we see dig_num is of type double (or numeric), and both ani_char and cond_fac are of type character. We can also check the value of my_animals and its structure. my_animals str(my_animals) We can see that the tibble my_animals is generated along with the correct column types. In order to introduce the various options associated with read_csv() function, let’s move on to the topic of inline .csv files next. 5.2.2 Read Inline .csv Files The read_csv() function not only can read files into R, it also accept inline input as its argument. While the inline input may not be commonly used in practice, it is particularly useful for learning how to use the function. Let’s see an example. read_csv(&quot;x,y,z 1,3,5 2,4,6&quot;) You can see that a tibble is generated with 2 rows and 3 columns with the column names being x, y and z. From the argument, we can see that by default, the first row of the input data will be interpreted as the column names. If the input data doesn’t correspond to the variable names, you need to set col_names = FALSE as an additional argument in read_csv(). read_csv(&quot;x,y,z 1,3,5 2,4,6&quot;, col_names = FALSE) Now, a tibble of 3 rows and 3 columns was generated, with the column names being X1, X2, and X3. Note that these are the naming convention in the function when you don’t supply the column names in the file. Another thing worth mentioning is that all three variables are of character types, due to the fact that there are character values for all variables (x, y, and z). Sometimes, the first few lines of your data file may be descriptions of the data, which you want to skip when import into R. We can set the skip argument in the read_csv() function to skip a certain number of lines. read_csv(&quot;The first line The second line The third line x,y,z 1,3,5&quot;, skip = 3) It is clear from the result that the first 3 lines of the input data is skipped. Another useful argument to when we have comments in the data file is the comment argument, which tells R to skip all text after the string specified in the comment argument. read_csv(&quot;x,y,z #variable names 1,3,5 #the first observation 2,4,6 #the second observation&quot;, comment = &quot;#&quot;) 5.2.3 Handing Missing Values In many real data sets, we may have missing values. You may recall that R uses NA to represent the missing values. If the data set was prepared by an R user, it probably already uses NA to represent all the missing values. In this case, read_csv() will automatically interpret all NAs as missing values. read_csv(&quot;x,y,z 999,3,5 NA,-999,6&quot;) In a typical application, however, the person who prepared the data may use other strings to represent missing value. For example, if 999 and -999 are used as the indicators for missing values, you can set the argument na to be the vector for those values. read_csv(&quot;x,y,z 999,3,5 999,-999,6&quot;, na = c(&quot;999&quot;,&quot;-999&quot;,&quot;NA&quot;)) You can see from the output tibble that all the missing values are now denoted as NA. 5.2.4 Importing data from a delimited file You now know how to import data from a .csv file using read_csv(). More generally, read_delim() allows us to import data from a delimited file with any chosen delimiter. The usage of read_delim() is almost identical to read_csv(), except that it has an additional argument delim, which specifies the delimiter to be used. Let’s see the following example with * as the delimiter. my_animals &lt;- read_delim(&quot;my_animals_star.csv&quot;, delim = &quot;*&quot;) #&gt; #&gt; ── Column specification ──────────────────────────────────────────────────────── #&gt; cols( #&gt; dig_num = col_double(), #&gt; ani_char = col_character(), #&gt; conditions = col_character() #&gt; ) 5.2.5 Import data using the menu Besides writing codes involving read_csv() or read_delim() to import data, you can also take advantage of the interactive menu RStudio provides. To do this, you can click on the Import Dataset button in the Environment panel on the top right of RStudio. Here, you can see quite a few options which are summarized in the following table. Table 5.1: Import Data from Menu Choice Name From Text (readr) Delimited Files (.csv, .txt, and others) From Excel Excel Files (.xls and .xlsx) From SPSS SPSS Files (.sav) From SAS SAS Files (.sas7bdat and.sas7bcat) From Stata Stata Files (.dta) We will focus on importing delimited files in this section. We will cover importing Excel files in Section 5.3. Working with SPSS, SAS, and Stata files will be covered in Section 5.4. For importing a .csv file, .txt file, or any other file with a delimiter, you can choose the From Text (readr) option. Then, you can click Browse… and select the data file. After a file is selected, you can see the Data Preview which showing the first several rows of the data. Note that the first row shows the column names and their associate types in parentheses. For each column, you can click the dropdown menu after the type to change its type. When we select a .csv file, we may see the function read_csv() in the Code Preview window. Indeed, read_csv() is the backbone for reading .csv files into R. We need a screen shot? The bottom area shows many Import Options. Let’s look at a few commonly used options, their corresponding arguments in the read_csv() or read_delim() function, and meanings. Table 5.2: Menu Options and its Corresponding Arguments in read_delim() and Meanings Option Argument Meaning Name - The object name you would like to assign to. Skip skip The number of rows to skip at the beginning of the file. First Row as Names col_names Whether you want to use the first row as column names. TRUE or FALSE. Delimiter delim The delimiter of the data file. Comment comment The character indicating the starting of comment. The contents after the comment character will be ignore in each line. NA na The way NA is represented in the data file. Code Preview - The R code to be executed for importing the data Note that when you change these options, the code in the Code Preview window will change accordingly, which is a great way to learn on how they work. 5.2.6 Exercises If we have a delimited file named “my_data.txt” with * as the delimiter and the file is located in the current working directory. Write R code to read the file into an object with name my_data. First, run the code below. d1 &lt;- read_csv(&quot;x,y,z 1,3,5 2,4,6&quot;, col_names = FALSE) Which of the following are the column names of the d1? X1, X2, and X3 x, y, and z First, run the code below. read_csv(&quot;The first line The second line The third line x,y,z 1,3,5&quot;, ) Which of the following are the column names of the d1? "],["import-excel.html", "5.3 Exporting and Importing Data from Excel Files", " 5.3 Exporting and Importing Data from Excel Files Now, you know how to export and import data from delimited files. In this section, you will learn how to export and import data from Excel files with extensions .xls and .xlxs. 5.3.1 Export data into Excel files To export data into an Excel file, you can use the writexl package. Let’s first install the package. install.packages(&quot;writexl&quot;) Now, we can load the writexl package and use the write.xlsx() function to write data into an Excel file with extension .xlsx. library(writexl) write_xlsx(my_animals, &quot;my_animals.xlsx&quot;) By default, the column name of the data frame/tibble will be written to the first row of the Excel file. In addition to writing one data frame to an Excel file, write.xlsx() can also write multiple data frames into a single Excel file, with each sheet containing each data frame. Let’s take a look at the following example which write both my_animals and sahp (a tibble in the r02pro package) into an Excel file named “two_data.xlsx.” two_data &lt;- list(my_animals = my_animals, sahp = sahp) write_xlsx(two_data, &quot;two_data.xlsx&quot;) 5.3.2 Import Excel Files (.xls and .xlsx ) using read_excel() Having learned how to export data into an Excel file, let’s see how to read an existing Excel file into R. We can use the read_excel() function in the readxl package to import Excel files. Here, readxl is another subpackage in the tidyverse package. Thus we can directly load the package and use it. Let’s import the sheet sahp from the Excel file “two_data.xlsx.” library(readxl) shap_1 &lt;- read_excel(&quot;two_data.xlsx&quot;, sheet = &quot;sahp&quot;) head(shap_1) #&gt; # A tibble: 6 × 13 #&gt; dt_sold bedroom bathroom gar_car oa_qual liv_area lot_area #&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2010-03-25 00:00:00 3 2.5 2 6 1479 13517 #&gt; 2 2009-04-10 00:00:00 4 3.5 2 7 2122 11492 #&gt; 3 2010-01-15 00:00:00 3 2 1 5 1057 7922 #&gt; 4 2010-04-19 00:00:00 3 2.5 2 5 1444 9802 #&gt; 5 2010-03-22 00:00:00 3 2 2 6 1445 14235 #&gt; 6 2010-06-06 00:00:00 2 2.5 2 6 1888 16492 #&gt; # … with 6 more variables: house_style &lt;chr&gt;, kit_qual &lt;chr&gt;, heat_qual &lt;chr&gt;, #&gt; # central_air &lt;chr&gt;, sale_price &lt;dbl&gt;, good_qual &lt;lgl&gt; If we only want to import a portion of the data, let’ say the first 5 rows and the first four columns, then we can set the argument range = \"A1:D5\". shap_2 &lt;- read_excel(&quot;two_data.xlsx&quot;, sheet = &quot;sahp&quot;, range = &quot;A1:D5&quot;) shap_2 #&gt; # A tibble: 4 × 4 #&gt; dt_sold bedroom bathroom gar_car #&gt; &lt;dttm&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2010-03-25 00:00:00 3 2.5 2 #&gt; 2 2009-04-10 00:00:00 4 3.5 2 #&gt; 3 2010-01-15 00:00:00 3 2 1 #&gt; 4 2010-04-19 00:00:00 3 2.5 2 5.3.3 Import Excel file using the menu Besides using read_excel() to import Excel files, you can again use the interactive menu we introduced in Section 5.2 . As introduced in Table 5.1, to import Excel files, you can select From Excel after choosing the Import Dataset option. As before, you can click Browse… and select the data file. Let’s select the “two_data.xlsx” file we just created. Similar to importing the delimited files, we can see the first several rows in the Data Preview windows. The first row shows the column names and their associate types in parentheses. For each column, you can click the dropdown menu after the type to change its type. Now, let’s discuss several options in the Import Options section and their corresponding arguments in the read_excel() function. Table 5.3: Menu Options and its Corresponding Arguments in read_excel() and Meanings Option Argument Meaning Name - The object name you would like to assign to. Sheet sheet The Sheet you want to import from. Range range The data range you want to import. Max Rows n_max The maximum number of rows to import. Skip skip The number of rows to skip at the beginning of the file. NA na The way NA is represented in the data file. First Row as Names col_names Whether you want to use the first row as column names. TRUE or FALSE. Code Preview - The R code to be executed for importing the data Note that similar as importing delimited files, when you change these options, the code in the Code Preview window will change accordingly, which is a great way to learn on how they work. 5.3.4 Exercise You can run the following code to do the exercise. r02pro(4) "],["import-other.html", "5.4 Working with Data from SPSS, SAS, and Stata Files", " 5.4 Working with Data from SPSS, SAS, and Stata Files Now, you know how to export and import data from delimited files and Excel files. In the section, you will learn how to export and import data from other statistical software including SPSS, SAS, and Stata. We will use the package haven, another member of the tidyverse family. 5.4.1 Export and Import SPSS Files Let’s first defined a data frame for dig_num &lt;- 7:1 ani_char &lt;- c(&quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;, &quot;pig&quot;, &quot;monkey&quot;, NA, &quot;pig&quot;) conditions &lt;- c(&quot;Excellent&quot;, &quot;Good&quot;, &quot;N&quot;, &quot;Fair&quot;, &quot;Good&quot;, &quot;Good&quot;, &quot;Excellent&quot;) my_animals&lt;- tibble(dig_num, ani_char,conditions) my_animals The data frame my_animals will be used as in Section 5.1. You can use the function write_sav() to export a data frame into a SPSS .sav file. library(haven) write_sav(my_animals, &quot;my_animals.sav&quot;) To read a SPSS file ending in .sav or .por, you can use the function read_spss() which will automatically call read_sav() for .sav files and read_por() for .por files. my_animals_spss &lt;- read_spss(&quot;my_animals.sav&quot;) head(my_animals_spss) 5.4.2 Export and Import SAS Files You can use the function write_sas() to export a data frame into a SAS .sas7bdat file. write_sas(my_animals, &quot;my_animals.sas7bdat&quot;) To import a SAS file, you can use the function read_sas(). my_animals_sas &lt;- read_sas(&quot;my_animals.sas7bdat&quot;) head(my_animals_sas) 5.4.3 Export and Import Stata Files Lastly, let’s talk about Stata files. You can use the function write_dta() to export a data frame into a Stata .dta file. write_dta(my_animals, &quot;my_animals.dta&quot;) To read a Stata file ending in .dta, you can use the function read_dta(). my_animals_stata &lt;- read_dta(&quot;my_animals.dta&quot;) head(my_animals_stata) 5.4.4 Import using the menu Similarly as Sections 5.2 and 5.3, you can also use the menu in Table 5.1 to import SPSS, SAS, and Stata Files. 5.4.5 Exercise You can run the following code to do the exercise. r02pro(&quot;8.1&quot;) "],["save-object.html", "5.5 Save and Restore Objects and Workspace", " 5.5 Save and Restore Objects and Workspace Now, you know how to export and import data frames (or tibbles) to and from various types of file. In this section, you will learn how to save and restore one or more objects that can be of any types, and even the whole workspace that includes all the named objects. To get started, let’s first clear our workspace using rm(list = ls()) and create a few objects with different types. rm(list = ls()) dig_num &lt;- 7:1 ani_char &lt;- c(&quot;sheep&quot;, &quot;pig&quot;, &quot;monkey&quot;, &quot;pig&quot;, &quot;monkey&quot;, NA, &quot;pig&quot;) my_list&lt;- list(dig_num = dig_num, ani_char = ani_char) Recall that we can use ls() to get a vector of strings giving the names of the objects in the current environment. ls() #&gt; [1] &quot;ani_char&quot; &quot;dig_num&quot; &quot;my_list&quot; 5.5.1 Save and Restore Objects using .RData In R, you can use the function save() to save one or more objects into an .RData file. Note that you want to make sure to change the working directory as needed. Let’s see the following example where we save the object dig_num into a file named “dig_num.RData.” save(dig_num, file = &quot;dig_num.RData&quot;) Before introducing how to restore objects, let’s first remove dig_num from our workspace using the rm() function. rm(dig_num) dig_num #&gt; Error in eval(expr, envir, enclos): object &#39;dig_num&#39; not found You can see that dig_num has indeed been removed from the workspace. To restore it, you can use the function load() with the corresponding .RData in double quotes as its argument. load(&quot;dig_num.RData&quot;) dig_num #&gt; [1] 7 6 5 4 3 2 1 You can verify from the value of dig_num that we have successfully restored the object dig_num from the file “dig_num.RData.” To save more than one objects into one file, you just need to enter them as additional arguments in the save() function. save(dig_num, ani_char, file = &quot;dig_num_and_ani_char.RData&quot;) To save everything in the workspace, you can use the function save.image() with the desired file name in double quotes as the argument. save.image(&quot;all.RData&quot;) To verify that “all.RData” indeed contains all the named object, let’s do the following. rm(list = ls()) #remove everything from the workspace. ls() #confirm the workspace is empty. #&gt; character(0) load(&quot;all.RData&quot;)#restore from &quot;all.RData&quot;. ls() #check what&#39;s in the workspace. #&gt; [1] &quot;ani_char&quot; &quot;dig_num&quot; &quot;my_list&quot; 5.5.2 Save and Restore a Single Object using saveRDS() and loadRDS() Before introducing the new method, there is one drawback of load() worth noting: if the imported .RData file contains objects with the same names as in the current workspace, all these objects in the current workspace will be silently overwritten without any warning! Let’s see the following example. dig_num &lt;- 724 dig_num #&gt; [1] 724 load(&quot;all.RData&quot;) dig_num #&gt; [1] 7 6 5 4 3 2 1 We can see that the value of dig_num was indeed silently overwritten by the load() function, which could be sometimes dangerous. To avoid this issue, another pair of functions to save and restore a single object is saveRDS() and loadRDS(). The usage of saveRDS() is almost identical to save() except we usually use a file with extension “.rds” to store the object. saveRDS(dig_num, file = &quot;dig_num.rds&quot;) To highlight the different behaviors of readRDS() and load(), let’s change the dig_num again. dig_num &lt;- 826 dig_num #&gt; [1] 826 To restore the object in an “rds” file, we use the readRDS() in the following way. dig_num_new &lt;- readRDS(&quot;dig_num.rds&quot;) dig_num_new #&gt; [1] 7 6 5 4 3 2 1 dig_num #&gt; [1] 826 As it is clearly from this example, you need to assign the value of the readRDS() function to a name, which helps to prevent any objects been overwritten silently. In fact, the saveRDS() only saves the value of the object without the object name. For this reason, you are recommended to use the function pair saveRDS() and readRDS() if you want to save and load one R object. While save() and load() may be simplier to use when saving and loading multiple objects, you want to be extremely careful with the overwriting issues we discussed here. 5.5.3 Exercise You can run the following code to do the exercise. r02pro(4) "],["data-manipulation.html", "Chapter 6 Data Manipulation", " Chapter 6 Data Manipulation For conducting data analysis, we often need to conduct various kinds of data manipulation. We will use the ahp data set in the r02pro package throughout this chapter. Let’s first review the data set. library(r02pro) ahp ahp is a dataset of 2048 houses in Ames, Iowa from 2006 to 2010, with 56 features including the sale date and price. To learn more about each variable, you can look at its documentation. ?ahp To view the entire dataset, you can use the View() function, which will open the dataset in the new file window. View(ahp) To get the first 6 rows of ahp, you can use the head() function, which also has an optional argument if you want a different number of top rows. head(ahp) head(ahp, n = 10) #the first 10 rows of ahp The following are some possible questions we may want to explore. (pick observations by their values) Find the houses that are sold in Jan 2009. (reorder the observations) Find the 10 houses with the highest sale prices. (pick variable by their names) We see there are 56 columns. For a particular data analysis question, perhaps we want to focus on a subset of the columns. (create new variables as functions of existing ones) From the existing variables, perhaps we want to create new ones, for instance, the average price per living area. (create various summary statistics) We may want to create certain summary statistics. For example, what is the average sale price for each type of houses? "],["filter-observations.html", "6.1 Filter Observations and Objects Masking", " 6.1 Filter Observations and Objects Masking Let’s start with the first task outlined at the beginning of this chapter. Suppose we want to find the houses that are sold in Jan 2009. You can use the function filter() in the dplyr package, a member of the tidyverse package. If you haven’t installed the tidyverse package, you need to install it. Let’s first load the dplyr package. library(dplyr) 6.1.1 Objects Masking After loading the package dplyr, you can see the following message The following objects are masked from ‘package:stats’: filter, lag The message appears because dplyr contains the functions filter() and lag() which are already defined and preloaded in the R package stats. As a result, the original functions are masked by the new definition in dplyr. In this scenario when the same function name is shared by multiple packages, we can add the package name as a prefix to the function name with double colon (::). For example, stats::filter() represents the filter() function in the stats package, while dplyr::filter() represents the filter() function in the dplyr package. You can also look at their documentations. ?stats::filter ?dplyr::filter It is helpful to verify which version of filter() you are using by typing the function name filter. filter Usually, R will use the function in the package that is loaded at a later time. To verify the search path, you can use the search() function. R will show a list of attached packages and R objects. search() #&gt; [1] &quot;.GlobalEnv&quot; &quot;package:haven&quot; &quot;package:readxl&quot; #&gt; [4] &quot;package:writexl&quot; &quot;package:forcats&quot; &quot;package:stringr&quot; #&gt; [7] &quot;package:purrr&quot; &quot;package:readr&quot; &quot;package:tidyr&quot; #&gt; [10] &quot;package:tidyverse&quot; &quot;package:ggplot2&quot; &quot;package:tibble&quot; #&gt; [13] &quot;package:r02pro&quot; &quot;package:dplyr&quot; &quot;package:stats&quot; #&gt; [16] &quot;package:graphics&quot; &quot;package:grDevices&quot; &quot;package:utils&quot; #&gt; [19] &quot;package:datasets&quot; &quot;package:methods&quot; &quot;Autoloads&quot; #&gt; [22] &quot;package:base&quot; 6.1.2 Filter Observations Now, let’s introduce how to use filter() to get the subset of ahp which consists of houses that are sold in Jan 2009. To use the filter() function, you put the dataset in the first argument, and put the logical statements as individual arguments after that. We know the ahp dataset has the year information in yr_sold and the month information in mo_sold. Apparently, Jan 2009 corresponding to yr_sold == 2009 and mo_sold == 1. library(r02pro) filter(ahp, yr_sold == 2009, mo_sold == 1) #&gt; # A tibble: 10 × 56 #&gt; dt_sold yr_sold mo_sold yr_built yr_remodel bldg_class bldg_type #&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 2009-01-07 2009 1 1979 1998 20 1Fam #&gt; 2 2009-01-09 2009 1 1920 1950 30 1Fam #&gt; 3 2009-01-04 2009 1 1958 1958 20 1Fam #&gt; 4 2009-01-17 2009 1 2004 2004 20 1Fam #&gt; 5 2009-01-16 2009 1 NA 2007 20 1Fam #&gt; 6 2009-01-18 2009 1 2008 2008 20 1Fam #&gt; 7 2009-01-07 2009 1 2008 2009 60 1Fam #&gt; 8 2009-01-28 2009 1 2004 2004 60 1Fam #&gt; 9 2009-01-12 2009 1 1926 2004 45 1Fam #&gt; 10 2009-01-07 2009 1 2004 2005 20 1Fam #&gt; # … with 49 more variables: house_style &lt;chr&gt;, zoning &lt;chr&gt;, neighborhd &lt;chr&gt;, #&gt; # oa_cond &lt;dbl&gt;, oa_qual &lt;dbl&gt;, func &lt;chr&gt;, liv_area &lt;dbl&gt;, 1fl_area &lt;dbl&gt;, #&gt; # 2fl_area &lt;dbl&gt;, tot_rms &lt;dbl&gt;, bedroom &lt;dbl&gt;, bathroom &lt;dbl&gt;, kit &lt;dbl&gt;, #&gt; # kit_qual &lt;chr&gt;, central_air &lt;chr&gt;, elect &lt;chr&gt;, bsmt_area &lt;dbl&gt;, #&gt; # bsmt_cond &lt;chr&gt;, bsmt_exp &lt;chr&gt;, bsmt_fin_qual &lt;chr&gt;, bsmt_ht &lt;chr&gt;, #&gt; # ext_cond &lt;chr&gt;, ext_cover &lt;chr&gt;, ext_qual &lt;chr&gt;, fdn &lt;chr&gt;, fence &lt;chr&gt;, #&gt; # fp &lt;dbl&gt;, fp_qual &lt;chr&gt;, gar_area &lt;dbl&gt;, gar_car &lt;dbl&gt;, gar_cond &lt;chr&gt;, … In the filter() function, each logical statement will be computed, which leads to a logical vector of the same length as the number of observations. Then, only the observations that have TRUE values in all logical vectors are kept. It is helpful to learn the mechanism of filter() by reproducing the results using what we learned on data frame subsetting in Section @ref(subset_df). ahp[ahp$yr_sold == 2009 &amp; ahp$mo_sold == 1, ] Although we got the same answer, we hope you agree with us that the filter() function provides more intuitive and simpler codes than the raw data frame subsetting. For example, the tibble name ahp appeared three times in the data frame subsetting while it only appears once in the filter() function. This is an example of the power of creating new R functions and R packages. They usually enable us to do tasks that couldn’t be done using the existing functions in base R, or making coding easier than just using the existing functions. Recall that the same thing happened in the visualization where we compared the visualization functions in base R with the ggplot() function. No matter how complicated the figure we want to create is, we only need to put the data set name once in the ggplot() function if all the layers are using the same data set. It is worth noting that the filter() function only returns the obsevations when the conditions are all TRUE, without including the NA observations. Using the filter() function, the original tibble is unchanged, which is actually the feature of many functions we will learn in this Chapter. To save the filtered tibble, you can either assign the value to the original tibble name, which will overwrite it; or assign the value to a new name, which will create a new tibble with the new values. Let’s save all houses that were sold in Apr 2009 in a new tibble. apr09 &lt;- filter(ahp, yr_sold == 2009, mo_sold == 4) apr09 In addition to using separate logical statements, you can also have logical operations between multiple logical vectors inside each statement. This makes the filter() function very flexible in expressing different kinds of filtering operation. Let’s say we want to find all houses that are sold in 2007, remodeled in 2006, and with house style either “1Story” or “2Story.” filter(ahp, dt_sold &gt;= &quot;2007-01-01&quot;, dt_sold &lt; &quot;2008-01-01&quot;, yr_remodel == 2006, house_style == &quot;1Story&quot; | house_style == &quot;2Story&quot;) From the above example, you can see that a variable can used multiple times in different logical statements. "],["reorder-observations.html", "6.2 Reorder Observations", " 6.2 Reorder Observations Now, let’s look at the second task: find the 10 houses with the highest sale prices. To order observations, you can use the function arrange() in the dplyr package. To make the ordering easier to check, we will first focus on a smaller data set, that corresponds to the houses that was sold in Jan 2009 with overall condition equaling 5. library(r02pro) library(dplyr) library(tibble) jan09 &lt;- filter(ahp, yr_sold == 2009, mo_sold == 1, oa_cond == 5) jan09 To arrange the observations in the ascending order of the year that the house was built (yr_built), you just need to add yr_built as a second argument of the arrange() function. To arrange the descending order, you just need to add desc() around the variable. arrange(jan09, yr_built) #arrange in the ascending order of yr_built #&gt; # A tibble: 8 × 56 #&gt; dt_sold yr_sold mo_sold yr_built yr_remodel bldg_class bldg_type #&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 2009-01-09 2009 1 1920 1950 30 1Fam #&gt; 2 2009-01-07 2009 1 1979 1998 20 1Fam #&gt; 3 2009-01-17 2009 1 2004 2004 20 1Fam #&gt; 4 2009-01-28 2009 1 2004 2004 60 1Fam #&gt; 5 2009-01-07 2009 1 2004 2005 20 1Fam #&gt; 6 2009-01-18 2009 1 2008 2008 20 1Fam #&gt; 7 2009-01-07 2009 1 2008 2009 60 1Fam #&gt; 8 2009-01-16 2009 1 NA 2007 20 1Fam #&gt; # … with 49 more variables: house_style &lt;chr&gt;, zoning &lt;chr&gt;, neighborhd &lt;chr&gt;, #&gt; # oa_cond &lt;dbl&gt;, oa_qual &lt;dbl&gt;, func &lt;chr&gt;, liv_area &lt;dbl&gt;, 1fl_area &lt;dbl&gt;, #&gt; # 2fl_area &lt;dbl&gt;, tot_rms &lt;dbl&gt;, bedroom &lt;dbl&gt;, bathroom &lt;dbl&gt;, kit &lt;dbl&gt;, #&gt; # kit_qual &lt;chr&gt;, central_air &lt;chr&gt;, elect &lt;chr&gt;, bsmt_area &lt;dbl&gt;, #&gt; # bsmt_cond &lt;chr&gt;, bsmt_exp &lt;chr&gt;, bsmt_fin_qual &lt;chr&gt;, bsmt_ht &lt;chr&gt;, #&gt; # ext_cond &lt;chr&gt;, ext_cover &lt;chr&gt;, ext_qual &lt;chr&gt;, fdn &lt;chr&gt;, fence &lt;chr&gt;, #&gt; # fp &lt;dbl&gt;, fp_qual &lt;chr&gt;, gar_area &lt;dbl&gt;, gar_car &lt;dbl&gt;, gar_cond &lt;chr&gt;, … arrange(jan09, desc(yr_built)) #arrange in the descending order of yr_built #&gt; # A tibble: 8 × 56 #&gt; dt_sold yr_sold mo_sold yr_built yr_remodel bldg_class bldg_type #&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 2009-01-18 2009 1 2008 2008 20 1Fam #&gt; 2 2009-01-07 2009 1 2008 2009 60 1Fam #&gt; 3 2009-01-17 2009 1 2004 2004 20 1Fam #&gt; 4 2009-01-28 2009 1 2004 2004 60 1Fam #&gt; 5 2009-01-07 2009 1 2004 2005 20 1Fam #&gt; 6 2009-01-07 2009 1 1979 1998 20 1Fam #&gt; 7 2009-01-09 2009 1 1920 1950 30 1Fam #&gt; 8 2009-01-16 2009 1 NA 2007 20 1Fam #&gt; # … with 49 more variables: house_style &lt;chr&gt;, zoning &lt;chr&gt;, neighborhd &lt;chr&gt;, #&gt; # oa_cond &lt;dbl&gt;, oa_qual &lt;dbl&gt;, func &lt;chr&gt;, liv_area &lt;dbl&gt;, 1fl_area &lt;dbl&gt;, #&gt; # 2fl_area &lt;dbl&gt;, tot_rms &lt;dbl&gt;, bedroom &lt;dbl&gt;, bathroom &lt;dbl&gt;, kit &lt;dbl&gt;, #&gt; # kit_qual &lt;chr&gt;, central_air &lt;chr&gt;, elect &lt;chr&gt;, bsmt_area &lt;dbl&gt;, #&gt; # bsmt_cond &lt;chr&gt;, bsmt_exp &lt;chr&gt;, bsmt_fin_qual &lt;chr&gt;, bsmt_ht &lt;chr&gt;, #&gt; # ext_cond &lt;chr&gt;, ext_cover &lt;chr&gt;, ext_qual &lt;chr&gt;, fdn &lt;chr&gt;, fence &lt;chr&gt;, #&gt; # fp &lt;dbl&gt;, fp_qual &lt;chr&gt;, gar_area &lt;dbl&gt;, gar_car &lt;dbl&gt;, gar_cond &lt;chr&gt;, … You may observe from the results that there are several houses with the same yr_built value, leading to a tie. To break the tie, you can supply additional variables in the arrange() function, which will arrange the observations in the tie according to the additional variables sequentially. arrange(jan09, desc(yr_built), bldg_class) #&gt; # A tibble: 8 × 56 #&gt; dt_sold yr_sold mo_sold yr_built yr_remodel bldg_class bldg_type #&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 2009-01-18 2009 1 2008 2008 20 1Fam #&gt; 2 2009-01-07 2009 1 2008 2009 60 1Fam #&gt; 3 2009-01-17 2009 1 2004 2004 20 1Fam #&gt; 4 2009-01-07 2009 1 2004 2005 20 1Fam #&gt; 5 2009-01-28 2009 1 2004 2004 60 1Fam #&gt; 6 2009-01-07 2009 1 1979 1998 20 1Fam #&gt; 7 2009-01-09 2009 1 1920 1950 30 1Fam #&gt; 8 2009-01-16 2009 1 NA 2007 20 1Fam #&gt; # … with 49 more variables: house_style &lt;chr&gt;, zoning &lt;chr&gt;, neighborhd &lt;chr&gt;, #&gt; # oa_cond &lt;dbl&gt;, oa_qual &lt;dbl&gt;, func &lt;chr&gt;, liv_area &lt;dbl&gt;, 1fl_area &lt;dbl&gt;, #&gt; # 2fl_area &lt;dbl&gt;, tot_rms &lt;dbl&gt;, bedroom &lt;dbl&gt;, bathroom &lt;dbl&gt;, kit &lt;dbl&gt;, #&gt; # kit_qual &lt;chr&gt;, central_air &lt;chr&gt;, elect &lt;chr&gt;, bsmt_area &lt;dbl&gt;, #&gt; # bsmt_cond &lt;chr&gt;, bsmt_exp &lt;chr&gt;, bsmt_fin_qual &lt;chr&gt;, bsmt_ht &lt;chr&gt;, #&gt; # ext_cond &lt;chr&gt;, ext_cover &lt;chr&gt;, ext_qual &lt;chr&gt;, fdn &lt;chr&gt;, fence &lt;chr&gt;, #&gt; # fp &lt;dbl&gt;, fp_qual &lt;chr&gt;, gar_area &lt;dbl&gt;, gar_car &lt;dbl&gt;, gar_cond &lt;chr&gt;, … Here, the observations are arranged in the descending order of yr_built, and the ties are broken in the ascending order of bldg_class. Clearly, you can supply as many arguments as needed in the arrange() function. It is also important to note that the observations that has an NA value in the specified variable will always be arranged at the end of the output. "],["pipe.html", "6.3 Pipe: Combining Multiple Operations", " 6.3 Pipe: Combining Multiple Operations We have now learned how to filter observations according to a set of conditions (Section 6.1) and how to rearrange observations according to a set of variables (Section 6.2). In practical applications, we usually need to apply multiple operations sequentially on a given data. Let’s consider the ahp dataset again. Say we want to first find the houses that were sold in Jan 2009 and with over all condition 5. Then, arrange the houses from the oldest to the newest. Finally, create a scatterplot on the sale_price vs. liv_area. library(r02pro) library(tidyverse) jan09 &lt;- filter(ahp, yr_sold == 2009, mo_sold == 1, oa_cond == 5) #filtering jan09_yr &lt;- arrange(jan09, yr_built) #find the oldest houses ggplot(jan09_yr, mapping = aes(x = liv_area, y = sale_price)) + geom_point() You may notice that we created two intermediate objects named jan09 and jan09_yr which may be unnecessary. Let’s say what happens to the code if we are not allowed to define such intermediate objects. ggplot(arrange(filter(ahp, yr_sold == 2009, mo_sold == 1, oa_cond == 5), yr_built), mapping = aes(x = liv_area, y = sale_price)) + geom_point() We hope you agree that while the code gets the work done, it is not pretty. To make the code more streamlined and intuitive, you can take advantage of the pipe operator %&gt;% in the dplyr package. Let’s take a look at the code using pipes before going to the details. ahp %&gt;% filter(yr_sold == 2009, mo_sold == 1, oa_cond == 5) %&gt;% arrange(yr_built) %&gt;% ggplot(mapping = aes(x = liv_area, y = sale_price)) + geom_point() We hope you agree this code looks more intuitive than the previous version. The working mechanism of %&gt;% is as follows. When you use data %&gt;% some_function(argA, argB), this is equivalent to some_function(data, argA, argB). As a result, you can use multiple %&gt;% operators in a row, if the first function provides an output which is the input data of the second function, etc. "],["select-variables.html", "6.4 Select, Rename, and Reorder Variables", " 6.4 Select, Rename, and Reorder Variables So far, we have only been manipulating observations, including filtering and arranging the observations. In many applications, there are some variables which may not be the focus of the research problem. As a result, learning how to select variables is very useful in data analysis. 6.4.1 Select Variables via Names Let’s again consider the ahp data set, which contains 56 variables in total. If we want to focus on the sold date, house style, living area, and sale price, we can use the select() function in the dplyr package. We will be using the pipe introduced in Section 6.3 throughout the rest of this Chapter. Inside the select() function, you can include the variables to select as different arguments. Note that the quotation marks are not necessary. library(r02pro) library(tidyverse) ahp %&gt;% select(dt_sold, house_style, liv_area, sale_price) #&gt; # A tibble: 2,048 × 4 #&gt; dt_sold house_style liv_area sale_price #&gt; &lt;date&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2010-03-25 2Story 1479 130. #&gt; 2 2009-04-10 2Story 2122 NA #&gt; 3 2010-01-15 1Story 1057 109 #&gt; 4 2010-04-19 2Story 1444 174 #&gt; 5 2010-03-22 1.5Fin 1445 138. #&gt; 6 2010-06-06 1Story 1888 190 #&gt; 7 2006-06-14 SFoyer 1072 140 #&gt; 8 2010-05-08 1Story 1188 142 #&gt; 9 2007-06-14 1Story 924 112. #&gt; 10 2007-09-01 2Story 2080 135 #&gt; # … with 2,038 more rows As you can see from the output, the select() function returns another tibble with all the observations and the selected variables. 6.4.2 Rename Variables In the select() function, you can also rename the variables in the form of new_name = old_name as the arguments. Let’s see the following example where we want to rename dt_sold as sold_date and liv_area as living_area. ahp %&gt;% select(sold_date = dt_sold, living_area = liv_area, sale_price) #&gt; # A tibble: 2,048 × 3 #&gt; sold_date living_area sale_price #&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2010-03-25 1479 130. #&gt; 2 2009-04-10 2122 NA #&gt; 3 2010-01-15 1057 109 #&gt; 4 2010-04-19 1444 174 #&gt; 5 2010-03-22 1445 138. #&gt; 6 2010-06-06 1888 190 #&gt; 7 2006-06-14 1072 140 #&gt; 8 2010-05-08 1188 142 #&gt; 9 2007-06-14 924 112. #&gt; 10 2007-09-01 2080 135 #&gt; # … with 2,038 more rows Note that in this renaming operations, only the variables mentioned in the select() function are kept. If you want to generate a tibble with some variables renamed while keeping all variables, you can use the rename() function. ahp %&gt;% rename(sold_date = dt_sold, living_area = liv_area) #&gt; # A tibble: 2,048 × 56 #&gt; sold_date yr_sold mo_sold yr_built yr_remodel bldg_class bldg_type #&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; #&gt; 1 2010-03-25 2010 3 1976 2005 60 1Fam #&gt; 2 2009-04-10 2009 4 1996 1997 60 1Fam #&gt; 3 2010-01-15 2010 1 1953 2007 20 1Fam #&gt; 4 2010-04-19 2010 4 2006 2007 60 1Fam #&gt; 5 2010-03-22 2010 3 1900 1993 50 1Fam #&gt; 6 2010-06-06 2010 6 1966 2002 20 1Fam #&gt; 7 2006-06-14 2006 6 2005 2006 180 TwnhsE #&gt; 8 2010-05-08 2010 5 1959 1959 20 1Fam #&gt; 9 2007-06-14 2007 6 1952 1952 20 1Fam #&gt; 10 2007-09-01 2007 9 1969 1969 60 1Fam #&gt; # … with 2,038 more rows, and 49 more variables: house_style &lt;chr&gt;, #&gt; # zoning &lt;chr&gt;, neighborhd &lt;chr&gt;, oa_cond &lt;dbl&gt;, oa_qual &lt;dbl&gt;, func &lt;chr&gt;, #&gt; # living_area &lt;dbl&gt;, 1fl_area &lt;dbl&gt;, 2fl_area &lt;dbl&gt;, tot_rms &lt;dbl&gt;, #&gt; # bedroom &lt;dbl&gt;, bathroom &lt;dbl&gt;, kit &lt;dbl&gt;, kit_qual &lt;chr&gt;, #&gt; # central_air &lt;chr&gt;, elect &lt;chr&gt;, bsmt_area &lt;dbl&gt;, bsmt_cond &lt;chr&gt;, #&gt; # bsmt_exp &lt;chr&gt;, bsmt_fin_qual &lt;chr&gt;, bsmt_ht &lt;chr&gt;, ext_cond &lt;chr&gt;, #&gt; # ext_cover &lt;chr&gt;, ext_qual &lt;chr&gt;, fdn &lt;chr&gt;, fence &lt;chr&gt;, fp &lt;dbl&gt;, … From this example, you can see the different behavior between select() and rename() when renaming variables. 6.4.3 Select Variables with Patterns Sometimes, you may want to select many variables that follows a particular pattern. a. select consecutive variables The first type of variable patterns is consecutive variables in a tibble. To get started, you can use select(1:m) to get the first m variables. To get the last column, you can use select(last_col()). To get the last m variables, you can use select(last_col(m-1):last_col()). ahp %&gt;% select(1:3) # the first 3 columns #&gt; # A tibble: 2,048 × 3 #&gt; dt_sold yr_sold mo_sold #&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2010-03-25 2010 3 #&gt; 2 2009-04-10 2009 4 #&gt; 3 2010-01-15 2010 1 #&gt; 4 2010-04-19 2010 4 #&gt; 5 2010-03-22 2010 3 #&gt; 6 2010-06-06 2010 6 #&gt; 7 2006-06-14 2006 6 #&gt; 8 2010-05-08 2010 5 #&gt; 9 2007-06-14 2007 6 #&gt; 10 2007-09-01 2007 9 #&gt; # … with 2,038 more rows ahp %&gt;% select(last_col()) # the last column #&gt; # A tibble: 2,048 × 1 #&gt; sale_price #&gt; &lt;dbl&gt; #&gt; 1 130. #&gt; 2 NA #&gt; 3 109 #&gt; 4 174 #&gt; 5 138. #&gt; 6 190 #&gt; 7 140 #&gt; 8 142 #&gt; 9 112. #&gt; 10 135 #&gt; # … with 2,038 more rows ahp %&gt;% select(last_col(1)) # the second to last column #&gt; # A tibble: 2,048 × 1 #&gt; wd_area #&gt; &lt;dbl&gt; #&gt; 1 0 #&gt; 2 0 #&gt; 3 0 #&gt; 4 100 #&gt; 5 0 #&gt; 6 0 #&gt; 7 0 #&gt; 8 0 #&gt; 9 0 #&gt; 10 335 #&gt; # … with 2,038 more rows ahp %&gt;% select(last_col(2):last_col()) # the last 3 columns #&gt; # A tibble: 2,048 × 3 #&gt; ep_area wd_area sale_price #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0 0 130. #&gt; 2 0 0 NA #&gt; 3 0 0 109 #&gt; 4 0 100 174 #&gt; 5 0 0 138. #&gt; 6 0 0 190 #&gt; 7 0 0 140 #&gt; 8 0 0 142 #&gt; 9 0 0 112. #&gt; 10 0 335 135 #&gt; # … with 2,038 more rows If you want to select all variables from yr_sold to yr_remodel in the tibble, you can use yr_sold:yr_remodel as a single argument in the select() function. Note that the result highly depends on the particular ordering of variables in the tibble. ahp %&gt;% select(yr_sold:yr_remodel, sale_price) #&gt; # A tibble: 2,048 × 5 #&gt; yr_sold mo_sold yr_built yr_remodel sale_price #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2010 3 1976 2005 130. #&gt; 2 2009 4 1996 1997 NA #&gt; 3 2010 1 1953 2007 109 #&gt; 4 2010 4 2006 2007 174 #&gt; 5 2010 3 1900 1993 138. #&gt; 6 2010 6 1966 2002 190 #&gt; 7 2006 6 2005 2006 140 #&gt; 8 2010 5 1959 1959 142 #&gt; 9 2007 6 1952 1952 112. #&gt; 10 2007 9 1969 1969 135 #&gt; # … with 2,038 more rows b. select variables with names that start with, end with, or contain a string Another commonly used pattern is to select all variables with names that start with, end with, or contain a string. To select all variables that begin with \"yr\" (representing year information) in the ahp data set, you can use the starts_with() function in the select() function. ahp %&gt;% select(starts_with(&quot;yr&quot;), sale_price) #&gt; # A tibble: 2,048 × 4 #&gt; yr_sold yr_built yr_remodel sale_price #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2010 1976 2005 130. #&gt; 2 2009 1996 1997 NA #&gt; 3 2010 1953 2007 109 #&gt; 4 2010 2006 2007 174 #&gt; 5 2010 1900 1993 138. #&gt; 6 2010 1966 2002 190 #&gt; 7 2006 2005 2006 140 #&gt; 8 2010 1959 1959 142 #&gt; 9 2007 1952 1952 112. #&gt; 10 2007 1969 1969 135 #&gt; # … with 2,038 more rows In the output, we can see three variables that begins with \"yr\" including the sold year, built year, and remodel year. We also include the sale_price in the select() function. You can also use ends_with() to select all variables with names that end with a particular string. ahp %&gt;% select(ends_with(&quot;qual&quot;)) #ending with qual #&gt; # A tibble: 2,048 × 7 #&gt; oa_qual kit_qual bsmt_fin_qual ext_qual fp_qual gar_qual heat_qual #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 6 Good GLQ Good &lt;NA&gt; Average Excellent #&gt; 2 7 Good GLQ Good Average Average Excellent #&gt; 3 5 Good GLQ Average &lt;NA&gt; Average Average #&gt; 4 5 Average Unf Average &lt;NA&gt; Average Good #&gt; 5 6 Average Unf Average &lt;NA&gt; Average Average #&gt; 6 6 Good ALQ Good Good Average Excellent #&gt; 7 6 Average GLQ Average &lt;NA&gt; Average Good #&gt; 8 5 Average Rec Average &lt;NA&gt; Average Fair #&gt; 9 5 Average Rec Average &lt;NA&gt; Average Average #&gt; 10 5 Fair Rec Average Average Average Average #&gt; # … with 2,038 more rows This produces a tibble with all quality related variables (ending with qual). If you want to select all variables with names containing a string (not necessarily starts with or ends with), you can use the contains() function with the string as its argument. ahp %&gt;% select(contains(&quot;mo&quot;)) #&gt; # A tibble: 2,048 × 2 #&gt; mo_sold yr_remodel #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 3 2005 #&gt; 2 4 1997 #&gt; 3 1 2007 #&gt; 4 4 2007 #&gt; 5 3 1993 #&gt; 6 6 2002 #&gt; 7 6 2006 #&gt; 8 5 1959 #&gt; 9 6 1952 #&gt; 10 9 1969 #&gt; # … with 2,038 more rows This outputs two variables named mo_sold and yr_remodel, both containing mo. You can also combine multiple conditions using logical operators. First of all, the multiple arguments in the select() function are combined with **or operations (|). For example, to get all variables that begins with b or ends with m, you can do the following. ahp %&gt;% select(starts_with(&quot;b&quot;), ends_with(&quot;m&quot;)) #&gt; # A tibble: 2,048 × 9 #&gt; bldg_class bldg_type bedroom bathroom bsmt_area bsmt_cond bsmt_exp #&gt; &lt;dbl&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 60 1Fam 3 2.5 725 Average No #&gt; 2 60 1Fam 4 3.5 913 Average No #&gt; 3 20 1Fam 3 2 1057 Average No #&gt; 4 60 1Fam 3 2.5 384 Average No #&gt; 5 50 1Fam 3 2 676 Good No #&gt; 6 20 1Fam 2 2.5 1517 Average No #&gt; 7 180 TwnhsE 2 3 547 Average Gd #&gt; 8 20 1Fam 3 2 1188 Average No #&gt; 9 20 1Fam 2 1 924 Average No #&gt; 10 60 1Fam 5 2.5 1040 Average Av #&gt; # … with 2,038 more rows, and 2 more variables: bsmt_fin_qual &lt;chr&gt;, #&gt; # bsmt_ht &lt;chr&gt; #ahp %&gt;% select(starts_with(&quot;b&quot;) | ends_with(&quot;m&quot;)) #equivalent For example, to get all variables that begins with b and ends with m, you can do the following. ahp %&gt;% select(starts_with(&quot;b&quot;) &amp; ends_with(&quot;m&quot;)) #&gt; # A tibble: 2,048 × 2 #&gt; bedroom bathroom #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 3 2.5 #&gt; 2 4 3.5 #&gt; 3 3 2 #&gt; 4 3 2.5 #&gt; 5 3 2 #&gt; 6 2 2.5 #&gt; 7 2 3 #&gt; 8 3 2 #&gt; 9 2 1 #&gt; 10 5 2.5 #&gt; # … with 2,038 more rows c. select variables except for the specified ones Sometimes, instead of specifying the variables to select, you want to keep all the variables except a few given ones. It works similar to the vector subsetting where you can add the negation sign ! before the indices. For example, to keep all variables except the ones of names ending with \"room\" in the sahp data set, you can use select(!ends_with(\"room\")). sahp %&gt;% select(!ends_with(&quot;room&quot;)) #&gt; # A tibble: 165 × 10 #&gt; dt_sold gar_car oa_qual liv_area lot_area house_style kit_qual heat_qual #&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt; &lt;chr&gt; #&gt; 1 2010-03-25 2 6 1479 13517 2Story Good Excellent #&gt; 2 2009-04-10 2 7 2122 11492 2Story Good Excellent #&gt; 3 2010-01-15 1 5 1057 7922 1Story Good Average #&gt; 4 2010-04-19 2 5 1444 9802 2Story Average Good #&gt; 5 2010-03-22 2 6 1445 14235 1.5Fin Average Average #&gt; 6 2010-06-06 2 6 1888 16492 1Story Good Excellent #&gt; 7 2006-06-14 2 6 1072 3675 SFoyer Average Good #&gt; 8 2010-05-08 2 5 1188 12160 1Story Average Fair #&gt; 9 2007-06-14 1 5 924 15783 1Story Average Average #&gt; 10 2007-09-01 2 5 2080 11606 2Story Fair Average #&gt; # … with 155 more rows, and 2 more variables: central_air &lt;chr&gt;, #&gt; # sale_price &lt;dbl&gt; 6.4.4 Reorder Variables via Names Knowing how to select and rename variables, let’s learn how to reorder variables in a tibble. The first approach to reordering variables is to use the select() function by listing all the variables in the desired order. However, you may realized that it would be time consuming if there are many variables in the tibble and we only want to move a few to the beginning. It turns out we can utilize the everything() function as an argument in the select() function, which will select all the remaining variables. Let’s say we want to move yr_sold and sale_price to the beginning of the tibble. ahp %&gt;% select(yr_sold, sale_price, everything()) #&gt; # A tibble: 2,048 × 56 #&gt; yr_sold sale_price dt_sold mo_sold yr_built yr_remodel bldg_class #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;date&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2010 130. 2010-03-25 3 1976 2005 60 #&gt; 2 2009 NA 2009-04-10 4 1996 1997 60 #&gt; 3 2010 109 2010-01-15 1 1953 2007 20 #&gt; 4 2010 174 2010-04-19 4 2006 2007 60 #&gt; 5 2010 138. 2010-03-22 3 1900 1993 50 #&gt; 6 2010 190 2010-06-06 6 1966 2002 20 #&gt; 7 2006 140 2006-06-14 6 2005 2006 180 #&gt; 8 2010 142 2010-05-08 5 1959 1959 20 #&gt; 9 2007 112. 2007-06-14 6 1952 1952 20 #&gt; 10 2007 135 2007-09-01 9 1969 1969 60 #&gt; # … with 2,038 more rows, and 49 more variables: bldg_type &lt;chr&gt;, #&gt; # house_style &lt;chr&gt;, zoning &lt;chr&gt;, neighborhd &lt;chr&gt;, oa_cond &lt;dbl&gt;, #&gt; # oa_qual &lt;dbl&gt;, func &lt;chr&gt;, liv_area &lt;dbl&gt;, 1fl_area &lt;dbl&gt;, 2fl_area &lt;dbl&gt;, #&gt; # tot_rms &lt;dbl&gt;, bedroom &lt;dbl&gt;, bathroom &lt;dbl&gt;, kit &lt;dbl&gt;, kit_qual &lt;chr&gt;, #&gt; # central_air &lt;chr&gt;, elect &lt;chr&gt;, bsmt_area &lt;dbl&gt;, bsmt_cond &lt;chr&gt;, #&gt; # bsmt_exp &lt;chr&gt;, bsmt_fin_qual &lt;chr&gt;, bsmt_ht &lt;chr&gt;, ext_cond &lt;chr&gt;, #&gt; # ext_cover &lt;chr&gt;, ext_qual &lt;chr&gt;, fdn &lt;chr&gt;, fence &lt;chr&gt;, fp &lt;dbl&gt;, … You can see the result is another tibble of 56 columns, with the first two columns being yr_sold and sale_price, followed by the remaining variables in the same order as in the original tibble ahp. "],["create-variables.html", "6.5 Create New Variables via mutate() and transmute()", " 6.5 Create New Variables via mutate() and transmute() You are now an expert in filtering observations (Section 6.1), reordering observations (Section 6.2), and selecting, renaming &amp; reordering variables (Section 6.4). In many applications, you may want to create new variables as functions of the existing ones. In this section, we will learn how to do this using the dplyr package. Let’s say you want to compute the average sale price per square foot for each house in the sahp data set. To highlight the useful columns, we first use select() to select the oa_qual, liv_area, and sale_price. Then, use the mutate() function to add a new variable named ave_price with the value sale_price/liv_area to the end. library(r02pro) library(tidyverse) sahp %&gt;% select(oa_qual, liv_area, sale_price) %&gt;% mutate(ave_price = sale_price/liv_area) #&gt; # A tibble: 165 × 4 #&gt; oa_qual liv_area sale_price ave_price #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 6 1479 130. 0.0882 #&gt; 2 7 2122 NA NA #&gt; 3 5 1057 109 0.103 #&gt; 4 5 1444 174 0.120 #&gt; 5 6 1445 138. 0.0958 #&gt; 6 6 1888 190 0.101 #&gt; 7 6 1072 140 0.131 #&gt; 8 5 1188 142 0.120 #&gt; 9 5 924 112. 0.122 #&gt; 10 5 2080 135 0.0649 #&gt; # … with 155 more rows From the result, you can check that the resulting tibble has 4 columns, with the last column being the newly created variable ave_price. You can use mutate() to create multiple variables at the same time following the same format. sahp %&gt;% select(oa_qual, liv_area, sale_price, lot_area) %&gt;% mutate(ave_price = sale_price/liv_area, area = lot_area + liv_area) #&gt; # A tibble: 165 × 6 #&gt; oa_qual liv_area sale_price lot_area ave_price area #&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 6 1479 130. 13517 0.0882 14996 #&gt; 2 7 2122 NA 11492 NA 13614 #&gt; 3 5 1057 109 7922 0.103 8979 #&gt; 4 5 1444 174 9802 0.120 11246 #&gt; 5 6 1445 138. 14235 0.0958 15680 #&gt; 6 6 1888 190 16492 0.101 18380 #&gt; 7 6 1072 140 3675 0.131 4747 #&gt; 8 5 1188 142 12160 0.120 13348 #&gt; 9 5 924 112. 15783 0.122 16707 #&gt; 10 5 2080 135 11606 0.0649 13686 #&gt; # … with 155 more rows This operation adds two new columns ave_price and area to the existing tibble. Note that the mutate() function can only use the variables inside the select() function. The following code will show an error since liv_area is not included in the select() function. sahp %&gt;% select(oa_qual, liv_area, sale_price) %&gt;% mutate(ave_price = sale_price/liv_area, area = lot_area + liv_area) #&gt; Error: Problem with `mutate()` input `area`. #&gt; x object &#39;lot_area&#39; not found #&gt; ℹ Input `area` is `lot_area + liv_area`. Note that you are free to use any functions on a vector, including all the arithmetic operations and various functions. For example, to include the order of each house in terms of sale price, you can use mutate(sale_price_order = order(sale_price)). To create a variable as the mean of the sale prices of all houses, you can add sale_price_ave = mean(sale_price) as an argument in the mutate() function. sahp %&gt;% filter(sale_price &gt; 400) %&gt;% select(sale_price) %&gt;% mutate(sale_price_order = order(sale_price), sale_price_ave = mean(sale_price)) #&gt; # A tibble: 5 × 3 #&gt; sale_price sale_price_order sale_price_ave #&gt; &lt;dbl&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 465 5 466. #&gt; 2 545. 4 466. #&gt; 3 457. 3 466. #&gt; 4 442. 1 466. #&gt; 5 421. 2 466. From the result, you can see that sale_price_order represent the order for each house in terms of sale price while the sale_price_ave has a constant value for all houses. The different behavior lies in the fact that the function order() returns another vector of the same length as the input, while mean() always returns a vector of length 1, which is recycled to fill in the new variable sale_price_ave. Once creating the new variables, you can immediately use them to do visualization. Let’s say we want to create a scatterplot between area and ave_price, using different colors to represent whether oa_qual &gt; 5. sahp %&gt;% mutate(ave_price = sale_price/liv_area, area = lot_area + liv_area) %&gt;% ggplot() + geom_point(mapping = aes(x = area, y = ave_price, color = oa_qual &gt; 5)) This plots shows that the average sale price does not have a trend when the total area changes. In addition, the “good” quality houses (oa_qual &gt; 5) has a higher ave_price in general when the total area is the same. Using the mutate() function, we add newly created variable while keeping all the existing ones. If you want to only keep the newly created variables, you can use the transmute() function. sahp %&gt;% transmute(ave_price = sale_price/liv_area, area = lot_area + liv_area) #&gt; # A tibble: 165 × 2 #&gt; ave_price area #&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 0.0882 14996 #&gt; 2 NA 13614 #&gt; 3 0.103 8979 #&gt; 4 0.120 11246 #&gt; 5 0.0958 15680 #&gt; 6 0.101 18380 #&gt; 7 0.131 4747 #&gt; 8 0.120 13348 #&gt; 9 0.122 16707 #&gt; 10 0.0649 13686 #&gt; # … with 155 more rows "],["create-grouped-summaries.html", "6.6 Create Grouped Summaries via group_by() and summarize()", " 6.6 Create Grouped Summaries via group_by() and summarize() In Section 6.5, you learned how to create new variables as functions of the existing ones. For example, we created a variable representing the average sale price of all houses. Perhaps you want to know the average sale price for houses of a particular over all condition. The dplyr package provides two useful functions to achieve this: namely group_by() which can group the observations according to the specified variables, and summarize() which create summaries for each group. 6.6.1 Create Summaries To create summaries for a variable, you can use the summarize() function. Let’s compute the number of houses, the average living area, and the 1st and 3rd quartile sale price of all houses. library(r02pro) library(tidyverse) ahp %&gt;% summarize(n_houses = n(), ave_liv_area = mean(liv_area), prob = c(0.25, 0.75), q_price = quantile(sale_price, c(0.25, 0.75), na.rm = TRUE)) #&gt; # A tibble: 2 × 4 #&gt; n_houses ave_liv_area prob q_price #&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 2048 1500. 0.25 130. #&gt; 2 2048 1500. 0.75 214 Note that here we use the n() function to count the number of houses. And the prob argument is included to represent the corresponding quantiles levels. 6.6.2 Create Grouped Summaries So far, we have learned to use summarize() to create summaries for all observations. In practical applications, it is often more useful to compute the summaries when the observations are grouped according to certain criteria. Let’s say we want to create the same summaries for each value of overall quality (oa_qual). Then, we need to add a group_by() function before applying the summarize() function. ahp %&gt;% group_by(oa_qual) %&gt;% summarize(n_houses = n(), ave_liv_area = mean(liv_area), prob = c(0.25, 0.75), q_price = quantile(sale_price, c(0.25, 0.75), na.rm = TRUE)) #&gt; `summarise()` has grouped output by &#39;oa_qual&#39;. You can override using the `.groups` argument. From the output, you can see that for each value of oa_qual, we have two rows representing different quantile values. It is interesting to visualize the relationship between the oa_qual and the quantile price (q_price), with different colors for the 1st and 3rd quantile. ahp %&gt;% group_by(oa_qual) %&gt;% summarize(n_houses = n(), ave_liv_area = mean(liv_area), prob = c(0.25, 0.75), q_price = quantile(sale_price, c(0.25, 0.75), na.rm = TRUE)) %&gt;% ggplot(mapping = aes(x = oa_qual, y = q_price, color = factor(prob))) + geom_point() + geom_smooth() #&gt; `summarise()` has grouped output by &#39;oa_qual&#39;. You can override using the `.groups` argument. #&gt; `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; This figure is very informative, showing that both the 1st quartile and 3rd quantile of the sale price increases as the overall quality increases. "],["tidy-data.html", "Chapter 7 Tidy Data", " Chapter 7 Tidy Data In the part several chapters, you have learned a lot in data visualization, data import and export, and data manipulation. All the data you have seen so far share a very attractive property, namely, they are all tidy. So, what is the so called tidy data? Following the definition in Wickham and Grolemund (2016), tidy data has the following three interrelated properties. Each variable must have its own column. Each observation must have its own row. Each value must have its own cell. These properties of tidy data enable us to conduct efficient data manipulation and visualization. Note that in practical applications, many collected data is untidy. Although untidy data could also be very useful in terms of reporting and visually more intuitive, you are recommended to tidy it before applying the tools we learned in this course. References "],["tidy-name-value.html", "7.1 Convert Between Names and Values", " 7.1 Convert Between Names and Values First, let’s create an artificial dataset which contains the weights of a sheep and a pig for years 2019, 2020, and 2021. library(tibble) animal &lt;- rep(c(&quot;sheep&quot;,&quot;pig&quot;), c(3,3)) year &lt;- rep(2019:2021, 2) weight &lt;- c(110, 120, 140, NA, 300, 800) animal_tidy &lt;- tibble(animal, year, weight) animal_tidy #&gt; # A tibble: 6 × 3 #&gt; animal year weight #&gt; &lt;chr&gt; &lt;int&gt; &lt;dbl&gt; #&gt; 1 sheep 2019 110 #&gt; 2 sheep 2020 120 #&gt; 3 sheep 2021 140 #&gt; 4 pig 2019 NA #&gt; 5 pig 2020 300 #&gt; 6 pig 2021 800 By checking the definition of tidy data, it is clear animal_tidy is indeed tidy. Let’s make it untidy. 7.1.1 Convert Values into Column Names In animal_tidy, each row contains the year when the weight measurement was taken. Suppose we want to convert the year value into column names. You can use the pivot_wider() function in tidyr package, another member of the tidyverse package. In pivot_wider(), you need to specify two arguments: names_from denotes which column in the original tibble contains the values of the new column names, values_from denotes which column in the original tibble contains the values for each cell in the new tibble. The reason why the function is called pivot_wider() is due to the fact that it will create a wider dataset than the orginal one, containing more columns. library(tidyr) animal_wide &lt;- animal_tidy %&gt;% pivot_wider(names_from = year, values_from = weight) animal_wide #untidy animal: wide #&gt; # A tibble: 2 × 4 #&gt; animal `2019` `2020` `2021` #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 sheep 110 120 140 #&gt; 2 pig NA 300 800 In animal_wide, we have the columns names 2019, 2020, and 2021 coming from the year variable, and the values 110, 120, 140, NA, 300, and 800 from the weight variable, both of which are in the original tibble animal_tidy. The animal_wide is clearly untidy, since neither the weight nor the year information is contained in a single column. Note that this data format is commonly encountered in practice. As it is clear from the resulting tibble, the name weight is lost during the pivoting process, which is not desirable. Fortunately, you can add a prefix “weight” to the column names via an argument names_prefix in the pivot_wider() function. animal_wide_weight &lt;- animal_tidy %&gt;% pivot_wider(names_from = year, names_prefix = &quot;weight&quot;, values_from = weight) animal_wide_weight #&gt; # A tibble: 2 × 4 #&gt; animal weight2019 weight2020 weight2021 #&gt; &lt;chr&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; #&gt; 1 sheep 110 120 140 #&gt; 2 pig NA 300 800 7.1.2 Convert Column Names into Values Now, you will learn how to tidy animal_wide into a tidy data. To do this, you can use the pivot_longer() function to convert the columns names 2019, 2020, and 2021 into values of a variable, for example, year. animal_wide %&gt;% pivot_longer(cols = -1, names_to = &quot;year&quot;, values_to = &quot;weight&quot;) In pivot_longer(), cols specifies the column names that you want to convert from, which accept the same format as that in dplyr::select() introduced in Section ?. names_to specifies the variable name you want to use for the column names. Finally, values_to specifies the variable name for holding the values in the selected columns. You can see that we have recovered the animal_tidy through the tidy process. To tidy animal_wide_weight, we can use the same function pivot_longer() along with the argument names_prefix as below. animal_wide_weight %&gt;% pivot_longer(cols = -1, names_to = &quot;year&quot;, names_prefix = &quot;weight&quot;, values_to = &quot;weight&quot;) In this regards, pivot_wider() and pivot_longer() can be viewed as opposite functions. "],["strings.html", "Chapter 8 Strings", " Chapter 8 Strings "],["statistics.html", "Chapter 9 Statistics", " Chapter 9 Statistics In this chapter, you will dive into the world of statistics. As a language initially designed for statistical computing, R undoubtedly provides a wide range of functions related to all aspects of probability and statistics. You will start with functions related to normal distribution in Section 9.1. "],["normal-distribution.html", "9.1 Normal Distribution", " 9.1 Normal Distribution First, let’s review the definition of normal distribution, which is also called Gaussian distribution. If \\(X\\sim N(\\mu, \\sigma^2)\\), we say \\(X\\) is a random variable following a normal distribution with mean \\(\\mu\\) and variance \\(\\sigma^2\\). In the following table, we list the four useful functions for normal distribution, and they will be introduced in the subsequent four parts, respectively. Code Name Section dnorm(x, mean, sd) probability density function 9.1.1 pnorm(q, mean, sd) cumulative distribution function 9.1.2 qnorm(p, mean, sd) quantile function 9.1.3 rnorm(n, mean, sd) random number generator 9.1.4 9.1.1 Probability density function (pdf) To characterize the distribution of a continuous random variable, you can use the probability density function (pdf) . When \\(X\\sim N(\\mu,\\sigma^2)\\), its pdf is \\[f(x) = \\frac{1}{\\sqrt{2\\pi \\sigma}}\\exp\\left[-\\frac{(x-\\mu)^2}{2\\sigma^2}\\right].\\] In R, you can use dnorm(x, mean, sd) to calculate the pdf of normal distribution. The argument x represent the location(s) at which to compute the pdf. The arguments mean and sd represent the mean and standard deviation of the normal distribution, respectively. For example, dnorm(0, mean = 1, sd = 2) computes the pdf at location 0 of \\(N(1, 4)\\), normal distribution with mean 1 and variance 4. Note that the argument sd is the standard deviation, which is the square root of the variance. In particular, dnorm() without specifying the mean and sd arguments will compute the pdf of \\(N(0,1)\\), which is the standard normal distribution. Let’s see examples of computing the pdf at one location for three different normal distributions. dnorm(0, mean = 1, sd = 2) dnorm(1, mean = -1, sd = 0.5) dnorm(0) #standard normal In addition to computing the pdf at one location for a single normal distribution, dnorm also accepts vectors with more than one elements in all three arguments. For example, you can use the following code to compute the three pdf values in the previous code block. dnorm(c(0,1,0), mean = c(1, -1, 0), sd= c(2, 0.5, 1)) If you want to compute the pdf at the same location 0 for distributions \\(N(1,4)\\), \\(N(-1, 0.25)\\), and \\(N(0, 1)\\), you can use the following code. dnorm(0, mean = c(1, -1, 0), sd= c(2, 0.5, 1)) If you want to compute the pdf at three different locations (-3, 2, and 5) for distribution \\(N(3, 4)\\), you can use the following code. dnorm(c(-3, 2, 5), mean = 3, sd = 2) To get a better understanding on the shape of the normal pdf, let’s visualize the pdf of \\(N(0,1)\\). You first need to create a equal-spaced vector x from -5 to 5 with increment 0.1. Then, you can compute the pdf value for each element of x using dnorm. Finally, you can visualize the pdf using geom_line. library(ggplot2) x &lt;- seq(from = -5, to = 5, by = 0.05) norm_dat &lt;- data.frame(x = x, pdf = dnorm(x)) ggplot(norm_dat) + geom_line(aes(x = x, y = pdf)) Next, you can take a step further to visualize three different normal distributions in the same plot, \\(N(0,1)\\), \\(N(1,4)\\), and \\(N(-1, 0.25)\\). You can use the same vector x and compute the three pdfs on each element of x. geom_line is still used with the variable dist mapped to the color aesthetic. x &lt;- seq(from = -5, to = 5, by = 0.05) norm_dat_1 &lt;- data.frame(dist = &quot;N(0,1)&quot;, x = x, pdf = dnorm(x)) norm_dat_2 &lt;- data.frame(dist = &quot;N(1,4)&quot;, x = x, pdf = dnorm(x, mean = 1, sd = 2)) norm_dat_3 &lt;- data.frame(dist = &quot;N(-1, 0.25)&quot;, x = x, pdf = dnorm(x, mean = -1, sd = 0.5)) norm_dat &lt;- rbind(norm_dat_1, norm_dat_2, norm_dat_3) ggplot(norm_dat) + geom_line(aes(x = x, y = pdf, color = dist)) 9.1.2 Cumulative distribution function (cdf) In addition to pdf, you can compute the cumulative distribution function (cdf) of the normal distribution using the function pnorm(q, mean, sd). Generally speaking, the cdf of a random variable \\(X\\) is defined as \\[F(x) = P(X\\leq x).\\] Similar to dnorm(), pnorm() also has two optional arguments, mean and sd, which represent the mean and standard deviation of the normal distribution, respectively. If you don’t specify these two arguments, pnorm() will compute the cdf of \\(N(0,1)\\). pnorm(0, mean = 1, sd = 2) pnorm(0) # cdf at 0 of standard normal You can also use pnorm() to visualize the cdf of the standard normal distribution. q &lt;- seq(from = -5, to = 5, by = 0.1) norm_dat &lt;- data.frame(q = q, cdf = pnorm(q)) ggplot(norm_dat) + geom_line(aes(x = q, y = cdf)) 9.1.3 Quantile function The third useful function related to distributions is the quantile function. You can compute the quantile of the normal distribution using qnorm(p, mean, sd). The quantile function is the inverse function of the cdf. In particular, the \\(p\\) quantile returns the value \\(x\\) such that \\[F(x) = P(X\\leq x) = p\\] Let’s verify qnorm() is indeed the inverse function of pnorm() using the following example. pnorm(qnorm(c(0.5,0.7))) When \\(p=0.5\\), qnorm() gives us the median of the normal distribution. Let’s see a few examples for computing the quantiles. qnorm(0.5, mean = 1, sd = 2) qnorm(0.5) You can also visualize the shape of the quantile function. p &lt;- seq(from = 0.01, to = 0.99, by = 0.01) norm_dat &lt;- data.frame(p = p, quantile = qnorm(p)) ggplot(norm_dat) + geom_line(aes(x = p, y = quantile)) 9.1.4 Random Number Generator Lastly, to generate (pick up) random numbers from normal distributions, you can use the function rnorm(n, mean, sd) , with the argument n represents the number of random numbers to generate, the arguments mean and sd are the mean and standard deviation of the normal distribution you would like to generate from, respectively. Again, if you only supply the argument n, you will be generating random numbers from \\(N(0,1)\\). rnorm(3, mean = 0, sd = 1) #generate 3 random numbers from N(0, 1) rnorm(3) #generate another 3 random numbers from N(0,1) Since you are generating random numbers, the results may be different each time. In many applications, however, you may want to make the results reproducible. To do this, you can set random seed using the function set.seed() before generating the random numbers. Let’s see the following example. set.seed(724) rnorm(3) Now, let’s run it one more time. set.seed(724) rnorm(3) You can see that the exact 3 numbers are reproduced since you are using the same random seed 724. You can run these two lines of code on any machine and will get the exact same three random numbers. Note that the code that involves randomness needs to be identical to reproduce the results. If you change the arguments in rnorm(), you will get totally different results. See the following example. set.seed(724) rnorm(1) rnorm(3) By setting a different random seed, you will see different results as the following example. set.seed(826) rnorm(3) Lastly, let’s do a simple statistical exercise by checking the closeness of the sample mean and sample standard deviation to their population counterparts. x &lt;- rnorm(1e6, mean = 1, sd = 2) mean(x) #sample mean sd(x) #sample standard deviation 9.1.5 Exercise You can run the following code to do the exercise. r02pro(&quot;8.1&quot;) "],["other-distributions.html", "9.2 Other Distributions", " 9.2 Other Distributions In Section 9.1, we gave a detailed introduction to the four functions for a normal distribution, which is a popular continuous distribution. In particular, we now know that dnorm() produces the pdf of a normal distribution. In the case of discrete distributions, however, we would have probability mass function (pmf) instead of the pdf. Let’s use the binomial distribution as a representative example of discrete distributions with the four functions as below. Now, let’s look at a few other commonly used distributions. For simplicity, let’s just use the random number generator for each distribution in the following table. As we can see from this table, all random number generator functions are formed by the letter r followed by the name of the distribution we would like to generate from. For the other three functions, we just need to change the initial letter r: to d for pdf (continuous distribution) or pmf (discrete distribution), to p for cdf, to q for quantile function. Let’s do some statistical exercise with those distributions. 9.2.1 Exercise You can run the following code to do the exercise. r02pro(&quot;8.2&quot;) "],["sampling.html", "9.3 Random Permutation and Random Sampling", " 9.3 Random Permutation and Random Sampling Now, you have covered how to work with distributions in R with the four useful functions for each distribution. In many applications, you may want to randomly permute or sample elements from a vector. Let’s see how to do that. The vector x &lt;- 6:10 will be used throughout this section. 9.3.1 Random Permutation In statistics and machine learning, you usually need to do a random permutation of the data. For example, you can evaluate a model’s performance by dividing the data randomly into two parts for training and validation, respectively. For the vector x &lt;- 6:10, you can use the function sample() to get a permutation for x. x &lt;- 6:10 set.seed(97) sample(x) #a random permutation of x To reproduce the random permutation, we can use the same seed. set.seed(97) sample(x) #reproduce the random permutation 9.3.2 Random Sampling without Replacement Note that the vector x has 5 elements in total. To sample a few elements from x, you can again use the sample() function. For example, if you want to randomly sample two elements from x, you can use the following code sample(x, size = 2) Here, the size argument specify the targeted number of elements. By default, the sample function take a sample without replacement, i.e. the results sample has no duplicated elements. Because of this, if the size is larger than the length of the vector x, you will see an error message as follows. sample(x, size = 6) #&gt; Error in sample.int(length(x), size, replace, prob): cannot take a sample larger than the population when &#39;replace = FALSE&#39; In addition to using a vector in the first argument of sample, you can also use a positive integer (e.g., 10), which will be equivalent to x = 1:10. See the following code for an example. sample(10, size = 4) #sample 4 integers from 1 to 10. sample(1:10, size = 4) #sample 4 integers from 1 to 10. 9.3.3 Random Sampling with Replacement Sometimes, you may want to get a sample with replacements. You will still be using the sample function, but setting the argument replace = TRUE. The following code samples 10 elements with replacement from x. sample(x, size = 10, replace = TRUE) As expected, you will see some duplicated elements in the output vector. A very important application of random sample with replacement is bootstrap. A bootstrap sample is a sample of the same size as the original data with replacement. So, if you want to get a bootstrap sample from x, you will sample 5 elements with replacement from x. sample(x, replace = TRUE) #a bootstrap sample Note that, when the argument size is not provided, it will take the default value: the length of x. 9.3.4 Random Sampling with Unequal Probabilities By default, the sample() function will draw each element with the same probability. In some cases, you may want to assign different probabilities for different elements. To draw elements with different probabilities, the first method is to use the random number generator for Binomial distribution or Bernoulli distribution. Let’s say we want to randomly sample 100 elements from a Bernoulli distribution with success probability \\(p=0.2\\). rbinom(100, size = 1, prob = 0.2) In addition to using the rbinom function introduced in Section 9.2, you can use the sample function with the prob argument inside to achieve the same goal. sample(c(0, 1), size = 100, replace = TRUE, prob = c(0.8, 0.2)) You will samples 100 elements with replacement from c(0,1) here, and the probability of drawing 0 is 0.8, the probability of drawing 1 is 0.2. 9.3.5 Exercise You can run the following code to do the exercise. r02pro(&quot;8.3&quot;) "],["covariance-correlation.html", "9.4 Covariance and Correlation", " 9.4 Covariance and Correlation In this section, we will dive further into statistics, this time talking about the relationship among variables. For two random variables \\(X\\) and \\(Y\\), the covariance between them is defined as \\(Cov(X, Y) = E[(X-E(X))(Y-E(Y))]\\). set.seed(724) n &lt;- 1e5 x1 &lt;- rnorm(n) x2 &lt;- x1 + rnorm(n) x3 &lt;- x2 + rnorm(n) cor(x1, x2) cor(x1, x3) cor(x2, x3) x &lt;- data.frame(x1, x2, x3) cor(x) #correlation matrix cov(x) #covariance matrix 9.4.1 Exercise You can run the following code to do the exercise. r02pro(&quot;8.4&quot;) "],["write-code.html", "Chapter 10 Writing Complicated Codes", " Chapter 10 Writing Complicated Codes "],["r-markdown.html", "Chapter 11 R Markdown", " Chapter 11 R Markdown In Section 1.1.2, we learned how to create a new R script. R script is useful for organizing R code and add brief comments. However, to write document with more complicated structure, you need to use something more sophisticated. In this chapter, we introduce a new file format, namely the R Markdown file (.rmd). Using R Markdown, you can turn the data analyses into high quality documents, reports, presentations, books, and many other possible forms. "],["intro-r-markdown.html", "11.1 Introduction to R Markdown", " 11.1 Introduction to R Markdown R Markdown is an interactive and dynamic file format in R. An R Markdown file can be transformed into a document of many different types, including HTML, PDF, and Word. 11.1.1 Create a new R Markdown document To create an R Markdown document, you can click the + button on the R Studio menu, then select R Markdown. Figure 11.1: create a new R Markdown document (I) Then you will see a window pops up like Figure 11.2. Figure 11.2: create a new R Markdown document (II) Here, you can enter the Title and Author of the document, and select one of the output formats: HTML, PDF and Word. In our opinion, HTML is the recommended format for authoring. If you want to generate a PDF, you need to have a Tex installation, which would have already been installed if you write LaTex documents on the computer. If necessary, you can install TinyTeX with the R package tinytex. install.packages(&quot;tinytex&quot;) tinytex::install_tinytex() A word of caution is needed here. We have seen a lot of people having issues with the installation of the Tex system. The exact cause is sometimes tricky to track. It could be the operating system, the physical location, existing software installed on the computer, or something else. If an error message shows up during the installation process, you are not alone. You could try to search the error message using a search engine. If generating PDF file is a must, as a last resort, you can first generate a word document and convert it into a pdf file afterward. After clicking OK, you have created an R Markdown document with file extension .Rmd. You can save the file with a desired name on the disk by clicking the save button or using keyboard shortcut of saving files. Here, we use the name Lesson 10.1. It is clear to see the difference of file extension between R Markdown document and R script. Figure 11.3: R Markdown vs. R Script 11.1.2 Knit the R Markdown document To generate the final output document, you need to knit the .Rmd file. To do that, you can click the Knit button shown in the following figure. Figure 11.4: Knit button Then you will get an HTML, PDF, or Word document, according to the chosen document type. Let’s take a look at the HTML document together, Figure 11.5: HTML document A document consists of components three different types. The first type is the header of document, the second type is text, and the third type is related to codes and the results. Since the output document is rendered from the .Rmd file, the .Rmd file also has three type of components accordingly. If you want to make any changes on the output document, you need to make the necessary changes on the .Rmd file and knit it again. Next, we introduce how to write an R Markdown document. 11.1.3 Write an R Markdown document Unlike R script, you may notice that RStudio provides an example of the .Rmd file after creating an R Markdown document. It is then straightforward for you to get started by replacing the example with your own contents. By now you know that there are three parts in the .Rmd file. Let’s go over them one by one. a. YAML header The first part is a YAML header (Yet Another Markup Language), which is a section of key: value pairs surrounded by --- marks, like below. --- title: &quot;Untitled&quot; author: &quot;r02pro&quot; date: &quot;8/31/2021&quot; output: html_document --- It is used to specify the document information, including the title, author, date, and output format. The output: recognizes the following values: html_document, which will create HTML output (default) pdf_document, which will create PDF output word_document, which will create Word output b. Text After the YAML header, you can see some text. Unlike R script, you don’t need to use the pound sign # to write text in an R Markdown document. Indeed, you can write as if you are writing in a text editor, though R Markdown provides a rich collection of text formats, which will be discussed in Section 11.2. c. Code Chunks The last component type is related to R codes. Different from R script, the R code is usually contained in the code chunks in the .Rmd file. So what is a code chunk? A code chunk is basically a collection of R codes surrounded by the chunk delimiters ```{r} and ```. Let’s take a look at one code chunk as follows. Figure 11.6: An R Code Chunk In this code chunk, there is only one line of code summary(cars) which will output the summary statistics of the cars data set. If necessary, you can include any lines of codes inside each code chunk. Each chunk can be viewed as a unit that usually serves a particular purpose. Inside each code chunk, you can run the codes line by line by the keyboard shortcut Cmd + Enter / Ctrl + Enter. However, it is often more convenient to run the codes all at once using the keyboard shortcut Shift + Cmd + Enter / Shift + Ctrl + Enter, or press the Green arrow on the right of the code chunk. Then you will see both R code and the result from the output document by default. Figure 11.7: R code and the result In addition to the R code, you may be wondering what do the arguments in the big parentheses { } work for. Here, we will introduce a few useful chunk options which control the behavior of each code chunk. “r cars” gives the code chunk the name “pressure,” which is useful to navigate between different chunks, and it is also necessary to give the code chunk a name if you want to cross reference the corresponding figure in the knitted document. eval = FALSE prevents codes from being evaluated. This is useful when you want to show the code but don’t want to run it. Default value is eval = TRUE. include = FALSE prevents code and results from appearing in the knitted file. The code will still be evaluated. Default value is include = TRUE. echo = FALSE prevents code, but not the results from appearing in the knitted file. This is useful if you want to embed figures in the document without showing the code used to generate them. Default value is echo = TRUE. message = FALSE prevents messages that are generated by code from appearing in the knitted file. Default value is message = TRUE. warning = FALSE prevents warnings that are generated by code from appearing in the knitted file. Default value is warning = TRUE. There are many other available options in an R Markdown code chunk. You can refer to the webpage https://yihui.org/knitr/options/ for details. Now let’s see some examples together. If you add the chunk option eval = FALSE. Figure 11.8: Add eval = FALSE Then you will see the code without the result from the output. Figure 11.9: Only see the code If you add the chunk option echo = FALSE, Figure 11.10: Add echo = FALSE you will see the result without the code from the output. Figure 11.11: Only see the result You can try to add other chunk options by yourself! Lastly, if you have many code chunks that share some chunk options, it is very useful to set the global chunk options at the beginning of an R Markdown document. To do that, you can add the following chunk right after the YAML header. Figure 11.12: global chunk options In this example, we set echo = TRUE and warning = FALSE. You can feel free to change their values and add other customizations. In each subsequent chunk, this set of global chunk options will be inherited. Of course, you can add additional options in each chunk to add additional chunk options or overwrite the global chunk options. This may be reminiscent of the relationship between global and local aesthetic mappings introduced in Section 4.6. "],["rmd-text-formating.html", "11.2 Text Formatting in R Markdown", " 11.2 Text Formatting in R Markdown Having learned the YAML Header and R Code Chunks in Section 11.1, we will introduce how to format text in R Markdown document, which is crucial in writing a report. In particular, R Markdown follows the syntax of Pandoc’s Markdown, a set of markup annotations for plain text files. Pandoc (https://pandoc.org/) is a universal document converter that converts documents from one markup format into another. Here, text in the .Rmd file is called the marked up text, and text in the output document is called the formatted text. When you knit the .Rmd file, Pandoc transforms the marked up text into formatted text in the specified file format. In this section, we will introduce how to get several kinds of formatted text in the output document by compiling the .Rmd file. 11.2.1 Special text formats Firstly, let’s discuss how to generate a couple of special formatted text. a. different header levels You may use different numbers of “#” before the marked up text to generate different header levels in the output document. (with more “#”s indicating lower levels and smaller fonts). For example, you can try to the following lines in the .Rmd file and see what happens in the output document, # Header1 ## Header2 ### Header3 #### Header4 ##### Header5 ###### Header6 b. change the text into italic type To make the formatted text into italic type, you can simply use a pair of * around the text with no space. For example *italic* in the .Rmd file generates italic in the output document. c. change the text into bold type To make the formatted text into bold type, you can simply use a pair of ** around the marked up text with no space. For example **bold** in the .Rmd file generates bold in the output document. d. create inline code emphasize texts by marking them as inline codes, not recommend Sometimes you may want to mark text or code as inline code. To do that, you need to use a pair of ` around the text or code. We have seen many inline codes so far. For example, *italic* is an inline code. Another common usage is when you want to include code along with other text outside code chunks. For example `1 + 1` in the markup text generates 1 + 1 in the formatted text. Here, we only display the code without running it. If you want to show the output instead of code, you can use `r `. For example, `r 1 + 1` will generate 2 in the formatted text. Note that if you add a pair of ` around code inside the the code chunk, you will get an error message when you knit the file. Figure 11.13: Error message (I) Figure 11.14: Error message (II) e. insert hyperlinks To insert a hyperlink in the output document, you can use the format [link](address) in the .Rmd file. For example, [r02pro](https://r02pro.github.io/) in the .Rmd file will generate the text r02pro with hyperlink to this book in the output document. f. write latex equations When writing documents that contain math symbols or equations, you can use latex equations directly in an R Markdown file, just like writing a .tex file. For example, you can use $\\sum_{i=1}^{10} i = 55$ in the .Rmd file to get \\(\\sum_{i=1}^{10} i= 55\\) in the output document. You can also use a pair of $$ to write in display math mode. Say $$\\sum_{i=1}^{10} i = 55$$ in the .Rmd file will generate \\[\\sum_{i=1}^{10} i = 55\\] in the output document. Lastly, please see the an example which has all components introduced in this part. You can copy the following lines and paste them on an R Markdown document, then click the knit button to see what will you get in the ouput document. # H1 *This is an example.* ## H2 I **learned** to use `a &lt;- rnorm(1)` to generate normal distributed random variable in [r02pro](https://r02pro.github.io/). The result of `1 + 1` is 2. ### H3 I learned how to sum up numbers when I was young. For example, $$\\sum_{i=1}^{10} i = 55$$ 11.2.2 Lists in R Markdown Secondly, we will introduce how to generate lists in the output document. There are two kinds of lists, unordered lists and ordered lists. Generally, To create an unordered list, you can use the symbol *, +, or - at the beginning of the line with a space between the symbol and the text. To create higher order lists, you just need to add extra indent at the beginning of the line. Different layers have different indents and you need to align the items of the same order. Normally, there are at most three layers in a list. Please feel free to try the following example and edit it to your need. * Item 1 * Item 2 + Item 2a - Item 2a.a - Item 2a.b + Item 2b * Item 3 + Item 3a You will see the following output in the formatted text. Item 1 Item 2 Item 2a Item 2a.a Item 2a.b Item 2b Item 3 Item 3a To create an ordered list, you can use numbers followed by the contents with a space in between. Similar to unordered list, you can add extra layers as needed. Please see the following example with some Spanish numbers. 1. uno 2. dos 2.1. dos.uno 2.2. dos.dos 3. tres 3.1. tres.uno 3.2. tres.dos You will see the following output. uno dos 2.1. dos.uno 2.2. dos.dos tres 3.1. tres.uno 3.2. tres.dos Of course, you can also mix ordered and unordered lists. Feel free to try the following example in your .Rmd file. 1. Item 1 2. Item 2 + Item 2a - Item 2a.a - Item 2a.b + Item 2b 3. Item 3 + Item 3a 11.2.3 Tables in R Markdown In addition to lists, you can easily create tables using R Markdown via the kable() function in the knitr package. You need to install the knitr package if you haven’t done so. You can study the following example and adapt it to your needs. ```{r echo = FALSE, results = TRUE} Code &lt;- c(&quot;`dnorm(x, mean, sd)`&quot;,&quot;`pnorm(q, mean, sd)`&quot;,&quot;`qnorm(p, mean, sd)`&quot;,&quot;`rnorm(n, mean, sd)`&quot;) Name &lt;- c(&quot;probability density function&quot;, &quot;cumulative distribution function&quot;, &quot;quantile function&quot;, &quot;random number generator&quot;) d &lt;- data.frame(Code, Name) knitr::kable(d) ``` Code Name dnorm(x, mean, sd) probability density function pnorm(q, mean, sd) cumulative distribution function qnorm(p, mean, sd) quantile function rnorm(n, mean, sd) random number generator 11.2.4 Insert citations and manage bibliographies in R Markdown R Markdown provides us the capability to add bibliography and manage citations with ease, similar to writing a LaTex document. To add citations, you first need to add the bibliography filed in the YAML head. If your references are in the file “references.bib,” you can set the bibliography file as follows. --- output: html_document bibliography: references.bib --- The .bib file is a plain-text file that consists of bibliography entries like the following: @book{r02pro, title = {R Programming: From Zero to Pro}, author = {Yang Feng and Jianan Zhu}, organization = {New York University}, address = {New York, NY}, year = {2021}, url = {https://r02pro.github.io/}, } Then, each bibtex items can be cited directly within the documentation using the syntax @key, where key is the citation key in the first line of the entry, e.g., @r02pro will show as Feng and Zhu (2021) in the document. To put citations in parentheses, use [@key]. To cite more than one items, separate the keys by semicolons, e.g., [@key-a; @key-b; @key-c]. To suppress the author name, you can add a minus sign before @, e.g., [-@r02pro] will generate (2021). To learn more about citations and bibliography in R Markdown, you can read the excellent book by Xie, Dervieux, and Riederer (2020). References "],["case-study.html", "Chapter 12 A Case Study: 24 Solver", " Chapter 12 A Case Study: 24 Solver "],["references.html", "References", " References "]]
