[["attr-coercion.html", "2.3 Vectors: Attributes and Coercion", " 2.3 Vectors: Attributes and Coercion Having learned vectors in Section 2.2, we first introduce two commonly used numeric classes (integers and doubles), then introduce the concept of attributes from a named vector, and discuss the coercion rule when you combine values of different types into a single vector. 2.3.1 Integers and Doubles The two most commonly used numeric classes in R are integers and doubles. As the names suggest, a vector of integers contain integers, and a vector of double class contain double precision numeric values. One obvious benefit of integers over doubles is the significant save of memory. To create an integer vector, you can still use the c() function with the integers separated by comma as arguments. However, you need to put an “L” after each integer. Let’s create an integer and check its class(). my_int &lt;- c(1L, 3L, 4L) class(my_int) #&gt; [1] &quot;integer&quot; my_double &lt;- c(1, 3, 4) class(my_double) #&gt; [1] &quot;numeric&quot; In addition to class(), another useful function typeof() gives us the internal type of an R object, which tells how the information is stored. typeof(my_int) #&gt; [1] &quot;integer&quot; typeof(my_double) #&gt; [1] &quot;double&quot; From the typeof() results, my_int is stored as integers while my_double is stored as double precision numeric values. Note that although the object my_double looks to be an integer, it is stored as a double precision object. Another vector classes in R is complex, which stores complex numbers. my_complex &lt;- c(1 + 2i, 3 + 4i, -3 - 4i) my_complex #&gt; [1] 1+2i 3+4i -3-4i class(my_complex) #&gt; [1] &quot;complex&quot; typeof(my_complex) #&gt; [1] &quot;complex&quot; You can use the functions Re(), Im(), and Mod() to get the real part, imaginary part, and the modulus of the complex vector, respectively. Re(my_complex) #&gt; [1] 1 3 -3 Im(my_complex) #&gt; [1] 2 4 -4 Mod(my_complex) #&gt; [1] 2.236068 5.000000 5.000000 2.3.2 Named Vectors In addition to storing the values of a vector, you can also create named vectors. To do that, the first option is to give each element a name in the processing of creating the vector using the form of name = value. x_wo_name &lt;- c(165, 60, 22) x_wo_name #&gt; [1] 165 60 22 x_w_name &lt;- c(height = 165, weight = 60, BMI = 22) x_w_name #&gt; height weight BMI #&gt; 165 60 22 A second way to assign names to a vector is to use the names() function. For example, if we want to represent whether it snows on each day using a logical vector. y &lt;- c(TRUE, FALSE, TRUE) y #&gt; [1] TRUE FALSE TRUE names(y) &lt;- c(&quot;Jan 1&quot;, &quot;Jan 2&quot;, &quot;Jan 3&quot;) y #&gt; Jan 1 Jan 2 Jan 3 #&gt; TRUE FALSE TRUE Note that the assignment operation looks similar to the object assignment operation. The values for names need to be a character vector. The names of a vector is a type of attributes of R Objects. We will introduce other types of attributes as we encounter them. The name attribute provides additional information regarding the meaning of each element, and enables us to extract values using the names (to be discussed in Section 2.7.3). To examine the type and attributes of an R object, you can use the str() and attributes() function. str(x_w_name) #&gt; Named num [1:3] 165 60 22 #&gt; - attr(*, &quot;names&quot;)= chr [1:3] &quot;height&quot; &quot;weight&quot; &quot;BMI&quot; attributes(x_w_name) #&gt; $names #&gt; [1] &quot;height&quot; &quot;weight&quot; &quot;BMI&quot; str(x_wo_name) #&gt; num [1:3] 165 60 22 You can see that it is a named numeric vector, with the names attribute. The str() function also shows the first few values of the vector and the names. In contrast, str() function tells us x_wo_name is a plain numeric vector with no attributes. To directly extract certain attributes of an R object, you can use the attr() function on it with the second argument being the specific attribute you wish to extract. attr(x_w_name, &quot;names&quot;) #&gt; [1] &quot;height&quot; &quot;weight&quot; &quot;BMI&quot; 2.3.3 The coercion rule So far, you have known that vectors are objects that have values of the same type, including numbers, strings, or logical values. But in practice, you may have values with a mix of different types. If you still want to combine them into a vector, R will unify all values into the most complex one, which is usually called the coercion rule. Specifically, R uses the following order of complexity (from simple to complex). \\[\\mbox{logical} &lt; \\mbox{numeric} &lt; \\mbox{character}\\] Let’s see a few examples to learn how the coercion works. The first example mixes logical values with numbers. mix_1 &lt;- c(TRUE, 7, 24, FALSE) mix_1 #&gt; [1] 1 7 24 0 class(mix_1) #&gt; [1] &quot;numeric&quot; You can see that the logical values are converted to numbers, in particular, TRUE will be converted to 1 and FALSE will be converted to 0 when they appear with numbers, that’s because numbers are more complex than logical values, and R will unify all values into the most complex one. Then you will see that mix_1 is a numeric vector with four numbers. This is the most commonly usage of coercion rule in R. Besides the coercion rule which automatically converts all elements into the most complex type, you can also use functions to do the conversion manually. In particular, as.numeric() converts its argument into numeric type. And as.logical() converts its argument into logical values. as.numeric(c(TRUE, FALSE)) #&gt; [1] 1 0 as.logical(c(1, 0)) #&gt; [1] TRUE FALSE as.logical(c(&quot;TRUE&quot;, &quot;FALSE&quot;)) #&gt; [1] TRUE FALSE The second example mixes numbers with strings. mix_2 &lt;- c(8, &quot;happy&quot;, 26, &quot;string&quot;) mix_2 #&gt; [1] &quot;8&quot; &quot;happy&quot; &quot;26&quot; &quot;string&quot; class(mix_2) #&gt; [1] &quot;character&quot; You can see that both 8 and 26 are converted into strings since strings are more complex than numbers. Then mix_2 will be a character vector. To manually converts an input into a character type, you can use the as.character() function. as.character(1:5) #&gt; [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; The next example mixes logical values, numbers and strings. mix_3 &lt;- c(16, TRUE, &quot;pig&quot;) mix_3 #&gt; [1] &quot;16&quot; &quot;TRUE&quot; &quot;pig&quot; class(mix_3) #&gt; [1] &quot;character&quot; You can see in mix_3, both 97 and TRUE are converted to strings! That’s because values of character type are the most complex among all values. Here, you can use as.character() on the logical values. as.character(c(TRUE, FALSE)) #&gt; [1] &quot;TRUE&quot; &quot;FALSE&quot; Next, let’s see an interesting example in which we have two layers of coercion. mix_4 &lt;- c(c(16, TRUE), &quot;pig&quot;) mix_4 #&gt; [1] &quot;16&quot; &quot;1&quot; &quot;pig&quot; However, if you create another vector mix_4, you first have c(16, TRUE) which will be converted to c(16, 1) since numbers are more complex than logical values. Then, c(16, 1) will be converted to c(\"16\", \"1\") when you combine it with \"pig\", leading to the results of mix_4. 2.3.4 Exercises Let class1 &lt;- c(7, TRUE). Which of the following is the class of class1? numeric logical character Let class2 &lt;- c(7, TRUE, \"char\"). Which of the following is the class of class2? numeric logical character "]]
