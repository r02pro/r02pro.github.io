[["sort-vector.html", "2.4 Sort, Rank, &amp; Order", " 2.4 Sort, Rank, &amp; Order In the past two sections, you have mastered how to create vectors of different types including numeric, character and logical. In addition, you know how to create vectors with patterns. A vector usually contains more than one elements. Sometimes, you want to order the elements in various ways. In this section, we will introduce important functions that relate to ordering elements in a vector. 2.4.1 Numeric vectors Let’s start with numeric vectors. Firstly, let’s create a numeric vector which will be used throughout this part. x &lt;- c(2, 3, 2, 0, 4, 7) x #check the value of x a. Sort vectors The first function we will introduce is sort(). By default, the sort() function sorts elements in vector in the ascending order, namely from the smallest to largest. sort(x) #&gt; [1] 0 2 2 3 4 7 If you want to sort the vector in the descending order, namely from the largest to smallest, you can set a second argument decreasing = TRUE. sort(x, decreasing = TRUE) b. Ranks of vectors Next, let’s talk about ranks. The rank() function gives the ranks for each element of the vector, namely the corresponding positions in the ascending order. rank(x) #&gt; [1] 2.5 4.0 2.5 1.0 5.0 6.0 If you check the values of x, you can see that the smallest value of x is 0, which corresponds to the fourth element. Thus, the fourth element has rank 1. The second smallest value of x is 2, which is shared at the first and the third elements, resulting a tie (elements with the same value will result in a tie). Normally, these two elements would have ranks 2 and 3. To break the tie, the rank() function assigns all the elements involving in the tie (the first and third elements in this example) the same rank, which is average of all their ranks (the average of 2 and 3), by default. In addition to this default behavior for handling ties, rank() also provides other options by setting the ties.method argument. If you set ties.method = \"min\", all the tied elements will have the minimum rank instead of the average rank. In this case, the minimum rank is 2. rank(x, ties.method = &quot;min&quot;) #&gt; [1] 2 4 2 1 5 6 If you want to break the ties by the order element appears in the vector, you can set ties.method = \"first\". Then the earlier appearing element will have smaller ranks than the later one. In this example, the first element will have rank 2 and the third element has rank 3, since the first element appears earlier than the third element. There are other options for handling ties, which you can look up in the documentation of rank() if interested. rank(x, ties.method = &quot;first&quot;) #&gt; [1] 2 4 3 1 5 6 Unlike sort(), you can’t get positions in the descending order from the rank() function, which means you can’t add decreasing = TRUE in rank(). c. Order of vectors The next item we want to introduce is the order() function. Note that the function name order could be a bit misleading since ordering elements also has the same meaning of sorting. However, although it is related to sorting, order() is a very different function from sort(). Let’s recall the values of x and apply order() on x. x #&gt; [1] 2 3 2 0 4 7 order(x) #&gt; [1] 4 1 3 2 5 6 From the result, you can see that the order() function returns indices for the elements in the ascending order, namely from the smallest to the largest. For example, the first output is 4, indicating the 4th element in x is the smallest. The second output is 1, showing the 1st element in x is the second smallest. Unlike rank(), the order() function breaks the ties by the appearing order by default. If you want the indices corresponding to the descending order, then you can set decreasing = TRUE just like what we did in the sort() function. order(x, decreasing = TRUE) So far, we have covered sort(), rank() and order() functions for numeric vectors. It is helpful to provide a brief summary. The sort() function sorts elements in vectors. The rank() function will give ranks for each element of the vector. The order() function returns indices for the elements. 2.4.2 Character vectors Now, let’s move to character vectors. For character vectors, R uses the lexicographical ordering, which is sometimes called dictionary order since it is the order used in a dictionary. Similar to numeric vectors, let’s first prepare a character vector. Note that the strings in character vectors can contain letters, numbers, or symbols. char_vec &lt;- c(&quot;a&quot;, &quot;A&quot;, &quot;B&quot;, &quot;b&quot;, &quot;ab&quot;,&quot;aC&quot;, &quot;1c&quot;, &quot;.a&quot;, &quot;1a&quot;,&quot;2a&quot;,&quot;.a&quot;,&quot;&amp;u&quot;,&quot;3&quot;,&quot;_4&quot;) a. Ordering rules First, let’s discuss the ordering of a single character, including symbols, digits and letters. There are a few important ordering rules as follows. symbols &lt; digits &lt; letters: symbols appear first, followed by digits, and letters come last. symbols are ordered in the following way. syms &lt;- c(&quot; &quot;,&quot;,&quot;,&quot;;&quot;,&quot;_&quot;,&quot;(&quot;,&quot;)&quot;,&quot;!&quot;,&quot;[&quot;,&quot;]&quot;,&quot;{&quot;,&quot;}&quot;,&quot;-&quot;,&quot;*&quot;,&quot;/&quot;,&quot;#&quot;,&quot;$&quot;,&quot;%&quot;,&quot;^&quot;,&quot;&amp;&quot;,&quot;`&quot;,&quot;@&quot;,&quot;+&quot;,&quot;=&quot;,&quot;|&quot;,&quot;?&quot;,&quot;&lt;&quot;,&quot;&gt;&quot;,&quot;.&quot;) sort(syms) #&gt; [1] &quot; &quot; &quot;_&quot; &quot;-&quot; &quot;,&quot; &quot;;&quot; &quot;!&quot; &quot;?&quot; &quot;.&quot; &quot;(&quot; &quot;)&quot; &quot;[&quot; &quot;]&quot; &quot;{&quot; &quot;}&quot; &quot;@&quot; #&gt; [16] &quot;*&quot; &quot;/&quot; &quot;&amp;&quot; &quot;#&quot; &quot;%&quot; &quot;`&quot; &quot;^&quot; &quot;+&quot; &quot;&lt;&quot; &quot;=&quot; &quot;&gt;&quot; &quot;|&quot; &quot;$&quot; digits are in an ascending order: the smaller digits appear earlier than the bigger ones. nums &lt;- 0:9 sort(nums) #&gt; [1] 0 1 2 3 4 5 6 7 8 9 letters are alphabetically ordered, for the same letter，the lower case comes first. all_letters &lt;- c(letters,LETTERS) sort(all_letters) #&gt; [1] &quot;a&quot; &quot;A&quot; &quot;b&quot; &quot;B&quot; &quot;c&quot; &quot;C&quot; &quot;d&quot; &quot;D&quot; &quot;e&quot; &quot;E&quot; &quot;f&quot; &quot;F&quot; &quot;g&quot; &quot;G&quot; &quot;h&quot; #&gt; [16] &quot;H&quot; &quot;i&quot; &quot;I&quot; &quot;j&quot; &quot;J&quot; &quot;k&quot; &quot;K&quot; &quot;l&quot; &quot;L&quot; &quot;m&quot; &quot;M&quot; &quot;n&quot; &quot;N&quot; &quot;o&quot; &quot;O&quot; #&gt; [31] &quot;p&quot; &quot;P&quot; &quot;q&quot; &quot;Q&quot; &quot;r&quot; &quot;R&quot; &quot;s&quot; &quot;S&quot; &quot;t&quot; &quot;T&quot; &quot;u&quot; &quot;U&quot; &quot;v&quot; &quot;V&quot; &quot;w&quot; #&gt; [46] &quot;W&quot; &quot;x&quot; &quot;X&quot; &quot;y&quot; &quot;Y&quot; &quot;z&quot; &quot;Z&quot; Here, letters is a character vector precreated by R, it has all 26 letters in the alphabet with lower case. And LETTERS is another character vector, which has all 26 letters in the alphabet with upper case. b. Sort vectors As before, you can apply sort() on character vectors. Basically, the elements of character vectors ordered by the first character of their values, move to the second character if there are ties in the first character (same first character), and look at more characters until the ties are broken or run out of characters. sort(char_vec) #&gt; [1] &quot;_4&quot; &quot;.a&quot; &quot;.a&quot; &quot;&amp;u&quot; &quot;1a&quot; &quot;1c&quot; &quot;2a&quot; &quot;3&quot; &quot;a&quot; &quot;A&quot; &quot;ab&quot; &quot;aC&quot; #&gt; [13] &quot;b&quot; &quot;B&quot; We have the following observations. Symbols appear first, followed by digits, and letters come last. According to the ordering rule of symbols, _4 is the first, .a should be the second and &amp;u is the third. 1a and 1c have the same first character, since a comes before c, 1a comes before 1c. ab and aC have the same first character, since b comes before C (regardless of the case), ab comes before aC. Of course, we can also have the order reversed by setting decreasing = TRUE. sort(char_vec, decreasing = TRUE) c. Ranks of vectors Similarly, you can look at the rank for each element according to the ordering rules. Here, the element with rank 1 is _4 and .a has rank 2. Just like numeric vectors, if you have elements with the same value in character vectors, the rank of these elements will be the same (the average of the corresponding ranks) by default. rank(char_vec) #&gt; [1] 9.0 10.0 14.0 13.0 11.0 12.0 6.0 2.5 5.0 7.0 2.5 4.0 #&gt; [13] 8.0 1.0 As expected, you can set the ties.method argument in rank() to use other methods for breaking ties. rank(char_vec, ties.method = &quot;min&quot;) rank(char_vec, ties.method = &quot;first&quot;) d. Order of vectors Again, you can get the indices for each element in character vectors with the same order() function like that for numeric vectors. Also, the order() function breaks the ties by the appearing order by default. order(char_vec) #&gt; [1] 14 8 11 12 9 7 10 13 1 2 5 6 4 3 The decreasing argument still works for order()! order(char_vec, decreasing = TRUE) #&gt; [1] 3 4 6 5 2 1 13 10 7 9 12 8 11 14 2.4.3 Logical vectors Since there are only two possible values TRUE and FALSE for logical vectors, it is straightforward to sort them with the knowledge of FALSE &lt; TRUE. You can try the following example. logi_vec &lt;- c(TRUE, FALSE, FALSE, TRUE, TRUE) sort(logi_vec) rank(logi_vec) order(logi_vec) 2.4.4 Exercise You can run the following code to do the exercise. r02pro(2) "],["comparison-vector-subsetting.html", "2.6 Comparisons, Vector Subsetting &amp; Change Values", " 2.6 Comparisons, Vector Subsetting &amp; Change Values By now, you are more than familiar with the simplest type of R objects—vector, and you can create vectors and apply many useful functions on vectors. Sometimes you may be wondering how to extract certain elements from a vector? In this section, we will introduce some new operations on vectors that can help you get the desired subset vector. 2.6.1 Comparisons on vectors of the same type The first type of operations we want to introduce is making comparisons between two vectors of the same type. Similar to the arithmetic operations between two numeric vectors in Section 2.2, we normally want to compare two vectors of the same length, but we can also compare two vectors of different lengths according to the recycling rule in R. a. Compare two vectors of the same length If two vectors are of the same length, the comparison is done elementwisely, just like the arithmetic operations in Section 2.2. Let’s take numeric vectors for example. You can create a numeric vector x with value 3, and compare it to another numeric vector 2 to find out whether the value of x is smaller than 2 or not. x &lt;- 3 x &lt; 2 #&gt; [1] FALSE Since 3 is bigger than 2, you will certainly get FALSE! In addition to the less than sign &lt;, there are a few other commonly useful operators for doing comparisons. x &lt; 2 #less x &lt;= 2 #less or equal x &gt; 1 #bigger x &gt;= 1 #bigger or equal x == 3 #equal #x = 3 #assignment operator x != 3 #not equal Note that if you want to check whether two vectors are equal, you have to use two equal signs as a single operator, which is ==, to do comparisons. If only one equal sign is used, it would work like an assignment operator. In addition, you can use an exclamation mark together with a equal sign, which is !=, to find out whether two vectors are not equal. Note that as we explained in Section 2.1.2, sometimes you need to execute an R expression because you can get its object type and value from the result. Here, you may notice that you get TRUE or FALSE as the result from the codes above. Since TRUE and FALSE are logical values (there are no pairs of double quotes around TRUE’s and FALSE’s when you use them as logical values), you know that all comparison operations generate logical vectors. Of course, you can assign the result to a name for future use. Let’s take x &gt; 1 for example. class(x &gt; 1) length(x &gt; 1) big1 &lt;- x &gt; 1 big1 class(big1) So x &gt; 1 and big1 are both logical vectors with length one. Also, you can create two length&gt;1 numeric vectors y and z with the same length, then do comparisons between them. y &lt;- c(3,5,7,5,3) z &lt;- c(2,6,7,6,3) y &gt; z #&gt; [1] TRUE FALSE FALSE FALSE FALSE From the result, you can see that y &gt; z is a length-5 logical vector. The values of y &gt; z are obtained by making elementwise comparisons between the corresponding elements in these two vectors. big2 &lt;- y &gt; z big2 class(big2) which(big2) By assigning y &gt; z to a big2, you create another logical vector. Here, the which() function returns the locations of all TRUE values, so you will get a result of 1 for big2. You can also compare two character vectors, which works by comparing the corresponding strings in the same location. The rule for comparison is the alphabetically order explained in Section 2.4.2. Similar to comparing numerical vectors, we also use two equal signs == to check whether the corresponding elements in the two input vectors have the same value. Let’s first create two character vectors with the same length, then use == to compare them. Since the expression of this comparison is again a logical vector, you can create a new logical vector same1 and get the locations of TRUE values. animals &lt;- c(&quot;pig&quot;, &quot;monkey&quot;, &quot;pig&quot;) zoo &lt;- c(&quot;sheep&quot;, &quot;monkey&quot;, &quot;pig&quot;) same1 &lt;- animals == zoo which(same1) Comparisons between logical vectors work similarly as character vectors, where we usually use == or != to compare corresponding elements in logical vectors. Here are the examples. logi1 &lt;- c(TRUE, FALSE, FALSE) logi2 &lt;- c(TRUE, TRUE, TRUE) same2 &lt;- logi1 == logi2 which(same2) which(logi1 != logi2) b. Compare between one vector with length &gt; 1 and another vector with length 1 The recycling rule also works for the comparison operations in R. With an vector of length 1, you can compare the value of it to the values of another vector with more than one elements one by one, which generates a logical vector as the result. The length of the logical vector will be the same as that of the longer vector. Here are some examples. y != x animals == &quot;pig&quot; log1 == TRUE #&gt; Error in eval(expr, envir, enclos): object &#39;log1&#39; not found Of course you can assign the values of results to names and get locations of TRUE values by using the which() function. Try it by yourself! 2.6.2 Comparisons on vectors of different types You can also make comparisons between two vectors of different types. Of course this operation also follow the rules that vectors are of the same length or comparing vectors of different length according to the recycling rule. But how can we compare vectors of different types? Similar to the coercion rule in Section 2.2.4, values of corresponding elements will be unified into the more complex one when making comparisons between two vectors. The order of complexity from simple to complex is still logical &lt; numeric &lt; character. Let’s try to compare between a numeric vector and a logical vector, a &lt;- c(-1, 0, 1) b &lt;- c(TRUE, FALSE, TRUE) a == b #&gt; [1] FALSE TRUE TRUE Then you will get a length-3 logical vector. In a == b, the first element is obtained by using == to compare -1 and TRUE, then R will convert TRUE to 1 and make comparison between -1 and 1 since numbers are more complex than logical values. The second and third elements are also obtained in a similar fashion. This is the most common use of comparisons between vectors of different types. Of course you can make comparisons between vectors of other types, but we won’t introduce in our book due to space constraints. However, you are welcome to try some by yourself! 2.6.3 Vector subsetting Sometimes you may want to extract particular elements from a vector, then the extracted elements will constitute a new vector, which is a subset vector of the original vector. This process is called vector subsetting, and the subset vector will be of the same type as the original one. In this part, we will introduce two common ways to do vector subsetting in R. Before we get started, let’s create a vector which will be used throughout this part. h &lt;- c(3,1,4,2,90) a. Use logical vectors to do vector subsetting Firstly, we introduce how to use logical vectors to do vector subsettings. You need to use a pair of square brackets [ ] after a vector, then put a logical vector of the same length as the original vector inside the square brackets. Here is an example, h[c(TRUE, FALSE, TRUE, FALSE, TRUE)] #&gt; [1] 3 4 90 From the result, you can see that the values from h with the same positions of TRUEs are extracted. Since 3, 4 and 90 are parts of the values of h, the vector composed of 3 4 90 is a subset vector of h. So if you assign these three values to a name, you will get a named subset vector of sub1. sub1 &lt;- h[c(TRUE, FALSE, TRUE, FALSE, TRUE)] sub1 #&gt; [1] 3 4 90 In addition to writing the logical vector in an explicit form, you can also use a named logical vector or an expression whose result is a logical vector. Let’s say we want to extract a subvector of h for the values larger than 2. Then you can make a comparison between h and 2. big3 &lt;- h &gt; 2 big3 #&gt; [1] TRUE FALSE TRUE FALSE TRUE and get a logical vector big3. Then you may notice that big3 and h &gt; 2 have the same values as c(TRUE, FALSE, TRUE, FALSE, TRUE), so you can also put big3 or h &gt; 2 into [ ], and you will get a numeric vector with 3 4 90 as values. h[c(TRUE, FALSE, TRUE, FALSE, TRUE)] h[big3] h[h &gt; 2] If you create a character vector home and compare it to \"pig\", you will get another logical vector same3. Let’s try to use same3 to do vector subsetting on h. home &lt;- c(&quot;pig&quot;, &quot;monkey&quot;, &quot;pig&quot;, &quot;monkey&quot;, &quot;pig&quot;) same3 &lt;- home == &quot;pig&quot; sub2 &lt;- h[same3] sub2 #&gt; [1] 3 4 90 Awesome! You still get the result of 3 4 90! As a result, only if the logical vectors you used have the same values, you will get the same result after doing vector subsetting. Of course you can do vector subsetting on character vectors or logical vectors, notice that the result will be the same type as the original one. Try the following code by yourself. home[same3] home[big3] lg &lt;- c(TRUE, FALSE, FALSE, FALSE, TRUE) lg[same3] lg[big3] b. Use indices to do vector subsetting Next, we will introduce how to use indices to do vector subsetting. To achieve this goal, you need to put a numeric vector into [ ], for example, h[c(2,4)] #return values of the 2nd and 4th elements #&gt; [1] 1 2 Then you will get values of the 2nd and 4th elements in h. If you add a minus sign - before the numeric vector, you will get values except the 2nd and 4th elements in h. h[-c(2,4)] #return values except the 2nd and 4th elements #&gt; [1] 3 4 90 Similar to use logical vectors to do vector subsetting, only if the numeric vectors have the same values, you will get the same result after doing vector subsetting. indices &lt;- c(2,4) sub3 &lt;- h[indices] sub3 Also, you can get subset vectors of character vectors or logical vectors according to indices. home[indices] lg[indices] In conclusion, there are two ways to get a subset vector of h with values bigger than 2. h &lt;- c(3,1,4,2,90) h[h &gt; 2] #h &gt; 2 will return TRUE if the element in h has value bigger than 2 h[c(1,3,5)] #It&#39;s clear to see that the first, third and fifth elements have values bigger than 2 2.6.4 Change values in named vectors a. Change all values in subsets of vectors Now you must be curious about why do we need to get subsets of vectors. Firstly let’s review values of vector h and get a subset of it. (There are two ways to do vector subsetting, here we choose to use indices to get the subset) h &lt;- c(3,1,4,2,90) h[c(2,4)] Obviously you will get a numeric vector with 1 and 2 as the values. Then we will introduce how to change values in subsets of h and put it back into h without changing other values, this is a very important usage of doing vector subsetting. You just need to assign new values to the subset, then you can verify the values of h, here is the example, h[c(2,4)] &lt;- 10 h #&gt; [1] 3 10 4 10 90 From the result, you can see that only 1 and 2 have been changed to 10, which means you have successfully change the parts of h! b. Define the vector again Another way to change values in named vectors is to do object assignment again on this vector, then you can change all values of it without changing the name. In Section 2.1, you have learned about checking all the named objects and their values in the environment. So let’s review values of vector h from this panel together. Figure 2.1: Values of h (1) Now we all know that h is a numeric vector with 5 values. Then let’s try to do an object assignment again, this time you can assign different values to h and see what will happen to h. h &lt;- c(1,2,3,4,5) h #&gt; [1] 1 2 3 4 5 Then you can see that the values of h have been changed to the new ones! Another easier way to verify values of h is from the environment, so it is a good habit to monitor the environment from time to time to make sure everything look fine. Figure 2.2: Values of h (2) You can assign any values to h as you want, then h may change the vector type or even the object type according to the values assigned. By running the following code, h will be a character vector with three strings. h &lt;- c(&quot;pig&quot;, &quot;monkey&quot;, &quot;panda&quot;) Figure 2.3: Values of h (3) If you assign values of the subset to a name, you will create a new named vector. Now hs is not the subset of h, it is a vector with the same value as the subset. If you assign differnt value(s) to hs, there will be no change on h. h &lt;- c(3,1,4,2,90) hs &lt;- h[c(2,4)] hs &lt;- 10 h 2.6.5 Exercises "],["logical-operators.html", "2.7 Logical Operators", " 2.7 Logical Operators In last section, you learned how to do vector subsetting, which yields a subvector of the original vector. Let’s take a numeric vector x &lt;- 1:5 for example. In order to get a subvector of x with values bigger than 3, you can first create a logical vector xb3 &lt;- x &gt; 3, then use the xb3 as the index to do vector subsetting. x &lt;- 1:5 xb3 &lt;- x &gt; 3 set1 &lt;- x[xb3] set1 #&gt; [1] 4 5 Here, the numeric vector set1 has values 4 5. You can get another subvector of x by running the following codes. xs4 &lt;- x &lt;= 4 set2 &lt;- x[xs4] Sometimes, you may want to get a subvector with more than one conditions. For example, how can we find the subvector of x with values larger than 3 and less than or equal to 4? In this section, we will introduce several logical operators and use them to get subvectors. Here, we only introduce how to apply these operators on logical vectors. Before we get started, let’s create another numeric vector y and compare it to 8 and 9 separately, then you will get two logical vectors with same values as xb3 and xs4. y &lt;- 6:10 yb8 &lt;- y &gt; 8 #xb3 is the same as yb8 ys9 &lt;- y &lt;= 9 #xs4 is the same as ys9 2.7.1 NOT operator by ! The first operator we want to introduce is !, often called the NOT operator. Let’s see what happens if you apply the NOT operator on a logical vector, !c(FALSE, FALSE, FALSE, TRUE, TRUE) #the opposite of a logical vector #&gt; [1] TRUE TRUE TRUE FALSE FALSE From the result, you get another logical vector with the same length as the original one. The value of each element in the new vector is the opposite of the corresponding value in the original vector. It is intuitive to understand since if something is NOT FALSE, then it is TRUE; and if it is NOT TRUE, then it has to be FALSE. Since xb3 is also a logical vector, you can try to apply ! on xb3, and use !xb3 (which is also a logical vector) to do vector subsetting. Guess what will you get? !xb3 #&gt; [1] TRUE TRUE TRUE FALSE FALSE set3 &lt;- x[!xb3] set3 #&gt; [1] 1 2 3 Of course the resulting numeric vector set3 will have 1 2 3 as values! As a result, set1 and set3 are complement of each other from the whole vector x. From Section 2.6, you have learned that if the logical vectors you use are identical, you will get the same result after doing vector subsetting. So if you use !yb8 to do vector subsetting, you will get a vector with the same result as that when you use set3. x[!yb8] #&gt; [1] 1 2 3 2.7.2 AND operator by &amp; Secondly, we will introduce the AND operator &amp;. Similar to making comparisons between two logical vectors, &amp; performs comparisons elementwisely, which generates a vector with the same length if the input logical vectors are of the same length or with the same length as that of the longer vector. For each location of the resulting vector, the value will be TRUE if both values in the same location of the input two vectors are both TRUE, and will be FALSE otherwise. In particular, for each element, we have the following summary. Operation Result TRUE &amp; TRUE TRUE TRUE &amp; FALSE FALSE FALSE &amp; TRUE FALSE FALSE &amp; FALSE FALSE Let’s see an example of the AND operation between two logical vectors of the same length. c(FALSE, FALSE, FALSE, TRUE, TRUE) &amp; c(TRUE, TRUE, FALSE, TRUE, FALSE) #&gt; [1] FALSE FALSE FALSE TRUE FALSE As explained before, the AND operator works elementwisely and the intermediate step is as below. c(FALSE &amp; TRUE, FALSE &amp; TRUE, FALSE &amp; FALSE, TRUE &amp; TRUE, TRUE &amp; FALSE) #&gt; [1] FALSE FALSE FALSE TRUE FALSE As you can see from the result, only the fourth element is TRUE since the fourth element of both input logical vectors is TRUE. Since the AND operator makes comparisons elementwisely, the recycling rule also works here. But normally we want one vector with length &gt; 1 and another one with length 1. c(FALSE, FALSE, FALSE, TRUE, TRUE) &amp; FALSE #&gt; [1] FALSE FALSE FALSE FALSE FALSE After learning about the AND operator, you can now get a subvector of x with value(s) &gt; 3 and &lt;= 4 easily. At the beginning of this section, you have created two logical vectors xb3 and xs4 by making comparisons, then let’s apply &amp; on these vectors, xb3 &amp; xs4 #&gt; [1] FALSE FALSE FALSE TRUE FALSE From the result, you know that both xb3 and xs4 have value TRUE for the fourth element, which means the statement that the value is &gt; 3 and &lt;= 4 is TRUE for the fourth element in x. Then you can use xb3 &amp; xs4 (a logical vector) to do vector subsetting. x[xb3 &amp; xs4] #&gt; [1] 4 Here, you get a subvector of x with value 4. Since xs4 and ys9 have same values, you will get the same result if you include ys9 to get a subvector. You can try the following codes by yourself. x[xb3 &amp; ys9] x[yb8 &amp; ys9] Note that the logical vector used to do vector subsetting needs to be of the same length as the original vector. Since x and y have the same length, the logical vectors from above can be used to get subvectors of y as well. You will get the same result from the following four codes. y[xb3 &amp; xs4] y[yb8 &amp; ys9] y[xb3 &amp; ys9] y[yb8 &amp; xs4] 2.7.3 OR operator by | The OR operator | works similarly to the AND operator &amp;, but the difference is that | returns TRUE if there is at least one TRUE among the two elements at the same location in two vectors. Let’s go through some examples together. Operation Result TRUE | TRUE TRUE TRUE | FALSE TRUE FALSE | TRUE TRUE FALSE | FALSE FALSE Let’s try another example on length &gt; 1 vectors and compare the result with that when we use the AND operator &amp;. c(FALSE, FALSE, FALSE, TRUE, TRUE) | c(TRUE, TRUE, FALSE, TRUE, FALSE) #&gt; [1] TRUE TRUE FALSE TRUE TRUE c(FALSE, FALSE, FALSE, TRUE, TRUE) &amp; c(TRUE, TRUE, FALSE, TRUE, FALSE) #&gt; [1] FALSE FALSE FALSE TRUE FALSE You also get a length-5 logical vector with an elementwise OR operation |, which is very different from the result with AND operation &amp;. Of course you can also use xb3 | xs4 to do vector subsetting, with it being another length-5 logical vector. x[xb3 | xs4] #&gt; [1] 1 2 3 4 5 Wow! You get all five elements of x! That’s because the statement that the value is either &gt; 3 or &lt;= 4 is TRUE for all elements in x. 2.7.4 Exclusive OR by xor Last but not least, we introduce the exclusive OR operator xor. From the name, it’s easy to know that xor is an extended form of |. Here are some examples, Operation Result xor(TRUE, TRUE) FALSE xor(TRUE, FALSE) TRUE xor(FALSE, TRUE) TRUE xor(FALSE, FALSE) FALSE Different from the OR operator, xor() returns TRUE when there is one and only one TRUE among values of these two logical vectors. If these two vectors have the same value, both TRUE or both FALSE, you will get the value FALSE. For two length &gt; 1 vectors, xor() performs comparisons elementwisely. You can check the result by yourself! xor(c(FALSE, FALSE, FALSE, TRUE, TRUE), c(TRUE, TRUE, TRUE, TRUE, FALSE)) #&gt; [1] TRUE TRUE TRUE FALSE TRUE Since you also get a logical vector after applying xor(), you can use it to do vector subsetting. Using different combinations to do vector subsetting is interesting. Try them! x[xor(xb3, xs4)] y[xor(!xb3, ys9)] y[xor(yb8, !ys9)] 2.7.5 Summary of Logical Operators Let’s summarize the logical operators between two vectors. The NOT operator ! gives the opposite of each value. The AND operator &amp; returns TRUE if both are TRUE. The OR operator | returns TRUE if at least one is TRUE. The exclusive OR operator xor() returns TRUE if one and only one is TRUE. 2.7.6 Exercise "]]
